// Copyright 2020-2022 Buf Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

syntax = "proto3";

package buf.alpha.registry.v1alpha1;

// GoConfig is the configuration for a Go plugin.
message GoConfig {
  // RuntimeLibrary describes the runtime library dependency of the generated code.
  message RuntimeLibrary {
    // The name of the runtime library module, i.e. "google.golang.org/protobuf".
    string module = 1;
    // The version of the runtime library, i.e. "v1.27.1".
    string version = 2;
  }
  // Optionally define the runtime libraries for the plugin.
  repeated RuntimeLibrary runtime_libraries = 1;
  // Optionally define the minimum Go version required by the plugin (e.g. 1.18)
  string minimum_version = 2;
}

// NPMConfig is the configuration for a JavaScript NPM plugin.
message NPMConfig {
  // RuntimeLibrary describes the runtime library dependency of the generated code.
  message RuntimeLibrary {
    // The name of the runtime library package, i.e. "@grpc/grpc-js".
    string package = 1;
    // The version of the runtime library, i.e. "^1.27.1".
    string version = 2;
  }
  // Optionally define the runtime libraries for the plugin.
  repeated RuntimeLibrary runtime_libraries = 1;
}

// RuntimeConfig is the configuration for the runtime of a plugin.
message RuntimeConfig {
  oneof runtime_config {
    GoConfig go_config = 1;
    NPMConfig npm_config = 2;
  }
}

// RemotePluginReference is the fully-qualified representation for
// a specific plugin version.
message RemotePluginReference {
  // The plugin's remote (e.g. 'buf.build').
  string remote = 1;
  // The plugin's owner (e.g. 'protocolbuffers').
  string owner = 2;
  // The plugin's name (e.g. 'go').
  string plugin = 3;
  // The plugin's version (e.g. 'v1.0.0').
  string version = 4;
}

// RemotePlugin represents a remote plugin.
//
// TODO: This really ought to just be referred to as a 'Plugin',
// but that would collide with the 'Plugin' message that already
// exists in this package today. Let's change this as soon as we
// can / before it's released.
//
// TODO: This is currently structured similar to the Module abstraction,
// such that it excludes the ID and the fully-quaified plugin name
// (e.g. 'buf.build/protocolbuffers/go:v1.0.0'). In its current form, the
// message stands on its own and isn't tied to a specific plugin version.
// This also makes it more easily mapped from the internal representation
// (often created from a local buf.plugin.yaml file) that doesn't have an
// ID associated with it.
//
// However, this means it's a little harder to work with endpoints that require
// the ID and/or RemotePluginReference (e.g. ListRemotePlugins). For that
// endpoint, we really ought to have another type that includes these fields so
// that the individual RemotePlugin instances are distinguishable.
//
// TL;DR We need to consider whether or not we should be consistent with the
// Module abstraction, or always assign the fully-qualified plugin name and ID
// here (which is what we currently planned for the curated plugins). There are
// more notes about this in the ListRemotePlugins endpoint comment below.
message RemotePlugin {
  // List of default plugin options in the form "{option}={defaultOption}"
  repeated PluginOption options = 1;
  // The configuration for the runtime of the plugin.
  RuntimeConfig runtime_config = 2;
  // List of plugin dependencies in the form "{remote}/{owner}/{name}:{version}"
  //
  // TODO: Note that this field is not currently exposed to the user.
  repeated RemotePluginReference dependencies = 3;
  // The full container image digest associated with this plugin, including the
  // algorithm (e.g. "sha256:a12kja").
  //
  // Ref: https://github.com/opencontainers/image-spec/blob/main/descriptor.md#digests
  string container_image_digest = 4;
  // Optionally specify the URL leading to the source code of the plugin, if available.
  string source_url = 5;
  // Optionally specify a brief description of the plugin functionality.
  string description = 6;
}

// PluginOption is an option passed into the plugin when it's executed.
message PluginOption {
  // The name of the option.
  string name = 1;
  // The value of the option. For now, this is always
  // a string - we add the explicit 'string_' prefix to
  // the field name so that it can more easily evolve into
  // a oneof later on.
  //
  //  oneof value {
  //    string string_value = 2;
  //    bool bool_value = 3;
  //    int64 int_value = 4;
  //  }
  //
  string string_value = 2;
}

message CreateRemotePluginRequest {
  // The owner of the plugin, e.g. "protocolbuffers".
  string owner = 1;
  // The name of the plugin, e.g. "go".
  string name = 2;
  // The plugin that is being created.
  //
  // TODO: If the RemotePlugin is updated to include
  // an ID and fully-qualified name, the fields used
  // to create the plugin should be flattened out here
  // rather than re-using the RemotePlugin message.
  //
  // For example,
  //
  //  message CreateRemotePluginRequest {
  //    string owner = 1;
  //    string name = 2;
  //    repeated PluginOption options = 3;
  //    RuntimeConfig runtime_config = 4;
  //    ...
  //  }
  //
  // Note that this is currently symmetrical with the
  // PushRequest used for modules.
  RemotePlugin plugin = 3;
}

message CreateRemotePluginResponse {
  // The created plugin reference.
  RemotePluginReference plugin_reference = 1;
}

message ListRemotePluginsRequest {
  uint32 page_size = 1;
  // The first page is returned if this is empty.
  string page_token = 2;
  bool reverse = 3;
}

message ListRemotePluginsResponse {
  // TODO: We need to include the ID and fully-qualified
  // name of the plugins here - otherwise the plugins are
  // indistinguishable from one another.
  //
  // One option would be that there are two messages:
  //
  //  // Plugin represents a plugin. Note that this is actually
  //  // the RemotePlugin message in its current form, but renamed.
  //  message Plugin {
  //    repeated PluginOption options = 1;
  //    RuntimeConfig runtime_config = 2;
  //    ...
  //  }
  //
  //  // RemotePlugin represents a remote-identifiable plugin.
  //  message RemotePlugin {
  //    string id = 1;
  //    RemotePluginReference name = 2;
  //
  //    // The following fields are the same ones specified in
  //    // the Plugin message, but flattened for usability and
  //    // extensibility.
  //    repeated PluginOption options = 3;
  //    RuntimeConfig runtime_config = 4;
  //    ...
  //    // This representation would also have a timestamp, whereas
  //    // the other would not.
  //    google.protobuf.Timestamp create_time = 10;
  //  }
  //
  // The naming might not be ideal here - the main idea is to separate
  // the identifiable fields into a separate message.
  repeated RemotePlugin plugins = 1;
  // There are no more pages if this is empty.
  string next_page_token = 2;
}

// RemotePluginService manages remote plugins.
service RemotePluginService {
  // ListRemotePlugins returns all the remote plugins available.
  rpc ListRemotePlugins(ListRemotePluginsRequest) returns (ListRemotePluginsResponse);
  // CreateRemotePlugin creates a new remote plugin.
  rpc CreateRemotePlugin(CreateRemotePluginRequest) returns (CreateRemotePluginResponse);
}
