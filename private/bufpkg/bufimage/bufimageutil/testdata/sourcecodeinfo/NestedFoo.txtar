-- google/protobuf/any.proto --
// Protocol Buffers - Google's data interchange format
// Copyright 2008 Google Inc.  All rights reserved.
// https://developers.google.com/protocol-buffers/
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
syntax = "proto3";
package google.protobuf;
option csharp_namespace = "Google.Protobuf.WellKnownTypes";
option go_package = "google.golang.org/protobuf/types/known/anypb";
option java_multiple_files = true;
option java_outer_classname = "AnyProto";
option java_package = "com.google.protobuf";
option objc_class_prefix = "GPB";
// `Any` contains an arbitrary serialized protocol buffer message along with a
// URL that describes the type of the serialized message.
//
// Protobuf library provides support to pack/unpack Any values in the form
// of utility functions or additional generated methods of the Any type.
//
// Example 1: Pack and unpack a message in C++.
//
//     Foo foo = ...;
//     Any any;
//     any.PackFrom(foo);
//     ...
//     if (any.UnpackTo(&foo)) {
//       ...
//     }
//
// Example 2: Pack and unpack a message in Java.
//
//     Foo foo = ...;
//     Any any = Any.pack(foo);
//     ...
//     if (any.is(Foo.class)) {
//       foo = any.unpack(Foo.class);
//     }
//     // or ...
//     if (any.isSameTypeAs(Foo.getDefaultInstance())) {
//       foo = any.unpack(Foo.getDefaultInstance());
//     }
//
//  Example 3: Pack and unpack a message in Python.
//
//     foo = Foo(...)
//     any = Any()
//     any.Pack(foo)
//     ...
//     if any.Is(Foo.DESCRIPTOR):
//       any.Unpack(foo)
//       ...
//
//  Example 4: Pack and unpack a message in Go
//
//      foo := &pb.Foo{...}
//      any, err := anypb.New(foo)
//      if err != nil {
//        ...
//      }
//      ...
//      foo := &pb.Foo{}
//      if err := any.UnmarshalTo(foo); err != nil {
//        ...
//      }
//
// The pack methods provided by protobuf library will by default use
// 'type.googleapis.com/full.type.name' as the type URL and the unpack
// methods only use the fully qualified type name after the last '/'
// in the type URL, for example "foo.bar.com/x/y.z" will yield type
// name "y.z".
//
// JSON
// ====
// The JSON representation of an `Any` value uses the regular
// representation of the deserialized, embedded message, with an
// additional field `@type` which contains the type URL. Example:
//
//     package google.profile;
//     message Person {
//       string first_name = 1;
//       string last_name = 2;
//     }
//
//     {
//       "@type": "type.googleapis.com/google.profile.Person",
//       "firstName": <string>,
//       "lastName": <string>
//     }
//
// If the embedded message type is well-known and has a custom JSON
// representation, that representation will be embedded adding a field
// `value` which holds the custom JSON in addition to the `@type`
// field. Example (for message [google.protobuf.Duration][]):
//
//     {
//       "@type": "type.googleapis.com/google.protobuf.Duration",
//       "value": "1.212s"
//     }
//
message Any {
  // A URL/resource name that uniquely identifies the type of the serialized
  // protocol buffer message. This string must contain at least
  // one "/" character. The last segment of the URL's path must represent
  // the fully qualified name of the type (as in
  // `path/google.protobuf.Duration`). The name should be in a canonical form
  // (e.g., leading "." is not accepted).
  //
  // In practice, teams usually precompile into the binary all types that they
  // expect it to use in the context of Any. However, for URLs which use the
  // scheme `http`, `https`, or no scheme, one can optionally set up a type
  // server that maps type URLs to message definitions as follows:
  //
  // * If no scheme is provided, `https` is assumed.
  // * An HTTP GET on the URL must yield a [google.protobuf.Type][]
  //   value in binary format, or produce an error.
  // * Applications are allowed to cache lookup results based on the
  //   URL, or have them precompiled into a binary to avoid any
  //   lookup. Therefore, binary compatibility needs to be preserved
  //   on changes to types. (Use versioned type names to manage
  //   breaking changes.)
  //
  // Note: this functionality is not currently available in the official
  // protobuf release, and it is not used for type URLs beginning with
  // type.googleapis.com. As of May 2023, there are no widely used type server
  // implementations and no plans to implement one.
  //
  // Schemes other than `http`, `https` (or the empty scheme) might be
  // used with implementation specific semantics.
  //
  string type_url = 1;
  // Must be a valid serialized protocol buffer of the above specified type.
  bytes value = 2;
}
-- test.proto --
// Keep 1: comment on syntax
syntax = "proto2";
// Keep 2: comment on package
package foo.bar;
// Keep if NestedFoo: comment on import any.proto
import "google/protobuf/any.proto";
// Keep 3: comment on option
option go_package = "foo.bar/baz";
message Foo {
  // Keep if NestedFoo: comment on message NestedFoo
  message NestedFoo {
    // We keep the following comment for Foo + ext because we don't
    // discard options or option comments even if we're only retaining
    // a message as a namespace for another retained element.
    // Keep if NestedFoo: comment on field uid
    optional uint64 uid = 1;
    // Keep if NestedFoo: comment on field meta
    repeated google.protobuf.Any meta = 2;
    // Keep if NestedFoo: comment on field state
    optional State state = 3;
    // Keep if NestedFoo: comment on enum State
    enum State {
      // Keep if NestedFoo: comment on enum value STATE_UNSPECIFIED
      STATE_UNSPECIFIED = 0;
      // Keep if NestedFoo: comment on enum value STATE_GOOD
      STATE_GOOD = 1;
    }
  }
}
-- source_code_info.json --
{
  "location": [
    {
      "span": [
        1,
        0,
        153,
        1
      ]
    },
    {
      "path": [
        12
      ],
      "span": [
        1,
        0,
        18
      ],
      "leadingComments": " Keep 1: comment on syntax\n"
    },
    {
      "path": [
        2
      ],
      "span": [
        4,
        0,
        16
      ],
      "leadingComments": " Keep 2: comment on package\n"
    },
    {
      "path": [
        8
      ],
      "span": [
        7,
        0,
        34
      ]
    },
    {
      "path": [
        8,
        11
      ],
      "span": [
        7,
        0,
        34
      ],
      "leadingComments": " Keep 3: comment on option\n"
    },
    {
      "path": [
        3,
        0
      ],
      "span": [
        16,
        0,
        40
      ],
      "leadingComments": " Keep if NestedFoo: comment on import any.proto\n"
    },
    {
      "path": [
        11,
        0
      ],
      "span": [
        16,
        7,
        11
      ]
    },
    {
      "path": [
        4,
        0
      ],
      "span": [
        40,
        0,
        89,
        1
      ]
    },
    {
      "path": [
        4,
        0,
        1
      ],
      "span": [
        40,
        8,
        11
      ]
    },
    {
      "path": [
        4,
        0,
        3,
        0
      ],
      "span": [
        61,
        2,
        88,
        3
      ],
      "leadingComments": " Keep if NestedFoo: comment on message NestedFoo\n",
      "trailingComments": " We keep the following comment for Foo + ext because we don't\n discard options or option comments even if we're only retaining\n a message as a namespace for another retained element.\n"
    },
    {
      "path": [
        4,
        0,
        3,
        0,
        1
      ],
      "span": [
        61,
        10,
        19
      ]
    },
    {
      "path": [
        4,
        0,
        3,
        0,
        2,
        0
      ],
      "span": [
        69,
        4,
        28
      ],
      "leadingComments": " Keep if NestedFoo: comment on field uid\n"
    },
    {
      "path": [
        4,
        0,
        3,
        0,
        2,
        0,
        4
      ],
      "span": [
        69,
        4,
        12
      ]
    },
    {
      "path": [
        4,
        0,
        3,
        0,
        2,
        0,
        5
      ],
      "span": [
        69,
        13,
        19
      ]
    },
    {
      "path": [
        4,
        0,
        3,
        0,
        2,
        0,
        1
      ],
      "span": [
        69,
        20,
        23
      ]
    },
    {
      "path": [
        4,
        0,
        3,
        0,
        2,
        0,
        3
      ],
      "span": [
        69,
        26,
        27
      ]
    },
    {
      "path": [
        4,
        0,
        3,
        0,
        2,
        1
      ],
      "span": [
        71,
        4,
        42
      ],
      "leadingComments": " Keep if NestedFoo: comment on field meta\n"
    },
    {
      "path": [
        4,
        0,
        3,
        0,
        2,
        1,
        4
      ],
      "span": [
        71,
        4,
        12
      ]
    },
    {
      "path": [
        4,
        0,
        3,
        0,
        2,
        1,
        6
      ],
      "span": [
        71,
        13,
        32
      ]
    },
    {
      "path": [
        4,
        0,
        3,
        0,
        2,
        1,
        1
      ],
      "span": [
        71,
        33,
        37
      ]
    },
    {
      "path": [
        4,
        0,
        3,
        0,
        2,
        1,
        3
      ],
      "span": [
        71,
        40,
        41
      ]
    },
    {
      "path": [
        4,
        0,
        3,
        0,
        2,
        2
      ],
      "span": [
        73,
        4,
        29
      ],
      "leadingComments": " Keep if NestedFoo: comment on field state\n"
    },
    {
      "path": [
        4,
        0,
        3,
        0,
        2,
        2,
        4
      ],
      "span": [
        73,
        4,
        12
      ]
    },
    {
      "path": [
        4,
        0,
        3,
        0,
        2,
        2,
        6
      ],
      "span": [
        73,
        13,
        18
      ]
    },
    {
      "path": [
        4,
        0,
        3,
        0,
        2,
        2,
        1
      ],
      "span": [
        73,
        19,
        24
      ]
    },
    {
      "path": [
        4,
        0,
        3,
        0,
        2,
        2,
        3
      ],
      "span": [
        73,
        27,
        28
      ]
    },
    {
      "path": [
        4,
        0,
        3,
        0,
        4,
        0
      ],
      "span": [
        76,
        4,
        81,
        5
      ],
      "leadingComments": " Keep if NestedFoo: comment on enum State\n"
    },
    {
      "path": [
        4,
        0,
        3,
        0,
        4,
        0,
        1
      ],
      "span": [
        76,
        9,
        14
      ]
    },
    {
      "path": [
        4,
        0,
        3,
        0,
        4,
        0,
        2,
        0
      ],
      "span": [
        78,
        6,
        28
      ],
      "leadingComments": " Keep if NestedFoo: comment on enum value STATE_UNSPECIFIED\n"
    },
    {
      "path": [
        4,
        0,
        3,
        0,
        4,
        0,
        2,
        0,
        1
      ],
      "span": [
        78,
        6,
        23
      ]
    },
    {
      "path": [
        4,
        0,
        3,
        0,
        4,
        0,
        2,
        0,
        2
      ],
      "span": [
        78,
        26,
        27
      ]
    },
    {
      "path": [
        4,
        0,
        3,
        0,
        4,
        0,
        2,
        1
      ],
      "span": [
        80,
        6,
        21
      ],
      "leadingComments": " Keep if NestedFoo: comment on enum value STATE_GOOD\n"
    },
    {
      "path": [
        4,
        0,
        3,
        0,
        4,
        0,
        2,
        1,
        1
      ],
      "span": [
        80,
        6,
        16
      ]
    },
    {
      "path": [
        4,
        0,
        3,
        0,
        4,
        0,
        2,
        1,
        2
      ],
      "span": [
        80,
        19,
        20
      ]
    }
  ]
}