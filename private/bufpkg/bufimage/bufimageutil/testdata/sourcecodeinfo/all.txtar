-- google/protobuf/any.proto --
// Protocol Buffers - Google's data interchange format
// Copyright 2008 Google Inc.  All rights reserved.
// https://developers.google.com/protocol-buffers/
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
syntax = "proto3";
package google.protobuf;
option csharp_namespace = "Google.Protobuf.WellKnownTypes";
option go_package = "google.golang.org/protobuf/types/known/anypb";
option java_multiple_files = true;
option java_outer_classname = "AnyProto";
option java_package = "com.google.protobuf";
option objc_class_prefix = "GPB";
// `Any` contains an arbitrary serialized protocol buffer message along with a
// URL that describes the type of the serialized message.
//
// Protobuf library provides support to pack/unpack Any values in the form
// of utility functions or additional generated methods of the Any type.
//
// Example 1: Pack and unpack a message in C++.
//
//     Foo foo = ...;
//     Any any;
//     any.PackFrom(foo);
//     ...
//     if (any.UnpackTo(&foo)) {
//       ...
//     }
//
// Example 2: Pack and unpack a message in Java.
//
//     Foo foo = ...;
//     Any any = Any.pack(foo);
//     ...
//     if (any.is(Foo.class)) {
//       foo = any.unpack(Foo.class);
//     }
//     // or ...
//     if (any.isSameTypeAs(Foo.getDefaultInstance())) {
//       foo = any.unpack(Foo.getDefaultInstance());
//     }
//
//  Example 3: Pack and unpack a message in Python.
//
//     foo = Foo(...)
//     any = Any()
//     any.Pack(foo)
//     ...
//     if any.Is(Foo.DESCRIPTOR):
//       any.Unpack(foo)
//       ...
//
//  Example 4: Pack and unpack a message in Go
//
//      foo := &pb.Foo{...}
//      any, err := anypb.New(foo)
//      if err != nil {
//        ...
//      }
//      ...
//      foo := &pb.Foo{}
//      if err := any.UnmarshalTo(foo); err != nil {
//        ...
//      }
//
// The pack methods provided by protobuf library will by default use
// 'type.googleapis.com/full.type.name' as the type URL and the unpack
// methods only use the fully qualified type name after the last '/'
// in the type URL, for example "foo.bar.com/x/y.z" will yield type
// name "y.z".
//
// JSON
// ====
// The JSON representation of an `Any` value uses the regular
// representation of the deserialized, embedded message, with an
// additional field `@type` which contains the type URL. Example:
//
//     package google.profile;
//     message Person {
//       string first_name = 1;
//       string last_name = 2;
//     }
//
//     {
//       "@type": "type.googleapis.com/google.profile.Person",
//       "firstName": <string>,
//       "lastName": <string>
//     }
//
// If the embedded message type is well-known and has a custom JSON
// representation, that representation will be embedded adding a field
// `value` which holds the custom JSON in addition to the `@type`
// field. Example (for message [google.protobuf.Duration][]):
//
//     {
//       "@type": "type.googleapis.com/google.protobuf.Duration",
//       "value": "1.212s"
//     }
//
message Any {
  // A URL/resource name that uniquely identifies the type of the serialized
  // protocol buffer message. This string must contain at least
  // one "/" character. The last segment of the URL's path must represent
  // the fully qualified name of the type (as in
  // `path/google.protobuf.Duration`). The name should be in a canonical form
  // (e.g., leading "." is not accepted).
  //
  // In practice, teams usually precompile into the binary all types that they
  // expect it to use in the context of Any. However, for URLs which use the
  // scheme `http`, `https`, or no scheme, one can optionally set up a type
  // server that maps type URLs to message definitions as follows:
  //
  // * If no scheme is provided, `https` is assumed.
  // * An HTTP GET on the URL must yield a [google.protobuf.Type][]
  //   value in binary format, or produce an error.
  // * Applications are allowed to cache lookup results based on the
  //   URL, or have them precompiled into a binary to avoid any
  //   lookup. Therefore, binary compatibility needs to be preserved
  //   on changes to types. (Use versioned type names to manage
  //   breaking changes.)
  //
  // Note: this functionality is not currently available in the official
  // protobuf release, and it is not used for type URLs beginning with
  // type.googleapis.com. As of May 2023, there are no widely used type server
  // implementations and no plans to implement one.
  //
  // Schemes other than `http`, `https` (or the empty scheme) might be
  // used with implementation specific semantics.
  //
  string type_url = 1;
  // Must be a valid serialized protocol buffer of the above specified type.
  bytes value = 2;
}
-- google/protobuf/descriptor.proto --
// Protocol Buffers - Google's data interchange format
// Copyright 2008 Google Inc.  All rights reserved.
// https://developers.google.com/protocol-buffers/
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
// Author: kenton@google.com (Kenton Varda)
//  Based on original Protocol Buffers design by
//  Sanjay Ghemawat, Jeff Dean, and others.
//
// The messages in this file describe the definitions found in .proto files.
// A valid .proto file can be translated directly to a FileDescriptorProto
// without any other information (e.g. without reading its imports).
syntax = "proto2";
package google.protobuf;
option cc_enable_arenas = true;
option csharp_namespace = "Google.Protobuf.Reflection";
option go_package = "google.golang.org/protobuf/types/descriptorpb";
option java_outer_classname = "DescriptorProtos";
option java_package = "com.google.protobuf";
option objc_class_prefix = "GPB";
// descriptor.proto must be optimized for speed because reflection-based
// algorithms don't work during bootstrapping.
option optimize_for = SPEED;
// ===================================================================
// Features
// TODO Enums in C++ gencode (and potentially other languages) are
// not well scoped.  This means that each of the feature enums below can clash
// with each other.  The short names we've chosen maximize call-site
// readability, but leave us very open to this scenario.  A future feature will
// be designed and implemented to handle this, hopefully before we ever hit a
// conflict here.
message FeatureSet {
  optional FieldPresence field_presence = 1 [
    edition_defaults = { value: "EXPLICIT", edition: EDITION_LEGACY },
    edition_defaults = { value: "IMPLICIT", edition: EDITION_PROTO3 },
    edition_defaults = { value: "EXPLICIT", edition: EDITION_2023 },
    feature_support = { edition_introduced: EDITION_2023 },
    retention = RETENTION_RUNTIME,
    targets = TARGET_TYPE_FIELD,
    targets = TARGET_TYPE_FILE
  ];
  optional EnumType enum_type = 2 [
    edition_defaults = { value: "CLOSED", edition: EDITION_LEGACY },
    edition_defaults = { value: "OPEN", edition: EDITION_PROTO3 },
    feature_support = { edition_introduced: EDITION_2023 },
    retention = RETENTION_RUNTIME,
    targets = TARGET_TYPE_ENUM,
    targets = TARGET_TYPE_FILE
  ];
  optional RepeatedFieldEncoding repeated_field_encoding = 3 [
    edition_defaults = { value: "EXPANDED", edition: EDITION_LEGACY },
    edition_defaults = { value: "PACKED", edition: EDITION_PROTO3 },
    feature_support = { edition_introduced: EDITION_2023 },
    retention = RETENTION_RUNTIME,
    targets = TARGET_TYPE_FIELD,
    targets = TARGET_TYPE_FILE
  ];
  optional Utf8Validation utf8_validation = 4 [
    edition_defaults = { value: "NONE", edition: EDITION_LEGACY },
    edition_defaults = { value: "VERIFY", edition: EDITION_PROTO3 },
    feature_support = { edition_introduced: EDITION_2023 },
    retention = RETENTION_RUNTIME,
    targets = TARGET_TYPE_FIELD,
    targets = TARGET_TYPE_FILE
  ];
  optional MessageEncoding message_encoding = 5 [
    edition_defaults = { value: "LENGTH_PREFIXED", edition: EDITION_LEGACY },
    feature_support = { edition_introduced: EDITION_2023 },
    retention = RETENTION_RUNTIME,
    targets = TARGET_TYPE_FIELD,
    targets = TARGET_TYPE_FILE
  ];
  optional JsonFormat json_format = 6 [
    edition_defaults = { value: "LEGACY_BEST_EFFORT", edition: EDITION_LEGACY },
    edition_defaults = { value: "ALLOW", edition: EDITION_PROTO3 },
    feature_support = { edition_introduced: EDITION_2023 },
    retention = RETENTION_RUNTIME,
    targets = TARGET_TYPE_MESSAGE,
    targets = TARGET_TYPE_ENUM,
    targets = TARGET_TYPE_FILE
  ];
  optional EnforceNamingStyle enforce_naming_style = 7 [
    edition_defaults = { value: "STYLE_LEGACY", edition: EDITION_LEGACY },
    edition_defaults = { value: "STYLE2024", edition: EDITION_2024 },
    feature_support = { edition_introduced: EDITION_2024 },
    retention = RETENTION_SOURCE,
    targets = TARGET_TYPE_FILE,
    targets = TARGET_TYPE_EXTENSION_RANGE,
    targets = TARGET_TYPE_MESSAGE,
    targets = TARGET_TYPE_FIELD,
    targets = TARGET_TYPE_ONEOF,
    targets = TARGET_TYPE_ENUM,
    targets = TARGET_TYPE_ENUM_ENTRY,
    targets = TARGET_TYPE_SERVICE,
    targets = TARGET_TYPE_METHOD
  ];
  optional VisibilityFeature.DefaultSymbolVisibility default_symbol_visibility = 8 [
    edition_defaults = { value: "EXPORT_ALL", edition: EDITION_LEGACY },
    edition_defaults = { value: "EXPORT_TOP_LEVEL", edition: EDITION_2024 },
    feature_support = { edition_introduced: EDITION_2024 },
    retention = RETENTION_SOURCE,
    targets = TARGET_TYPE_FILE
  ];
  message VisibilityFeature {
    enum DefaultSymbolVisibility {
      DEFAULT_SYMBOL_VISIBILITY_UNKNOWN = 0;
      // Default pre-EDITION_2024, all UNSET visibility are export.
      EXPORT_ALL = 1;
      // All top-level symbols default to export, nested default to local.
      EXPORT_TOP_LEVEL = 2;
      // All symbols default to local.
      LOCAL_ALL = 3;
      // All symbols local by default. Nested types cannot be exported.
      // With special case caveat for message { enum {} reserved 1 to max; }
      // This is the recommended setting for new protos.
      STRICT = 4;
    }
  }
  enum EnforceNamingStyle {
    ENFORCE_NAMING_STYLE_UNKNOWN = 0;
    STYLE2024 = 1;
    STYLE_LEGACY = 2;
  }
  enum EnumType {
    ENUM_TYPE_UNKNOWN = 0;
    OPEN = 1;
    CLOSED = 2;
  }
  enum FieldPresence {
    FIELD_PRESENCE_UNKNOWN = 0;
    EXPLICIT = 1;
    IMPLICIT = 2;
    LEGACY_REQUIRED = 3;
  }
  enum JsonFormat {
    JSON_FORMAT_UNKNOWN = 0;
    ALLOW = 1;
    LEGACY_BEST_EFFORT = 2;
  }
  enum MessageEncoding {
    MESSAGE_ENCODING_UNKNOWN = 0;
    LENGTH_PREFIXED = 1;
    DELIMITED = 2;
  }
  enum RepeatedFieldEncoding {
    REPEATED_FIELD_ENCODING_UNKNOWN = 0;
    PACKED = 1;
    EXPANDED = 2;
  }
  enum Utf8Validation {
    UTF8_VALIDATION_UNKNOWN = 0;
    VERIFY = 2;
    NONE = 3;
    reserved 1;
  }
  extensions 1000 to 9994 [
    declaration = {
      number: 1000,
      full_name: ".pb.cpp",
      type: ".pb.CppFeatures"
    },
    declaration = {
      number: 1001,
      full_name: ".pb.java",
      type: ".pb.JavaFeatures"
    },
    declaration = {
      number: 1002,
      full_name: ".pb.go",
      type: ".pb.GoFeatures"
    },
    declaration = {
      number: 1003,
      full_name: ".pb.python",
      type: ".pb.PythonFeatures"
    },
    declaration = {
      number: 9990,
      full_name: ".pb.proto1",
      type: ".pb.Proto1Features"
    }
  ];
  extensions 9995 to 9999, 10000;
  reserved 999;
}
message MessageOptions {
  // Set true to use the old proto1 MessageSet wire format for extensions.
  // This is provided for backwards-compatibility with the MessageSet wire
  // format.  You should not use this for any other reason:  It's less
  // efficient, has fewer features, and is more complicated.
  //
  // The message must be defined exactly as follows:
  //   message Foo {
  //     option message_set_wire_format = true;
  //     extensions 4 to max;
  //   }
  // Note that the message cannot have any defined fields; MessageSets only
  // have extensions.
  //
  // All extensions of your type must be singular messages; e.g. they cannot
  // be int32s, enums, or repeated messages.
  //
  // Because this is an option, the above two restrictions are not enforced by
  // the protocol compiler.
  optional bool message_set_wire_format = 1 [default = false];
  // Disables the generation of the standard "descriptor()" accessor, which can
  // conflict with a field of the same name.  This is meant to make migration
  // from proto1 easier; new code should avoid fields named "descriptor".
  optional bool no_standard_descriptor_accessor = 2 [default = false];
  // Is this message deprecated?
  // Depending on the target platform, this can emit Deprecated annotations
  // for the message, or it will be completely ignored; in the very least,
  // this is a formalization for deprecating messages.
  optional bool deprecated = 3 [default = false];
  // Whether the message is an automatically generated map entry type for the
  // maps field.
  //
  // For maps fields:
  //     map<KeyType, ValueType> map_field = 1;
  // The parsed descriptor looks like:
  //     message MapFieldEntry {
  //         option map_entry = true;
  //         optional KeyType key = 1;
  //         optional ValueType value = 2;
  //     }
  //     repeated MapFieldEntry map_field = 1;
  //
  // Implementations may choose not to generate the map_entry=true message, but
  // use a native map in the target language to hold the keys and values.
  // The reflection APIs in such implementations still need to work as
  // if the field is a repeated message field.
  //
  // NOTE: Do not set the option in .proto files. Always use the maps syntax
  // instead. The option should only be implicitly set by the proto compiler
  // parser.
  optional bool map_entry = 7;
  // Enable the legacy handling of JSON field name conflicts.  This lowercases
  // and strips underscored from the fields before comparison in proto3 only.
  // The new behavior takes `json_name` into account and applies to proto2 as
  // well.
  //
  // This should only be used as a temporary measure against broken builds due
  // to the change in behavior for JSON field name conflicts.
  //
  // TODO This is legacy behavior we plan to remove once downstream
  // teams have had time to migrate.
  optional bool deprecated_legacy_json_field_conflicts = 11 [deprecated = true];
  // Any features defined in the specific edition.
  // WARNING: This field should only be used by protobuf plugins or special
  // cases like the proto compiler. Other uses are discouraged and
  // developers should rely on the protoreflect APIs for their client language.
  optional FeatureSet features = 12;
  // The parser stores options it doesn't recognize here. See above.
  repeated UninterpretedOption uninterpreted_option = 999;
  extensions 1000 to max;
  reserved 4, 5, 6, 8, 9;
}
message ServiceOptions {
  // Note:  Field numbers 1 through 32 are reserved for Google's internal RPC
  //   framework.  We apologize for hoarding these numbers to ourselves, but
  //   we were already using them long before we decided to release Protocol
  //   Buffers.
  // Is this service deprecated?
  // Depending on the target platform, this can emit Deprecated annotations
  // for the service, or it will be completely ignored; in the very least,
  // this is a formalization for deprecating services.
  optional bool deprecated = 33 [default = false];
  // Any features defined in the specific edition.
  // WARNING: This field should only be used by protobuf plugins or special
  // cases like the proto compiler. Other uses are discouraged and
  // developers should rely on the protoreflect APIs for their client language.
  optional FeatureSet features = 34;
  // The parser stores options it doesn't recognize here. See above.
  repeated UninterpretedOption uninterpreted_option = 999;
  extensions 1000 to max;
}
// A message representing a option the parser does not recognize. This only
// appears in options protos created by the compiler::Parser class.
// DescriptorPool resolves these when building Descriptor objects. Therefore,
// options protos in descriptor objects (e.g. returned by Descriptor::options(),
// or produced by Descriptor::CopyTo()) will never have UninterpretedOptions
// in them.
message UninterpretedOption {
  repeated NamePart name = 2;
  // The value of the uninterpreted option, in whatever type the tokenizer
  // identified it as during parsing. Exactly one of these should be set.
  optional string identifier_value = 3;
  optional uint64 positive_int_value = 4;
  optional int64 negative_int_value = 5;
  optional double double_value = 6;
  optional bytes string_value = 7;
  optional string aggregate_value = 8;
  // The name of the uninterpreted option.  Each string represents a segment in
  // a dot-separated name.  is_extension is true iff a segment represents an
  // extension (denoted with parentheses in options specs in .proto files).
  // E.g.,{ ["foo", false], ["bar.baz", true], ["moo", false] } represents
  // "foo.(bar.baz).moo".
  message NamePart {
    required string name_part = 1;
    required bool is_extension = 2;
  }
}
-- test.proto --
// Keep 1: comment on syntax
syntax = "proto2";
// Keep 2: comment on package
package foo.bar;
// Keep if NestedFoo: comment on import any.proto
import "google/protobuf/any.proto";
// Keep if ext: comment on import descriptor.proto
import "google/protobuf/descriptor.proto";
// Keep 3: comment on option
option go_package = "foo.bar/baz";
// "Keep if Bar" are also kept for Svc and Svc.Do since those
// elements depend on Bar.
// Keep if Bar: comment on message Bar
message Bar {
  // Keep if Bar: comment on field foo
  optional Foo foo = 1;
  // Keep if Bar: comment on oneof status
  oneof status {
    // Keep if Bar: comment on field baz
    Baz baz = 2;
    // Keep if Bar: comment on field quz
    Quz quz = 3;
  }
}
// Keep if all: comment on message Bedazzle
message Bedazzle {
  // Keep if all: comment on field t
  optional string t = 1;
}
// Keep if all: comment on message Buzz
message Buzz {
  // Keep if all: comment on field s
  optional string s = 1;
}
// "Keep if Foo" are also kept for Bar, Svc, and Svc.Do since those
// elements depend on Foo.
// Keep if Foo: comment on message Foo
message Foo {
  // We keep the following comment for NestedFoo because we don't
  // discard options or option comments even if we're only retaining
  // a message as a namespace for another retained element.
  // Keep if Foo | NestedFoo: comment on option
  option (bizniz) = "abc";
  // Keep if Foo: comment on field name
  optional string name = 1;
  // Keep if Foo: comment on field bits
  repeated int64 bits = 2;
  // Keep if NestedFoo: comment on message NestedFoo
  message NestedFoo {
    // We keep the following comment for Foo + ext because we don't
    // discard options or option comments even if we're only retaining
    // a message as a namespace for another retained element.
    // Keep if Foo + ext | NestedFoo: comment on option
    option (bizniz) = "abc";
    // Keep if NestedFoo: comment on field uid
    optional uint64 uid = 1;
    // Keep if NestedFoo: comment on field meta
    repeated google.protobuf.Any meta = 2;
    // Keep if NestedFoo: comment on field state
    optional State state = 3;
    // Keep if NestedFoo: comment on enum State
    enum State {
      // Keep if NestedFoo: comment on enum value STATE_UNSPECIFIED
      STATE_UNSPECIFIED = 0;
      // Keep if NestedFoo: comment on enum value STATE_GOOD
      STATE_GOOD = 1;
    }
    // Keep if Foo + ext: comment on extend block
    extend Foo {
      // Keep if Foo + ext: comment on extension blah
      repeated bytes blah = 101;
    }
  }
  extensions 100 to max;
  reserved 10 to 20;
  reserved "abc", "def", "ghi";
}
// Keep if all: comment on message Frobnitz
message Frobnitz {
  // Keep if all: comment on field xyz
  optional bytes xyz = 1;
}
// "Keep if Baz" and "Keep if Quz" are also kept for Bar, Svc, and Svc.Do
// since those elements depend on Baz and Quz.
// Keep if Baz: comment on enum Baz
enum Baz {
  // Keep if Baz: comment on enum value BAZ_UNSPECIFIED
  BAZ_UNSPECIFIED = 0;
}
// Keep if Quz: comment on enum Quz
enum Quz {
  // Keep if Quz: comment on enum value QUZ_UNSPECIFIED
  QUZ_UNSPECIFIED = 0;
}
// Keep if all: comment on service BuzzService
service BuzzService {
  // Keep if all: comment on method BuzzyBuzz
  rpc BuzzyBuzz ( Buzz ) returns ( Bedazzle );
}
// Keep if Svc: comment on service Svc
service Svc {
  // Keep if Svc: comment on option
  option (fizzbuzz) = "wxyz";
  // Keep if Svc.Do: comment on rpc Do
  rpc Do ( Foo ) returns ( Bar ) {
    // Keep if Svc.Do: comment on option
    option idempotency_level = NO_SIDE_EFFECTS;
  }
  // Keep if Svc: comment on rpc Dont
  rpc Dont ( Foo ) returns ( Bar );
}
// Keep if ext: comment on extend block
extend google.protobuf.MessageOptions {
  // Keep if ext: comment on custom option bizniz
  optional string bizniz = 10101;
}
// Keep if ext: comment on extend block
extend google.protobuf.ServiceOptions {
  // Keep if ext + Svc: comment on custom option fizzbuzz
  optional string fizzbuzz = 10101;
}
-- source_code_info.json --
{
  "location": [
    {
      "span": [
        1,
        0,
        153,
        1
      ]
    },
    {
      "path": [
        12
      ],
      "span": [
        1,
        0,
        18
      ],
      "leadingComments": " Keep 1: comment on syntax\n"
    },
    {
      "path": [
        2
      ],
      "span": [
        4,
        0,
        16
      ],
      "leadingComments": " Keep 2: comment on package\n"
    },
    {
      "path": [
        8
      ],
      "span": [
        7,
        0,
        34
      ]
    },
    {
      "path": [
        8,
        11
      ],
      "span": [
        7,
        0,
        34
      ],
      "leadingComments": " Keep 3: comment on option\n"
    },
    {
      "path": [
        3,
        0
      ],
      "span": [
        10,
        0,
        42
      ],
      "leadingComments": " Keep if ext: comment on import descriptor.proto\n"
    },
    {
      "path": [
        3,
        1
      ],
      "span": [
        16,
        0,
        40
      ],
      "leadingComments": " Keep if NestedFoo: comment on import any.proto\n"
    },
    {
      "path": [
        11,
        0
      ],
      "span": [
        16,
        7,
        11
      ]
    },
    {
      "path": [
        7
      ],
      "span": [
        19,
        0,
        22,
        1
      ],
      "leadingComments": " Keep if ext: comment on extend block\n"
    },
    {
      "path": [
        7,
        0
      ],
      "span": [
        21,
        2,
        33
      ],
      "leadingComments": " Keep if ext: comment on custom option bizniz\n"
    },
    {
      "path": [
        7,
        0,
        2
      ],
      "span": [
        19,
        7,
        37
      ]
    },
    {
      "path": [
        7,
        0,
        4
      ],
      "span": [
        21,
        2,
        10
      ]
    },
    {
      "path": [
        7,
        0,
        5
      ],
      "span": [
        21,
        11,
        17
      ]
    },
    {
      "path": [
        7,
        0,
        1
      ],
      "span": [
        21,
        18,
        24
      ]
    },
    {
      "path": [
        7,
        0,
        3
      ],
      "span": [
        21,
        27,
        32
      ]
    },
    {
      "path": [
        7
      ],
      "span": [
        25,
        0,
        28,
        1
      ],
      "leadingComments": " Keep if ext: comment on extend block\n"
    },
    {
      "path": [
        7,
        1
      ],
      "span": [
        27,
        2,
        35
      ],
      "leadingComments": " Keep if ext + Svc: comment on custom option fizzbuzz\n"
    },
    {
      "path": [
        7,
        1,
        2
      ],
      "span": [
        25,
        7,
        37
      ]
    },
    {
      "path": [
        7,
        1,
        4
      ],
      "span": [
        27,
        2,
        10
      ]
    },
    {
      "path": [
        7,
        1,
        5
      ],
      "span": [
        27,
        11,
        17
      ]
    },
    {
      "path": [
        7,
        1,
        1
      ],
      "span": [
        27,
        18,
        26
      ]
    },
    {
      "path": [
        7,
        1,
        3
      ],
      "span": [
        27,
        29,
        34
      ]
    },
    {
      "path": [
        4,
        0
      ],
      "span": [
        31,
        0,
        34,
        1
      ],
      "leadingComments": " Keep if all: comment on message Frobnitz\n"
    },
    {
      "path": [
        4,
        0,
        1
      ],
      "span": [
        31,
        8,
        16
      ]
    },
    {
      "path": [
        4,
        0,
        2,
        0
      ],
      "span": [
        33,
        2,
        25
      ],
      "leadingComments": " Keep if all: comment on field xyz\n"
    },
    {
      "path": [
        4,
        0,
        2,
        0,
        4
      ],
      "span": [
        33,
        2,
        10
      ]
    },
    {
      "path": [
        4,
        0,
        2,
        0,
        5
      ],
      "span": [
        33,
        11,
        16
      ]
    },
    {
      "path": [
        4,
        0,
        2,
        0,
        1
      ],
      "span": [
        33,
        17,
        20
      ]
    },
    {
      "path": [
        4,
        0,
        2,
        0,
        3
      ],
      "span": [
        33,
        23,
        24
      ]
    },
    {
      "path": [
        4,
        1
      ],
      "span": [
        40,
        0,
        89,
        1
      ],
      "leadingComments": " Keep if Foo: comment on message Foo\n",
      "trailingComments": " We keep the following comment for NestedFoo because we don't\n discard options or option comments even if we're only retaining\n a message as a namespace for another retained element.\n",
      "leadingDetachedComments": [
        " \"Keep if Foo\" are also kept for Bar, Svc, and Svc.Do since those\n elements depend on Foo.\n"
      ]
    },
    {
      "path": [
        4,
        1,
        1
      ],
      "span": [
        40,
        8,
        11
      ]
    },
    {
      "path": [
        4,
        1,
        7
      ],
      "span": [
        46,
        2,
        26
      ]
    },
    {
      "path": [
        4,
        1,
        7,
        10101
      ],
      "span": [
        46,
        2,
        26
      ],
      "leadingComments": " Keep if Foo | NestedFoo: comment on option\n"
    },
    {
      "path": [
        4,
        1,
        2,
        0
      ],
      "span": [
        49,
        2,
        27
      ],
      "leadingComments": " Keep if Foo: comment on field name\n"
    },
    {
      "path": [
        4,
        1,
        2,
        0,
        4
      ],
      "span": [
        49,
        2,
        10
      ]
    },
    {
      "path": [
        4,
        1,
        2,
        0,
        5
      ],
      "span": [
        49,
        11,
        17
      ]
    },
    {
      "path": [
        4,
        1,
        2,
        0,
        1
      ],
      "span": [
        49,
        18,
        22
      ]
    },
    {
      "path": [
        4,
        1,
        2,
        0,
        3
      ],
      "span": [
        49,
        25,
        26
      ]
    },
    {
      "path": [
        4,
        1,
        2,
        1
      ],
      "span": [
        51,
        2,
        26
      ],
      "leadingComments": " Keep if Foo: comment on field bits\n"
    },
    {
      "path": [
        4,
        1,
        2,
        1,
        4
      ],
      "span": [
        51,
        2,
        10
      ]
    },
    {
      "path": [
        4,
        1,
        2,
        1,
        5
      ],
      "span": [
        51,
        11,
        16
      ]
    },
    {
      "path": [
        4,
        1,
        2,
        1,
        1
      ],
      "span": [
        51,
        17,
        21
      ]
    },
    {
      "path": [
        4,
        1,
        2,
        1,
        3
      ],
      "span": [
        51,
        24,
        25
      ]
    },
    {
      "path": [
        4,
        1,
        9
      ],
      "span": [
        54,
        2,
        20
      ],
      "leadingComments": " Keep if Foo: comment on reserved range\n"
    },
    {
      "path": [
        4,
        1,
        9,
        0
      ],
      "span": [
        54,
        11,
        19
      ]
    },
    {
      "path": [
        4,
        1,
        9,
        0,
        1
      ],
      "span": [
        54,
        11,
        13
      ]
    },
    {
      "path": [
        4,
        1,
        9,
        0,
        2
      ],
      "span": [
        54,
        17,
        19
      ]
    },
    {
      "path": [
        4,
        1,
        10
      ],
      "span": [
        56,
        2,
        31
      ],
      "leadingComments": " Keep if Foo: comment on reserved names\n"
    },
    {
      "path": [
        4,
        1,
        10,
        0
      ],
      "span": [
        56,
        11,
        16
      ]
    },
    {
      "path": [
        4,
        1,
        10,
        1
      ],
      "span": [
        56,
        18,
        23
      ]
    },
    {
      "path": [
        4,
        1,
        10,
        2
      ],
      "span": [
        56,
        25,
        30
      ]
    },
    {
      "path": [
        4,
        1,
        5
      ],
      "span": [
        58,
        2,
        24
      ],
      "leadingComments": " Keep if Foo: comment on extension range\n"
    },
    {
      "path": [
        4,
        1,
        5,
        0
      ],
      "span": [
        58,
        13,
        23
      ]
    },
    {
      "path": [
        4,
        1,
        5,
        0,
        1
      ],
      "span": [
        58,
        13,
        16
      ]
    },
    {
      "path": [
        4,
        1,
        5,
        0,
        2
      ],
      "span": [
        58,
        20,
        23
      ]
    },
    {
      "path": [
        4,
        1,
        3,
        0
      ],
      "span": [
        61,
        2,
        88,
        3
      ],
      "leadingComments": " Keep if NestedFoo: comment on message NestedFoo\n",
      "trailingComments": " We keep the following comment for Foo + ext because we don't\n discard options or option comments even if we're only retaining\n a message as a namespace for another retained element.\n"
    },
    {
      "path": [
        4,
        1,
        3,
        0,
        1
      ],
      "span": [
        61,
        10,
        19
      ]
    },
    {
      "path": [
        4,
        1,
        3,
        0,
        7
      ],
      "span": [
        67,
        4,
        28
      ]
    },
    {
      "path": [
        4,
        1,
        3,
        0,
        7,
        10101
      ],
      "span": [
        67,
        4,
        28
      ],
      "leadingComments": " Keep if Foo + ext | NestedFoo: comment on option\n"
    },
    {
      "path": [
        4,
        1,
        3,
        0,
        2,
        0
      ],
      "span": [
        69,
        4,
        28
      ],
      "leadingComments": " Keep if NestedFoo: comment on field uid\n"
    },
    {
      "path": [
        4,
        1,
        3,
        0,
        2,
        0,
        4
      ],
      "span": [
        69,
        4,
        12
      ]
    },
    {
      "path": [
        4,
        1,
        3,
        0,
        2,
        0,
        5
      ],
      "span": [
        69,
        13,
        19
      ]
    },
    {
      "path": [
        4,
        1,
        3,
        0,
        2,
        0,
        1
      ],
      "span": [
        69,
        20,
        23
      ]
    },
    {
      "path": [
        4,
        1,
        3,
        0,
        2,
        0,
        3
      ],
      "span": [
        69,
        26,
        27
      ]
    },
    {
      "path": [
        4,
        1,
        3,
        0,
        2,
        1
      ],
      "span": [
        71,
        4,
        42
      ],
      "leadingComments": " Keep if NestedFoo: comment on field meta\n"
    },
    {
      "path": [
        4,
        1,
        3,
        0,
        2,
        1,
        4
      ],
      "span": [
        71,
        4,
        12
      ]
    },
    {
      "path": [
        4,
        1,
        3,
        0,
        2,
        1,
        6
      ],
      "span": [
        71,
        13,
        32
      ]
    },
    {
      "path": [
        4,
        1,
        3,
        0,
        2,
        1,
        1
      ],
      "span": [
        71,
        33,
        37
      ]
    },
    {
      "path": [
        4,
        1,
        3,
        0,
        2,
        1,
        3
      ],
      "span": [
        71,
        40,
        41
      ]
    },
    {
      "path": [
        4,
        1,
        3,
        0,
        2,
        2
      ],
      "span": [
        73,
        4,
        29
      ],
      "leadingComments": " Keep if NestedFoo: comment on field state\n"
    },
    {
      "path": [
        4,
        1,
        3,
        0,
        2,
        2,
        4
      ],
      "span": [
        73,
        4,
        12
      ]
    },
    {
      "path": [
        4,
        1,
        3,
        0,
        2,
        2,
        6
      ],
      "span": [
        73,
        13,
        18
      ]
    },
    {
      "path": [
        4,
        1,
        3,
        0,
        2,
        2,
        1
      ],
      "span": [
        73,
        19,
        24
      ]
    },
    {
      "path": [
        4,
        1,
        3,
        0,
        2,
        2,
        3
      ],
      "span": [
        73,
        27,
        28
      ]
    },
    {
      "path": [
        4,
        1,
        3,
        0,
        4,
        0
      ],
      "span": [
        76,
        4,
        81,
        5
      ],
      "leadingComments": " Keep if NestedFoo: comment on enum State\n"
    },
    {
      "path": [
        4,
        1,
        3,
        0,
        4,
        0,
        1
      ],
      "span": [
        76,
        9,
        14
      ]
    },
    {
      "path": [
        4,
        1,
        3,
        0,
        4,
        0,
        2,
        0
      ],
      "span": [
        78,
        6,
        28
      ],
      "leadingComments": " Keep if NestedFoo: comment on enum value STATE_UNSPECIFIED\n"
    },
    {
      "path": [
        4,
        1,
        3,
        0,
        4,
        0,
        2,
        0,
        1
      ],
      "span": [
        78,
        6,
        23
      ]
    },
    {
      "path": [
        4,
        1,
        3,
        0,
        4,
        0,
        2,
        0,
        2
      ],
      "span": [
        78,
        26,
        27
      ]
    },
    {
      "path": [
        4,
        1,
        3,
        0,
        4,
        0,
        2,
        1
      ],
      "span": [
        80,
        6,
        21
      ],
      "leadingComments": " Keep if NestedFoo: comment on enum value STATE_GOOD\n"
    },
    {
      "path": [
        4,
        1,
        3,
        0,
        4,
        0,
        2,
        1,
        1
      ],
      "span": [
        80,
        6,
        16
      ]
    },
    {
      "path": [
        4,
        1,
        3,
        0,
        4,
        0,
        2,
        1,
        2
      ],
      "span": [
        80,
        19,
        20
      ]
    },
    {
      "path": [
        4,
        1,
        3,
        0,
        6
      ],
      "span": [
        84,
        4,
        87,
        5
      ],
      "leadingComments": " Keep if Foo + ext: comment on extend block\n"
    },
    {
      "path": [
        4,
        1,
        3,
        0,
        6,
        0
      ],
      "span": [
        86,
        6,
        32
      ],
      "leadingComments": " Keep if Foo + ext: comment on extension blah\n"
    },
    {
      "path": [
        4,
        1,
        3,
        0,
        6,
        0,
        2
      ],
      "span": [
        84,
        11,
        14
      ]
    },
    {
      "path": [
        4,
        1,
        3,
        0,
        6,
        0,
        4
      ],
      "span": [
        86,
        6,
        14
      ]
    },
    {
      "path": [
        4,
        1,
        3,
        0,
        6,
        0,
        5
      ],
      "span": [
        86,
        15,
        20
      ]
    },
    {
      "path": [
        4,
        1,
        3,
        0,
        6,
        0,
        1
      ],
      "span": [
        86,
        21,
        25
      ]
    },
    {
      "path": [
        4,
        1,
        3,
        0,
        6,
        0,
        3
      ],
      "span": [
        86,
        28,
        31
      ]
    },
    {
      "path": [
        4,
        2
      ],
      "span": [
        95,
        0,
        105,
        1
      ],
      "leadingComments": " Keep if Bar: comment on message Bar\n",
      "leadingDetachedComments": [
        " \"Keep if Bar\" are also kept for Svc and Svc.Do since those\n elements depend on Bar.\n"
      ]
    },
    {
      "path": [
        4,
        2,
        1
      ],
      "span": [
        95,
        8,
        11
      ]
    },
    {
      "path": [
        4,
        2,
        2,
        0
      ],
      "span": [
        97,
        2,
        23
      ],
      "leadingComments": " Keep if Bar: comment on field foo\n"
    },
    {
      "path": [
        4,
        2,
        2,
        0,
        4
      ],
      "span": [
        97,
        2,
        10
      ]
    },
    {
      "path": [
        4,
        2,
        2,
        0,
        6
      ],
      "span": [
        97,
        11,
        14
      ]
    },
    {
      "path": [
        4,
        2,
        2,
        0,
        1
      ],
      "span": [
        97,
        15,
        18
      ]
    },
    {
      "path": [
        4,
        2,
        2,
        0,
        3
      ],
      "span": [
        97,
        21,
        22
      ]
    },
    {
      "path": [
        4,
        2,
        8,
        0
      ],
      "span": [
        99,
        2,
        104,
        3
      ],
      "leadingComments": " Keep if Bar: comment on oneof status\n"
    },
    {
      "path": [
        4,
        2,
        8,
        0,
        1
      ],
      "span": [
        99,
        8,
        14
      ]
    },
    {
      "path": [
        4,
        2,
        2,
        1
      ],
      "span": [
        101,
        4,
        16
      ],
      "leadingComments": " Keep if Bar: comment on field baz\n"
    },
    {
      "path": [
        4,
        2,
        2,
        1,
        6
      ],
      "span": [
        101,
        4,
        7
      ]
    },
    {
      "path": [
        4,
        2,
        2,
        1,
        1
      ],
      "span": [
        101,
        8,
        11
      ]
    },
    {
      "path": [
        4,
        2,
        2,
        1,
        3
      ],
      "span": [
        101,
        14,
        15
      ]
    },
    {
      "path": [
        4,
        2,
        2,
        2
      ],
      "span": [
        103,
        4,
        16
      ],
      "leadingComments": " Keep if Bar: comment on field quz\n"
    },
    {
      "path": [
        4,
        2,
        2,
        2,
        6
      ],
      "span": [
        103,
        4,
        7
      ]
    },
    {
      "path": [
        4,
        2,
        2,
        2,
        1
      ],
      "span": [
        103,
        8,
        11
      ]
    },
    {
      "path": [
        4,
        2,
        2,
        2,
        3
      ],
      "span": [
        103,
        14,
        15
      ]
    },
    {
      "path": [
        5,
        0
      ],
      "span": [
        111,
        0,
        114,
        1
      ],
      "leadingComments": " Keep if Baz: comment on enum Baz\n",
      "leadingDetachedComments": [
        " \"Keep if Baz\" and \"Keep if Quz\" are also kept for Bar, Svc, and Svc.Do\n since those elements depend on Baz and Quz.\n"
      ]
    },
    {
      "path": [
        5,
        0,
        1
      ],
      "span": [
        111,
        5,
        8
      ]
    },
    {
      "path": [
        5,
        0,
        2,
        0
      ],
      "span": [
        113,
        2,
        22
      ],
      "leadingComments": " Keep if Baz: comment on enum value BAZ_UNSPECIFIED\n"
    },
    {
      "path": [
        5,
        0,
        2,
        0,
        1
      ],
      "span": [
        113,
        2,
        17
      ]
    },
    {
      "path": [
        5,
        0,
        2,
        0,
        2
      ],
      "span": [
        113,
        20,
        21
      ]
    },
    {
      "path": [
        5,
        1
      ],
      "span": [
        117,
        0,
        120,
        1
      ],
      "leadingComments": " Keep if Quz: comment on enum Quz\n"
    },
    {
      "path": [
        5,
        1,
        1
      ],
      "span": [
        117,
        5,
        8
      ]
    },
    {
      "path": [
        5,
        1,
        2,
        0
      ],
      "span": [
        119,
        2,
        22
      ],
      "leadingComments": " Keep if Quz: comment on enum value QUZ_UNSPECIFIED\n"
    },
    {
      "path": [
        5,
        1,
        2,
        0,
        1
      ],
      "span": [
        119,
        2,
        17
      ]
    },
    {
      "path": [
        5,
        1,
        2,
        0,
        2
      ],
      "span": [
        119,
        20,
        21
      ]
    },
    {
      "path": [
        4,
        3
      ],
      "span": [
        123,
        0,
        126,
        1
      ],
      "leadingComments": " Keep if all: comment on message Buzz\n"
    },
    {
      "path": [
        4,
        3,
        1
      ],
      "span": [
        123,
        8,
        12
      ]
    },
    {
      "path": [
        4,
        3,
        2,
        0
      ],
      "span": [
        125,
        2,
        24
      ],
      "leadingComments": " Keep if all: comment on field s\n"
    },
    {
      "path": [
        4,
        3,
        2,
        0,
        4
      ],
      "span": [
        125,
        2,
        10
      ]
    },
    {
      "path": [
        4,
        3,
        2,
        0,
        5
      ],
      "span": [
        125,
        11,
        17
      ]
    },
    {
      "path": [
        4,
        3,
        2,
        0,
        1
      ],
      "span": [
        125,
        18,
        19
      ]
    },
    {
      "path": [
        4,
        3,
        2,
        0,
        3
      ],
      "span": [
        125,
        22,
        23
      ]
    },
    {
      "path": [
        4,
        4
      ],
      "span": [
        129,
        0,
        132,
        1
      ],
      "leadingComments": " Keep if all: comment on message Bedazzle\n"
    },
    {
      "path": [
        4,
        4,
        1
      ],
      "span": [
        129,
        8,
        16
      ]
    },
    {
      "path": [
        4,
        4,
        2,
        0
      ],
      "span": [
        131,
        2,
        24
      ],
      "leadingComments": " Keep if all: comment on field t\n"
    },
    {
      "path": [
        4,
        4,
        2,
        0,
        4
      ],
      "span": [
        131,
        2,
        10
      ]
    },
    {
      "path": [
        4,
        4,
        2,
        0,
        5
      ],
      "span": [
        131,
        11,
        17
      ]
    },
    {
      "path": [
        4,
        4,
        2,
        0,
        1
      ],
      "span": [
        131,
        18,
        19
      ]
    },
    {
      "path": [
        4,
        4,
        2,
        0,
        3
      ],
      "span": [
        131,
        22,
        23
      ]
    },
    {
      "path": [
        6,
        0
      ],
      "span": [
        135,
        0,
        138,
        1
      ],
      "leadingComments": " Keep if all: comment on service BuzzService\n"
    },
    {
      "path": [
        6,
        0,
        1
      ],
      "span": [
        135,
        8,
        19
      ]
    },
    {
      "path": [
        6,
        0,
        2,
        0
      ],
      "span": [
        137,
        2,
        41
      ],
      "leadingComments": " Keep if all: comment on method BuzzyBuzz\n"
    },
    {
      "path": [
        6,
        0,
        2,
        0,
        1
      ],
      "span": [
        137,
        6,
        15
      ]
    },
    {
      "path": [
        6,
        0,
        2,
        0,
        2
      ],
      "span": [
        137,
        16,
        20
      ]
    },
    {
      "path": [
        6,
        0,
        2,
        0,
        3
      ],
      "span": [
        137,
        31,
        39
      ]
    },
    {
      "path": [
        6,
        1
      ],
      "span": [
        141,
        0,
        153,
        1
      ],
      "leadingComments": " Keep if Svc: comment on service Svc\n"
    },
    {
      "path": [
        6,
        1,
        1
      ],
      "span": [
        141,
        8,
        11
      ]
    },
    {
      "path": [
        6,
        1,
        3
      ],
      "span": [
        143,
        2,
        29
      ]
    },
    {
      "path": [
        6,
        1,
        3,
        10101
      ],
      "span": [
        143,
        2,
        29
      ],
      "leadingComments": " Keep if Svc: comment on option\n"
    },
    {
      "path": [
        6,
        1,
        2,
        0
      ],
      "span": [
        146,
        2,
        149,
        3
      ],
      "leadingComments": " Keep if Svc.Do: comment on rpc Do\n"
    },
    {
      "path": [
        6,
        1,
        2,
        0,
        1
      ],
      "span": [
        146,
        6,
        8
      ]
    },
    {
      "path": [
        6,
        1,
        2,
        0,
        2
      ],
      "span": [
        146,
        9,
        12
      ]
    },
    {
      "path": [
        6,
        1,
        2,
        0,
        3
      ],
      "span": [
        146,
        23,
        26
      ]
    },
    {
      "path": [
        6,
        1,
        2,
        0,
        4
      ],
      "span": [
        148,
        4,
        47
      ]
    },
    {
      "path": [
        6,
        1,
        2,
        0,
        4,
        34
      ],
      "span": [
        148,
        4,
        47
      ],
      "leadingComments": " Keep if Svc.Do: comment on option\n"
    },
    {
      "path": [
        6,
        1,
        2,
        1
      ],
      "span": [
        152,
        2,
        30
      ],
      "leadingComments": " Keep if Svc: comment on rpc Dont\n"
    },
    {
      "path": [
        6,
        1,
        2,
        1,
        1
      ],
      "span": [
        152,
        6,
        10
      ]
    },
    {
      "path": [
        6,
        1,
        2,
        1,
        2
      ],
      "span": [
        152,
        11,
        14
      ]
    },
    {
      "path": [
        6,
        1,
        2,
        1,
        3
      ],
      "span": [
        152,
        25,
        28
      ]
    }
  ]
}