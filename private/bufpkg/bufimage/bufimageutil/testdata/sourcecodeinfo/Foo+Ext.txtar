-- google/protobuf/descriptor.proto --
// Protocol Buffers - Google's data interchange format
// Copyright 2008 Google Inc.  All rights reserved.
// https://developers.google.com/protocol-buffers/
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
// Author: kenton@google.com (Kenton Varda)
//  Based on original Protocol Buffers design by
//  Sanjay Ghemawat, Jeff Dean, and others.
//
// The messages in this file describe the definitions found in .proto files.
// A valid .proto file can be translated directly to a FileDescriptorProto
// without any other information (e.g. without reading its imports).
syntax = "proto2";
package google.protobuf;
option cc_enable_arenas = true;
option csharp_namespace = "Google.Protobuf.Reflection";
option go_package = "google.golang.org/protobuf/types/descriptorpb";
option java_outer_classname = "DescriptorProtos";
option java_package = "com.google.protobuf";
option objc_class_prefix = "GPB";
// descriptor.proto must be optimized for speed because reflection-based
// algorithms don't work during bootstrapping.
option optimize_for = SPEED;
// ===================================================================
// Features
// TODO Enums in C++ gencode (and potentially other languages) are
// not well scoped.  This means that each of the feature enums below can clash
// with each other.  The short names we've chosen maximize call-site
// readability, but leave us very open to this scenario.  A future feature will
// be designed and implemented to handle this, hopefully before we ever hit a
// conflict here.
message FeatureSet {
  optional FieldPresence field_presence = 1 [
    edition_defaults = { value: "EXPLICIT", edition: EDITION_LEGACY },
    edition_defaults = { value: "IMPLICIT", edition: EDITION_PROTO3 },
    edition_defaults = { value: "EXPLICIT", edition: EDITION_2023 },
    feature_support = { edition_introduced: EDITION_2023 },
    retention = RETENTION_RUNTIME,
    targets = TARGET_TYPE_FIELD,
    targets = TARGET_TYPE_FILE
  ];
  optional EnumType enum_type = 2 [
    edition_defaults = { value: "CLOSED", edition: EDITION_LEGACY },
    edition_defaults = { value: "OPEN", edition: EDITION_PROTO3 },
    feature_support = { edition_introduced: EDITION_2023 },
    retention = RETENTION_RUNTIME,
    targets = TARGET_TYPE_ENUM,
    targets = TARGET_TYPE_FILE
  ];
  optional RepeatedFieldEncoding repeated_field_encoding = 3 [
    edition_defaults = { value: "EXPANDED", edition: EDITION_LEGACY },
    edition_defaults = { value: "PACKED", edition: EDITION_PROTO3 },
    feature_support = { edition_introduced: EDITION_2023 },
    retention = RETENTION_RUNTIME,
    targets = TARGET_TYPE_FIELD,
    targets = TARGET_TYPE_FILE
  ];
  optional Utf8Validation utf8_validation = 4 [
    edition_defaults = { value: "NONE", edition: EDITION_LEGACY },
    edition_defaults = { value: "VERIFY", edition: EDITION_PROTO3 },
    feature_support = { edition_introduced: EDITION_2023 },
    retention = RETENTION_RUNTIME,
    targets = TARGET_TYPE_FIELD,
    targets = TARGET_TYPE_FILE
  ];
  optional MessageEncoding message_encoding = 5 [
    edition_defaults = { value: "LENGTH_PREFIXED", edition: EDITION_LEGACY },
    feature_support = { edition_introduced: EDITION_2023 },
    retention = RETENTION_RUNTIME,
    targets = TARGET_TYPE_FIELD,
    targets = TARGET_TYPE_FILE
  ];
  optional JsonFormat json_format = 6 [
    edition_defaults = { value: "LEGACY_BEST_EFFORT", edition: EDITION_LEGACY },
    edition_defaults = { value: "ALLOW", edition: EDITION_PROTO3 },
    feature_support = { edition_introduced: EDITION_2023 },
    retention = RETENTION_RUNTIME,
    targets = TARGET_TYPE_MESSAGE,
    targets = TARGET_TYPE_ENUM,
    targets = TARGET_TYPE_FILE
  ];
  optional EnforceNamingStyle enforce_naming_style = 7 [
    edition_defaults = { value: "STYLE_LEGACY", edition: EDITION_LEGACY },
    edition_defaults = { value: "STYLE2024", edition: EDITION_2024 },
    feature_support = { edition_introduced: EDITION_2024 },
    retention = RETENTION_SOURCE,
    targets = TARGET_TYPE_FILE,
    targets = TARGET_TYPE_EXTENSION_RANGE,
    targets = TARGET_TYPE_MESSAGE,
    targets = TARGET_TYPE_FIELD,
    targets = TARGET_TYPE_ONEOF,
    targets = TARGET_TYPE_ENUM,
    targets = TARGET_TYPE_ENUM_ENTRY,
    targets = TARGET_TYPE_SERVICE,
    targets = TARGET_TYPE_METHOD
  ];
  optional VisibilityFeature.DefaultSymbolVisibility default_symbol_visibility = 8 [
    edition_defaults = { value: "EXPORT_ALL", edition: EDITION_LEGACY },
    edition_defaults = { value: "EXPORT_TOP_LEVEL", edition: EDITION_2024 },
    feature_support = { edition_introduced: EDITION_2024 },
    retention = RETENTION_SOURCE,
    targets = TARGET_TYPE_FILE
  ];
  message VisibilityFeature {
    enum DefaultSymbolVisibility {
      DEFAULT_SYMBOL_VISIBILITY_UNKNOWN = 0;
      // Default pre-EDITION_2024, all UNSET visibility are export.
      EXPORT_ALL = 1;
      // All top-level symbols default to export, nested default to local.
      EXPORT_TOP_LEVEL = 2;
      // All symbols default to local.
      LOCAL_ALL = 3;
      // All symbols local by default. Nested types cannot be exported.
      // With special case caveat for message { enum {} reserved 1 to max; }
      // This is the recommended setting for new protos.
      STRICT = 4;
    }
  }
  enum EnforceNamingStyle {
    ENFORCE_NAMING_STYLE_UNKNOWN = 0;
    STYLE2024 = 1;
    STYLE_LEGACY = 2;
  }
  enum EnumType {
    ENUM_TYPE_UNKNOWN = 0;
    OPEN = 1;
    CLOSED = 2;
  }
  enum FieldPresence {
    FIELD_PRESENCE_UNKNOWN = 0;
    EXPLICIT = 1;
    IMPLICIT = 2;
    LEGACY_REQUIRED = 3;
  }
  enum JsonFormat {
    JSON_FORMAT_UNKNOWN = 0;
    ALLOW = 1;
    LEGACY_BEST_EFFORT = 2;
  }
  enum MessageEncoding {
    MESSAGE_ENCODING_UNKNOWN = 0;
    LENGTH_PREFIXED = 1;
    DELIMITED = 2;
  }
  enum RepeatedFieldEncoding {
    REPEATED_FIELD_ENCODING_UNKNOWN = 0;
    PACKED = 1;
    EXPANDED = 2;
  }
  enum Utf8Validation {
    UTF8_VALIDATION_UNKNOWN = 0;
    VERIFY = 2;
    NONE = 3;
    reserved 1;
  }
  extensions 1000 to 9994 [
    declaration = {
      number: 1000,
      full_name: ".pb.cpp",
      type: ".pb.CppFeatures"
    },
    declaration = {
      number: 1001,
      full_name: ".pb.java",
      type: ".pb.JavaFeatures"
    },
    declaration = {
      number: 1002,
      full_name: ".pb.go",
      type: ".pb.GoFeatures"
    },
    declaration = {
      number: 1003,
      full_name: ".pb.python",
      type: ".pb.PythonFeatures"
    },
    declaration = {
      number: 9990,
      full_name: ".pb.proto1",
      type: ".pb.Proto1Features"
    }
  ];
  extensions 9995 to 9999, 10000;
  reserved 999;
}
message MessageOptions {
  // Set true to use the old proto1 MessageSet wire format for extensions.
  // This is provided for backwards-compatibility with the MessageSet wire
  // format.  You should not use this for any other reason:  It's less
  // efficient, has fewer features, and is more complicated.
  //
  // The message must be defined exactly as follows:
  //   message Foo {
  //     option message_set_wire_format = true;
  //     extensions 4 to max;
  //   }
  // Note that the message cannot have any defined fields; MessageSets only
  // have extensions.
  //
  // All extensions of your type must be singular messages; e.g. they cannot
  // be int32s, enums, or repeated messages.
  //
  // Because this is an option, the above two restrictions are not enforced by
  // the protocol compiler.
  optional bool message_set_wire_format = 1 [default = false];
  // Disables the generation of the standard "descriptor()" accessor, which can
  // conflict with a field of the same name.  This is meant to make migration
  // from proto1 easier; new code should avoid fields named "descriptor".
  optional bool no_standard_descriptor_accessor = 2 [default = false];
  // Is this message deprecated?
  // Depending on the target platform, this can emit Deprecated annotations
  // for the message, or it will be completely ignored; in the very least,
  // this is a formalization for deprecating messages.
  optional bool deprecated = 3 [default = false];
  // Whether the message is an automatically generated map entry type for the
  // maps field.
  //
  // For maps fields:
  //     map<KeyType, ValueType> map_field = 1;
  // The parsed descriptor looks like:
  //     message MapFieldEntry {
  //         option map_entry = true;
  //         optional KeyType key = 1;
  //         optional ValueType value = 2;
  //     }
  //     repeated MapFieldEntry map_field = 1;
  //
  // Implementations may choose not to generate the map_entry=true message, but
  // use a native map in the target language to hold the keys and values.
  // The reflection APIs in such implementations still need to work as
  // if the field is a repeated message field.
  //
  // NOTE: Do not set the option in .proto files. Always use the maps syntax
  // instead. The option should only be implicitly set by the proto compiler
  // parser.
  optional bool map_entry = 7;
  // Enable the legacy handling of JSON field name conflicts.  This lowercases
  // and strips underscored from the fields before comparison in proto3 only.
  // The new behavior takes `json_name` into account and applies to proto2 as
  // well.
  //
  // This should only be used as a temporary measure against broken builds due
  // to the change in behavior for JSON field name conflicts.
  //
  // TODO This is legacy behavior we plan to remove once downstream
  // teams have had time to migrate.
  optional bool deprecated_legacy_json_field_conflicts = 11 [deprecated = true];
  // Any features defined in the specific edition.
  // WARNING: This field should only be used by protobuf plugins or special
  // cases like the proto compiler. Other uses are discouraged and
  // developers should rely on the protoreflect APIs for their client language.
  optional FeatureSet features = 12;
  // The parser stores options it doesn't recognize here. See above.
  repeated UninterpretedOption uninterpreted_option = 999;
  extensions 1000 to max;
  reserved 4, 5, 6, 8, 9;
}
// A message representing a option the parser does not recognize. This only
// appears in options protos created by the compiler::Parser class.
// DescriptorPool resolves these when building Descriptor objects. Therefore,
// options protos in descriptor objects (e.g. returned by Descriptor::options(),
// or produced by Descriptor::CopyTo()) will never have UninterpretedOptions
// in them.
message UninterpretedOption {
  repeated NamePart name = 2;
  // The value of the uninterpreted option, in whatever type the tokenizer
  // identified it as during parsing. Exactly one of these should be set.
  optional string identifier_value = 3;
  optional uint64 positive_int_value = 4;
  optional int64 negative_int_value = 5;
  optional double double_value = 6;
  optional bytes string_value = 7;
  optional string aggregate_value = 8;
  // The name of the uninterpreted option.  Each string represents a segment in
  // a dot-separated name.  is_extension is true iff a segment represents an
  // extension (denoted with parentheses in options specs in .proto files).
  // E.g.,{ ["foo", false], ["bar.baz", true], ["moo", false] } represents
  // "foo.(bar.baz).moo".
  message NamePart {
    required string name_part = 1;
    required bool is_extension = 2;
  }
}
-- test.proto --
// Keep 1: comment on syntax
syntax = "proto2";
// Keep 2: comment on package
package foo.bar;
// Keep if ext: comment on import descriptor.proto
import "google/protobuf/descriptor.proto";
// Keep 3: comment on option
option go_package = "foo.bar/baz";
// "Keep if Foo" are also kept for Bar, Svc, and Svc.Do since those
// elements depend on Foo.
// Keep if Foo: comment on message Foo
message Foo {
  // We keep the following comment for NestedFoo because we don't
  // discard options or option comments even if we're only retaining
  // a message as a namespace for another retained element.
  // Keep if Foo | NestedFoo: comment on option
  option (bizniz) = "abc";
  // Keep if Foo: comment on field name
  optional string name = 1;
  // Keep if Foo: comment on field bits
  repeated int64 bits = 2;
  message NestedFoo {
    // Keep if Foo + ext | NestedFoo: comment on option
    option (bizniz) = "abc";
    // Keep if Foo + ext: comment on extend block
    extend Foo {
      // Keep if Foo + ext: comment on extension blah
      repeated bytes blah = 101;
    }
  }
  extensions 100 to max;
  reserved 10 to 20;
  reserved "abc", "def", "ghi";
}
// Keep if ext: comment on extend block
extend google.protobuf.MessageOptions {
  // Keep if ext: comment on custom option bizniz
  optional string bizniz = 10101;
}
-- source_code_info.json --
{
  "location": [
    {
      "span": [
        1,
        0,
        153,
        1
      ]
    },
    {
      "path": [
        12
      ],
      "span": [
        1,
        0,
        18
      ],
      "leadingComments": " Keep 1: comment on syntax\n"
    },
    {
      "path": [
        2
      ],
      "span": [
        4,
        0,
        16
      ],
      "leadingComments": " Keep 2: comment on package\n"
    },
    {
      "path": [
        8
      ],
      "span": [
        7,
        0,
        34
      ]
    },
    {
      "path": [
        8,
        11
      ],
      "span": [
        7,
        0,
        34
      ],
      "leadingComments": " Keep 3: comment on option\n"
    },
    {
      "path": [
        3,
        0
      ],
      "span": [
        10,
        0,
        42
      ],
      "leadingComments": " Keep if ext: comment on import descriptor.proto\n"
    },
    {
      "path": [
        11,
        0
      ],
      "span": [
        13,
        7,
        11
      ]
    },
    {
      "path": [
        7
      ],
      "span": [
        19,
        0,
        22,
        1
      ],
      "leadingComments": " Keep if ext: comment on extend block\n"
    },
    {
      "path": [
        7,
        0
      ],
      "span": [
        21,
        2,
        33
      ],
      "leadingComments": " Keep if ext: comment on custom option bizniz\n"
    },
    {
      "path": [
        7,
        0,
        2
      ],
      "span": [
        19,
        7,
        37
      ]
    },
    {
      "path": [
        7,
        0,
        4
      ],
      "span": [
        21,
        2,
        10
      ]
    },
    {
      "path": [
        7,
        0,
        5
      ],
      "span": [
        21,
        11,
        17
      ]
    },
    {
      "path": [
        7,
        0,
        1
      ],
      "span": [
        21,
        18,
        24
      ]
    },
    {
      "path": [
        7,
        0,
        3
      ],
      "span": [
        21,
        27,
        32
      ]
    },
    {
      "path": [
        7
      ],
      "span": [
        25,
        0,
        28,
        1
      ],
      "leadingComments": " Keep if ext: comment on extend block\n"
    },
    {
      "path": [
        4,
        0
      ],
      "span": [
        40,
        0,
        89,
        1
      ],
      "leadingComments": " Keep if Foo: comment on message Foo\n",
      "trailingComments": " We keep the following comment for NestedFoo because we don't\n discard options or option comments even if we're only retaining\n a message as a namespace for another retained element.\n",
      "leadingDetachedComments": [
        " \"Keep if Foo\" are also kept for Bar, Svc, and Svc.Do since those\n elements depend on Foo.\n"
      ]
    },
    {
      "path": [
        4,
        0,
        1
      ],
      "span": [
        40,
        8,
        11
      ]
    },
    {
      "path": [
        4,
        0,
        7
      ],
      "span": [
        46,
        2,
        26
      ]
    },
    {
      "path": [
        4,
        0,
        7,
        10101
      ],
      "span": [
        46,
        2,
        26
      ],
      "leadingComments": " Keep if Foo | NestedFoo: comment on option\n"
    },
    {
      "path": [
        4,
        0,
        2,
        0
      ],
      "span": [
        49,
        2,
        27
      ],
      "leadingComments": " Keep if Foo: comment on field name\n"
    },
    {
      "path": [
        4,
        0,
        2,
        0,
        4
      ],
      "span": [
        49,
        2,
        10
      ]
    },
    {
      "path": [
        4,
        0,
        2,
        0,
        5
      ],
      "span": [
        49,
        11,
        17
      ]
    },
    {
      "path": [
        4,
        0,
        2,
        0,
        1
      ],
      "span": [
        49,
        18,
        22
      ]
    },
    {
      "path": [
        4,
        0,
        2,
        0,
        3
      ],
      "span": [
        49,
        25,
        26
      ]
    },
    {
      "path": [
        4,
        0,
        2,
        1
      ],
      "span": [
        51,
        2,
        26
      ],
      "leadingComments": " Keep if Foo: comment on field bits\n"
    },
    {
      "path": [
        4,
        0,
        2,
        1,
        4
      ],
      "span": [
        51,
        2,
        10
      ]
    },
    {
      "path": [
        4,
        0,
        2,
        1,
        5
      ],
      "span": [
        51,
        11,
        16
      ]
    },
    {
      "path": [
        4,
        0,
        2,
        1,
        1
      ],
      "span": [
        51,
        17,
        21
      ]
    },
    {
      "path": [
        4,
        0,
        2,
        1,
        3
      ],
      "span": [
        51,
        24,
        25
      ]
    },
    {
      "path": [
        4,
        0,
        9
      ],
      "span": [
        54,
        2,
        20
      ],
      "leadingComments": " Keep if Foo: comment on reserved range\n"
    },
    {
      "path": [
        4,
        0,
        9,
        0
      ],
      "span": [
        54,
        11,
        19
      ]
    },
    {
      "path": [
        4,
        0,
        9,
        0,
        1
      ],
      "span": [
        54,
        11,
        13
      ]
    },
    {
      "path": [
        4,
        0,
        9,
        0,
        2
      ],
      "span": [
        54,
        17,
        19
      ]
    },
    {
      "path": [
        4,
        0,
        10
      ],
      "span": [
        56,
        2,
        31
      ],
      "leadingComments": " Keep if Foo: comment on reserved names\n"
    },
    {
      "path": [
        4,
        0,
        10,
        0
      ],
      "span": [
        56,
        11,
        16
      ]
    },
    {
      "path": [
        4,
        0,
        10,
        1
      ],
      "span": [
        56,
        18,
        23
      ]
    },
    {
      "path": [
        4,
        0,
        10,
        2
      ],
      "span": [
        56,
        25,
        30
      ]
    },
    {
      "path": [
        4,
        0,
        5
      ],
      "span": [
        58,
        2,
        24
      ],
      "leadingComments": " Keep if Foo: comment on extension range\n"
    },
    {
      "path": [
        4,
        0,
        5,
        0
      ],
      "span": [
        58,
        13,
        23
      ]
    },
    {
      "path": [
        4,
        0,
        5,
        0,
        1
      ],
      "span": [
        58,
        13,
        16
      ]
    },
    {
      "path": [
        4,
        0,
        5,
        0,
        2
      ],
      "span": [
        58,
        20,
        23
      ]
    },
    {
      "path": [
        4,
        0,
        3,
        0
      ],
      "span": [
        61,
        2,
        88,
        3
      ]
    },
    {
      "path": [
        4,
        0,
        3,
        0,
        1
      ],
      "span": [
        61,
        10,
        19
      ]
    },
    {
      "path": [
        4,
        0,
        3,
        0,
        7
      ],
      "span": [
        67,
        4,
        28
      ]
    },
    {
      "path": [
        4,
        0,
        3,
        0,
        7,
        10101
      ],
      "span": [
        67,
        4,
        28
      ],
      "leadingComments": " Keep if Foo + ext | NestedFoo: comment on option\n"
    },
    {
      "path": [
        4,
        0,
        3,
        0,
        6
      ],
      "span": [
        84,
        4,
        87,
        5
      ],
      "leadingComments": " Keep if Foo + ext: comment on extend block\n"
    },
    {
      "path": [
        4,
        0,
        3,
        0,
        6,
        0
      ],
      "span": [
        86,
        6,
        32
      ],
      "leadingComments": " Keep if Foo + ext: comment on extension blah\n"
    },
    {
      "path": [
        4,
        0,
        3,
        0,
        6,
        0,
        2
      ],
      "span": [
        84,
        11,
        14
      ]
    },
    {
      "path": [
        4,
        0,
        3,
        0,
        6,
        0,
        4
      ],
      "span": [
        86,
        6,
        14
      ]
    },
    {
      "path": [
        4,
        0,
        3,
        0,
        6,
        0,
        5
      ],
      "span": [
        86,
        15,
        20
      ]
    },
    {
      "path": [
        4,
        0,
        3,
        0,
        6,
        0,
        1
      ],
      "span": [
        86,
        21,
        25
      ]
    },
    {
      "path": [
        4,
        0,
        3,
        0,
        6,
        0,
        3
      ],
      "span": [
        86,
        28,
        31
      ]
    }
  ]
}