// Copyright 2023-2025 Buf Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

syntax = "proto2";

package buf.validate;

import "google/protobuf/descriptor.proto";
import "google/protobuf/duration.proto";
import "google/protobuf/field_mask.proto";
import "google/protobuf/timestamp.proto";

option go_package = "buf.build/gen/go/bufbuild/protovalidate/protocolbuffers/go/buf/validate";
option java_multiple_files = true;
option java_outer_classname = "ValidateProto";
option java_package = "build.buf.validate";

// MessageOptions is an extension to google.protobuf.MessageOptions. It allows
// the addition of validation rules at the message level. These rules can be
// applied to incoming messages to ensure they meet certain criteria before
// being processed.
extend google.protobuf.MessageOptions {
  // Rules specify the validations to be performed on this message. By default,
  // no validation is performed against a message.
  optional MessageRules message = 1159;
}

// OneofOptions is an extension to google.protobuf.OneofOptions. It allows
// the addition of validation rules on a oneof. These rules can be
// applied to incoming messages to ensure they meet certain criteria before
// being processed.
extend google.protobuf.OneofOptions {
  // Rules specify the validations to be performed on this oneof. By default,
  // no validation is performed against a oneof.
  optional OneofRules oneof = 1159;
}

// FieldOptions is an extension to google.protobuf.FieldOptions. It allows
// the addition of validation rules at the field level. These rules can be
// applied to incoming messages to ensure they meet certain criteria before
// being processed.
extend google.protobuf.FieldOptions {
  // Rules specify the validations to be performed on this field. By default,
  // no validation is performed against a field.
  optional FieldRules field = 1159;

  // Specifies predefined rules. When extending a standard rule message,
  // this adds additional CEL expressions that apply when the extension is used.
  //
  // ```proto
  // extend buf.validate.Int32Rules {
  //   bool is_zero [(buf.validate.predefined).cel = {
  //     id: "int32.is_zero",
  //     message: "value must be zero",
  //     expression: "!rule || this == 0",
  //   }];
  // }
  //
  // message Foo {
  //   int32 reserved = 1 [(buf.validate.field).int32.(is_zero) = true];
  // }
  // ```
  optional PredefinedRules predefined = 1160;
}

// `Rule` represents a validation rule written in the Common Expression
// Language (CEL) syntax. Each Rule includes a unique identifier, an
// optional error message, and the CEL expression to evaluate. For more
// information, [see our documentation](https://buf.build/docs/protovalidate/schemas/custom-rules/).
//
// ```proto
// message Foo {
//   option (buf.validate.message).cel = {
//     id: "foo.bar"
//     message: "bar must be greater than 0"
//     expression: "this.bar > 0"
//   };
//   int32 bar = 1;
// }
// ```
message Rule {
  // `id` is a string that serves as a machine-readable name for this Rule.
  // It should be unique within its scope, which could be either a message or a field.
  optional string id = 1;

  // `message` is an optional field that provides a human-readable error message
  // for this Rule when the CEL expression evaluates to false. If a
  // non-empty message is provided, any strings resulting from the CEL
  // expression evaluation are ignored.
  optional string message = 2;

  // `expression` is the actual CEL expression that will be evaluated for
  // validation. This string must resolve to either a boolean or a string
  // value. If the expression evaluates to false or a non-empty string, the
  // validation is considered failed, and the message is rejected.
  optional string expression = 3;
}

// MessageRules represents validation rules that are applied to the entire message.
// It includes disabling options and a list of Rule messages representing Common Expression Language (CEL) validation rules.
message MessageRules {
  // `cel_expression` is a repeated field CEL expressions. Each expression specifies a validation
  // rule to be applied to this message. These rules are written in Common Expression Language (CEL) syntax.
  //
  // This is a simplified form of the `cel` Rule field, where only `expression` is set. This allows for
  // simpler syntax when defining CEL Rules where `id` and `message` derived from the `expression`. `id` will
  // be same as the `expression`.
  //
  // For more information, [see our documentation](https://buf.build/docs/protovalidate/schemas/custom-rules/).
  //
  // ```proto
  // message MyMessage {
  //   // The field `foo` must be greater than 42.
  //   option (buf.validate.message).cel_expression = "this.foo > 42";
  //   // The field `foo` must be less than 84.
  //   option (buf.validate.message).cel_expression = "this.foo < 84";
  //   optional int32 foo = 1;
  // }
  // ```
  repeated string cel_expression = 5;
  // `cel` is a repeated field of type Rule. Each Rule specifies a validation rule to be applied to this message.
  // These rules are written in Common Expression Language (CEL) syntax. For more information,
  // [see our documentation](https://buf.build/docs/protovalidate/schemas/custom-rules/).
  //
  //
  // ```proto
  // message MyMessage {
  //   // The field `foo` must be greater than 42.
  //   option (buf.validate.message).cel = {
  //     id: "my_message.value",
  //     message: "value must be greater than 42",
  //     expression: "this.foo > 42",
  //   };
  //   optional int32 foo = 1;
  // }
  // ```
  repeated Rule cel = 3;

  // `oneof` is a repeated field of type MessageOneofRule that specifies a list of fields
  // of which at most one can be present. If `required` is also specified, then exactly one
  // of the specified fields _must_ be present.
  //
  // This will enforce oneof-like constraints with a few features not provided by
  // actual Protobuf oneof declarations:
  //   1. Repeated and map fields are allowed in this validation. In a Protobuf oneof,
  //      only scalar fields are allowed.
  //   2. Fields with implicit presence are allowed. In a Protobuf oneof, all member
  //      fields have explicit presence. This means that, for the purpose of determining
  //      how many fields are set, explicitly setting such a field to its zero value is
  //      effectively the same as not setting it at all.
  //   3. This will always generate validation errors for a message unmarshalled from
  //      serialized data that sets more than one field. With a Protobuf oneof, when
  //      multiple fields are present in the serialized form, earlier values are usually
  //      silently ignored when unmarshalling, with only the last field being set when
  //      unmarshalling completes.
  //
  // Note that adding a field to a `oneof` will also set the IGNORE_IF_ZERO_VALUE on the fields. This means
  // only the field that is set will be validated and the unset fields are not validated according to the field rules.
  // This behavior can be overridden by setting `ignore` against a field.
  //
  // ```proto
  // message MyMessage {
  //   // Only one of `field1` or `field2` _can_ be present in this message.
  //   option (buf.validate.message).oneof = { fields: ["field1", "field2"] };
  //   // Exactly one of `field3` or `field4` _must_ be present in this message.
  //   option (buf.validate.message).oneof = { fields: ["field3", "field4"], required: true };
  //   string field1 = 1;
  //   bytes field2 = 2;
  //   bool field3 = 3;
  //   int32 field4 = 4;
  // }
  // ```
  repeated MessageOneofRule oneof = 4;

  reserved 1;
  reserved "disabled";
}

message MessageOneofRule {
  // A list of field names to include in the oneof. All field names must be
  // defined in the message. At least one field must be specified, and
  // duplicates are not permitted.
  repeated string fields = 1;
  // If true, one of the fields specified _must_ be set.
  optional bool required = 2;
}

// The `OneofRules` message type enables you to manage rules for
// oneof fields in your protobuf messages.
message OneofRules {
  // If `required` is true, exactly one field of the oneof must be set. A
  // validation error is returned if no fields in the oneof are set. Further rules
  // should be placed on the fields themselves to ensure they are valid values,
  // such as `min_len` or `gt`.
  //
  // ```proto
  // message MyMessage {
  //   oneof value {
  //     // Either `a` or `b` must be set. If `a` is set, it must also be
  //     // non-empty; whereas if `b` is set, it can still be an empty string.
  //     option (buf.validate.oneof).required = true;
  //     string a = 1 [(buf.validate.field).string.min_len = 1];
  //     string b = 2;
  //   }
  // }
  // ```
  optional bool required = 1;
}

// FieldRules encapsulates the rules for each type of field. Depending on
// the field, the correct set should be used to ensure proper validations.
message FieldRules {
  // `cel_expression` is a repeated field CEL expressions. Each expression specifies a validation
  // rule to be applied to this message. These rules are written in Common Expression Language (CEL) syntax.
  //
  // This is a simplified form of the `cel` Rule field, where only `expression` is set. This allows for
  // simpler syntax when defining CEL Rules where `id` and `message` derived from the `expression`. `id` will
  // be same as the `expression`.
  //
  // For more information, [see our documentation](https://buf.build/docs/protovalidate/schemas/custom-rules/).
  //
  // ```proto
  // message MyMessage {
  //   // The field `value` must be greater than 42.
  //   optional int32 value = 1 [(buf.validate.field).cel_expression = "this > 42"];
  // }
  // ```
  repeated string cel_expression = 29;
  // `cel` is a repeated field used to represent a textual expression
  // in the Common Expression Language (CEL) syntax. For more information,
  // [see our documentation](https://buf.build/docs/protovalidate/schemas/custom-rules/).
  //
  // ```proto
  // message MyMessage {
  //   // The field `value` must be greater than 42.
  //   optional int32 value = 1 [(buf.validate.field).cel = {
  //     id: "my_message.value",
  //     message: "value must be greater than 42",
  //     expression: "this > 42",
  //   }];
  // }
  // ```
  repeated Rule cel = 23;
  // If `required` is true, the field must be set. A validation error is returned
  // if the field is not set.
  //
  // ```proto
  // syntax="proto3";
  //
  // message FieldsWithPresence {
  //   // Requires any string to be set, including the empty string.
  //   optional string link = 1 [
  //     (buf.validate.field).required = true
  //   ];
  //   // Requires true or false to be set.
  //   optional bool disabled = 2 [
  //     (buf.validate.field).required = true
  //   ];
  //   // Requires a message to be set, including the empty message.
  //   SomeMessage msg = 4 [
  //     (buf.validate.field).required = true
  //   ];
  // }
  // ```
  //
  // All fields in the example above track presence. By default, Protovalidate
  // ignores rules on those fields if no value is set. `required` ensures that
  // the fields are set and valid.
  //
  // Fields that don't track presence are always validated by Protovalidate,
  // whether they are set or not. It is not necessary to add `required`. It
  // can be added to indicate that the field cannot be the zero value.
  //
  // ```proto
  // syntax="proto3";
  //
  // message FieldsWithoutPresence {
  //   // `string.email` always applies, even to an empty string.
  //   string link = 1 [
  //     (buf.validate.field).string.email = true
  //   ];
  //   // `repeated.min_items` always applies, even to an empty list.
  //   repeated string labels = 2 [
  //     (buf.validate.field).repeated.min_items = 1
  //   ];
  //   // `required`, for fields that don't track presence, indicates
  //   // the value of the field can't be the zero value.
  //   int32 zero_value_not_allowed = 3 [
  //     (buf.validate.field).required = true
  //   ];
  // }
  // ```
  //
  // To learn which fields track presence, see the
  // [Field Presence cheat sheet](https://protobuf.dev/programming-guides/field_presence/#cheat).
  //
  // Note: While field rules can be applied to repeated items, map keys, and map
  // values, the elements are always considered to be set. Consequently,
  // specifying `repeated.items.required` is redundant.
  optional bool required = 25;
  // Ignore validation rules on the field if its value matches the specified
  // criteria. See the `Ignore` enum for details.
  //
  // ```proto
  // message UpdateRequest {
  //   // The uri rule only applies if the field is not an empty string.
  //   string url = 1 [
  //     (buf.validate.field).ignore = IGNORE_IF_ZERO_VALUE,
  //     (buf.validate.field).string.uri = true
  //   ];
  // }
  // ```
  optional Ignore ignore = 27;

  oneof type {
    // Scalar Field Types
    FloatRules float = 1;
    DoubleRules double = 2;
    Int32Rules int32 = 3;
    Int64Rules int64 = 4;
    UInt32Rules uint32 = 5;
    UInt64Rules uint64 = 6;
    SInt32Rules sint32 = 7;
    SInt64Rules sint64 = 8;
    Fixed32Rules fixed32 = 9;
    Fixed64Rules fixed64 = 10;
    SFixed32Rules sfixed32 = 11;
    SFixed64Rules sfixed64 = 12;
    BoolRules bool = 13;
    StringRules string = 14;
    BytesRules bytes = 15;

    // Complex Field Types
    EnumRules enum = 16;
    RepeatedRules repeated = 18;
    MapRules map = 19;

    // Well-Known Field Types
    AnyRules any = 20;
    DurationRules duration = 21;
    FieldMaskRules field_mask = 28;
    TimestampRules timestamp = 22;
  }

  reserved 24, 26;
  reserved "skipped", "ignore_empty";
}

// PredefinedRules are custom rules that can be re-used with
// multiple fields.
message PredefinedRules {
  // `cel` is a repeated field used to represent a textual expression
  // in the Common Expression Language (CEL) syntax. For more information,
  // [see our documentation](https://buf.build/docs/protovalidate/schemas/predefined-rules/).
  //
  // ```proto
  // message MyMessage {
  //   // The field `value` must be greater than 42.
  //   optional int32 value = 1 [(buf.validate.predefined).cel = {
  //     id: "my_message.value",
  //     message: "value must be greater than 42",
  //     expression: "this > 42",
  //   }];
  // }
  // ```
  repeated Rule cel = 1;

  reserved 24, 26;
  reserved "skipped", "ignore_empty";
}

// Specifies how `FieldRules.ignore` behaves, depending on the field's value, and
// whether the field tracks presence.
enum Ignore {
  // Ignore rules if the field tracks presence and is unset. This is the default
  // behavior.
  //
  // In proto3, only message fields, members of a Protobuf `oneof`, and fields
  // with the `optional` label track presence. Consequently, the following fields
  // are always validated, whether a value is set or not:
  //
  // ```proto
  // syntax="proto3";
  //
  // message RulesApply {
  //   string email = 1 [
  //     (buf.validate.field).string.email = true
  //   ];
  //   int32 age = 2 [
  //     (buf.validate.field).int32.gt = 0
  //   ];
  //   repeated string labels = 3 [
  //     (buf.validate.field).repeated.min_items = 1
  //   ];
  // }
  // ```
  //
  // In contrast, the following fields track presence, and are only validated if
  // a value is set:
  //
  // ```proto
  // syntax="proto3";
  //
  // message RulesApplyIfSet {
  //   optional string email = 1 [
  //     (buf.validate.field).string.email = true
  //   ];
  //   oneof ref {
  //     string reference = 2 [
  //       (buf.validate.field).string.uuid = true
  //     ];
  //     string name = 3 [
  //       (buf.validate.field).string.min_len = 4
  //     ];
  //   }
  //   SomeMessage msg = 4 [
  //     (buf.validate.field).cel = {/* ... */}
  //   ];
  // }
  // ```
  //
  // To ensure that such a field is set, add the `required` rule.
  //
  // To learn which fields track presence, see the
  // [Field Presence cheat sheet](https://protobuf.dev/programming-guides/field_presence/#cheat).
  IGNORE_UNSPECIFIED = 0;

  // Ignore rules if the field is unset, or set to the zero value.
  //
  // The zero value depends on the field type:
  // - For strings, the zero value is the empty string.
  // - For bytes, the zero value is empty bytes.
  // - For bool, the zero value is false.
  // - For numeric types, the zero value is zero.
  // - For enums, the zero value is the first defined enum value.
  // - For repeated fields, the zero is an empty list.
  // - For map fields, the zero is an empty map.
  // - For message fields, absence of the message (typically a null-value) is considered zero value.
  //
  // For fields that track presence (e.g. adding the `optional` label in proto3),
  // this a no-op and behavior is the same as the default `IGNORE_UNSPECIFIED`.
  IGNORE_IF_ZERO_VALUE = 1;

  // Always ignore rules, including the `required` rule.
  //
  // This is useful for ignoring the rules of a referenced message, or to
  // temporarily ignore rules during development.
  //
  // ```proto
  // message MyMessage {
  //   // The field's rules will always be ignored, including any validations
  //   // on value's fields.
  //   MyOtherMessage value = 1 [
  //     (buf.validate.field).ignore = IGNORE_ALWAYS
  //   ];
  // }
  // ```
  IGNORE_ALWAYS = 3;

  reserved 2;
  reserved "IGNORE_EMPTY", "IGNORE_DEFAULT", "IGNORE_IF_DEFAULT_VALUE", "IGNORE_IF_UNPOPULATED";
}

// FloatRules describes the rules applied to `float` values. These
// rules may also be applied to the `google.protobuf.FloatValue` Well-Known-Type.
message FloatRules {
  // `const` requires the field value to exactly match the specified value. If
  // the field value doesn't match, an error message is generated.
  //
  // ```proto
  // message MyFloat {
  //   // value must equal 42.0
  //   float value = 1 [(buf.validate.field).float.const = 42.0];
  // }
  // ```
  optional float const = 1 [(predefined).cel = {
    id: "float.const"
    expression: "this != getField(rules, 'const') ? 'value must equal %s'.format([getField(rules, 'const')]) : ''"
  }];

  oneof less_than {
    // `lt` requires the field value to be less than the specified value (field <
    // value). If the field value is equal to or greater than the specified value,
    // an error message is generated.
    //
    // ```proto
    // message MyFloat {
    //   // value must be less than 10.0
    //   float value = 1 [(buf.validate.field).float.lt = 10.0];
    // }
    // ```
    float lt = 2 [(predefined).cel = {
      id: "float.lt"
      expression:
        "!has(rules.gte) && !has(rules.gt) && (this.isNan() || this >= rules.lt)"
        "? 'value must be less than %s'.format([rules.lt]) : ''"
    }];

    // `lte` requires the field value to be less than or equal to the specified
    // value (field <= value). If the field value is greater than the specified
    // value, an error message is generated.
    //
    // ```proto
    // message MyFloat {
    //   // value must be less than or equal to 10.0
    //   float value = 1 [(buf.validate.field).float.lte = 10.0];
    // }
    // ```
    float lte = 3 [(predefined).cel = {
      id: "float.lte"
      expression:
        "!has(rules.gte) && !has(rules.gt) && (this.isNan() || this > rules.lte)"
        "? 'value must be less than or equal to %s'.format([rules.lte]) : ''"
    }];
  }

  oneof greater_than {
    // `gt` requires the field value to be greater than the specified value
    // (exclusive). If the value of `gt` is larger than a specified `lt` or
    // `lte`, the range is reversed, and the field value must be outside the
    // specified range. If the field value doesn't meet the required conditions,
    // an error message is generated.
    //
    // ```proto
    // message MyFloat {
    //   // value must be greater than 5.0 [float.gt]
    //   float value = 1 [(buf.validate.field).float.gt = 5.0];
    //
    //   // value must be greater than 5 and less than 10.0 [float.gt_lt]
    //   float other_value = 2 [(buf.validate.field).float = { gt: 5.0, lt: 10.0 }];
    //
    //   // value must be greater than 10 or less than 5.0 [float.gt_lt_exclusive]
    //   float another_value = 3 [(buf.validate.field).float = { gt: 10.0, lt: 5.0 }];
    // }
    // ```
    float gt = 4 [
      (predefined).cel = {
        id: "float.gt"
        expression:
          "!has(rules.lt) && !has(rules.lte) && (this.isNan() || this <= rules.gt)"
          "? 'value must be greater than %s'.format([rules.gt]) : ''"
      },
      (predefined).cel = {
        id: "float.gt_lt"
        expression:
          "has(rules.lt) && rules.lt >= rules.gt && (this.isNan() || this >= rules.lt || this <= rules.gt)"
          "? 'value must be greater than %s and less than %s'.format([rules.gt, rules.lt]) : ''"
      },
      (predefined).cel = {
        id: "float.gt_lt_exclusive"
        expression:
          "has(rules.lt) && rules.lt < rules.gt && (this.isNan() || (rules.lt <= this && this <= rules.gt))"
          "? 'value must be greater than %s or less than %s'.format([rules.gt, rules.lt]) : ''"
      },
      (predefined).cel = {
        id: "float.gt_lte"
        expression:
          "has(rules.lte) && rules.lte >= rules.gt && (this.isNan() || this > rules.lte || this <= rules.gt)"
          "? 'value must be greater than %s and less than or equal to %s'.format([rules.gt, rules.lte]) : ''"
      },
      (predefined).cel = {
        id: "float.gt_lte_exclusive"
        expression:
          "has(rules.lte) && rules.lte < rules.gt && (this.isNan() || (rules.lte < this && this <= rules.gt))"
          "? 'value must be greater than %s or less than or equal to %s'.format([rules.gt, rules.lte]) : ''"
      }
    ];

    // `gte` requires the field value to be greater than or equal to the specified
    // value (exclusive). If the value of `gte` is larger than a specified `lt`
    // or `lte`, the range is reversed, and the field value must be outside the
    // specified range. If the field value doesn't meet the required conditions,
    // an error message is generated.
    //
    // ```proto
    // message MyFloat {
    //   // value must be greater than or equal to 5.0 [float.gte]
    //   float value = 1 [(buf.validate.field).float.gte = 5.0];
    //
    //   // value must be greater than or equal to 5.0 and less than 10.0 [float.gte_lt]
    //   float other_value = 2 [(buf.validate.field).float = { gte: 5.0, lt: 10.0 }];
    //
    //   // value must be greater than or equal to 10.0 or less than 5.0 [float.gte_lt_exclusive]
    //   float another_value = 3 [(buf.validate.field).float = { gte: 10.0, lt: 5.0 }];
    // }
    // ```
    float gte = 5 [
      (predefined).cel = {
        id: "float.gte"
        expression:
          "!has(rules.lt) && !has(rules.lte) && (this.isNan() || this < rules.gte)"
          "? 'value must be greater than or equal to %s'.format([rules.gte]) : ''"
      },
      (predefined).cel = {
        id: "float.gte_lt"
        expression:
          "has(rules.lt) && rules.lt >= rules.gte && (this.isNan() || this >= rules.lt || this < rules.gte)"
          "? 'value must be greater than or equal to %s and less than %s'.format([rules.gte, rules.lt]) : ''"
      },
      (predefined).cel = {
        id: "float.gte_lt_exclusive"
        expression:
          "has(rules.lt) && rules.lt < rules.gte && (this.isNan() || (rules.lt <= this && this < rules.gte))"
          "? 'value must be greater than or equal to %s or less than %s'.format([rules.gte, rules.lt]) : ''"
      },
      (predefined).cel = {
        id: "float.gte_lte"
        expression:
          "has(rules.lte) && rules.lte >= rules.gte && (this.isNan() || this > rules.lte || this < rules.gte)"
          "? 'value must be greater than or equal to %s and less than or equal to %s'.format([rules.gte, rules.lte]) : ''"
      },
      (predefined).cel = {
        id: "float.gte_lte_exclusive"
        expression:
          "has(rules.lte) && rules.lte < rules.gte && (this.isNan() || (rules.lte < this && this < rules.gte))"
          "? 'value must be greater than or equal to %s or less than or equal to %s'.format([rules.gte, rules.lte]) : ''"
      }
    ];
  }

  // `in` requires the field value to be equal to one of the specified values.
  // If the field value isn't one of the specified values, an error message
  // is generated.
  //
  // ```proto
  // message MyFloat {
  //   // value must be in list [1.0, 2.0, 3.0]
  //   float value = 1 [(buf.validate.field).float = { in: [1.0, 2.0, 3.0] }];
  // }
  // ```
  repeated float in = 6 [(predefined).cel = {
    id: "float.in"
    expression: "!(this in getField(rules, 'in')) ? 'value must be in list %s'.format([getField(rules, 'in')]) : ''"
  }];

  // `in` requires the field value to not be equal to any of the specified
  // values. If the field value is one of the specified values, an error
  // message is generated.
  //
  // ```proto
  // message MyFloat {
  //   // value must not be in list [1.0, 2.0, 3.0]
  //   float value = 1 [(buf.validate.field).float = { not_in: [1.0, 2.0, 3.0] }];
  // }
  // ```
  repeated float not_in = 7 [(predefined).cel = {
    id: "float.not_in"
    expression: "this in rules.not_in ? 'value must not be in list %s'.format([rules.not_in]) : ''"
  }];

  // `finite` requires the field value to be finite. If the field value is
  // infinite or NaN, an error message is generated.
  optional bool finite = 8 [(predefined).cel = {
    id: "float.finite"
    expression: "rules.finite ? (this.isNan() || this.isInf() ? 'value must be finite' : '') : ''"
  }];

  // `example` specifies values that the field may have. These values SHOULD
  // conform to other rules. `example` values will not impact validation
  // but may be used as helpful guidance on how to populate the given field.
  //
  // ```proto
  // message MyFloat {
  //   float value = 1 [
  //     (buf.validate.field).float.example = 1.0,
  //     (buf.validate.field).float.example = inf
  //   ];
  // }
  // ```
  repeated float example = 9 [(predefined).cel = {
    id: "float.example"
    expression: "true"
  }];

  // Extension fields in this range that have the (buf.validate.predefined)
  // option set will be treated as predefined field rules that can then be
  // set on the field options of other fields to apply field rules.
  // Extension numbers 1000 to 99999 are reserved for extension numbers that are
  // defined in the [Protobuf Global Extension Registry][1]. Extension numbers
  // above this range are reserved for extension numbers that are not explicitly
  // assigned. For rules defined in publicly-consumed schemas, use of extensions
  // above 99999 is discouraged due to the risk of conflicts.
  //
  // [1]: https://github.com/protocolbuffers/protobuf/blob/main/docs/options.md
  extensions 1000 to max;
}

// DoubleRules describes the rules applied to `double` values. These
// rules may also be applied to the `google.protobuf.DoubleValue` Well-Known-Type.
message DoubleRules {
  // `const` requires the field value to exactly match the specified value. If
  // the field value doesn't match, an error message is generated.
  //
  // ```proto
  // message MyDouble {
  //   // value must equal 42.0
  //   double value = 1 [(buf.validate.field).double.const = 42.0];
  // }
  // ```
  optional double const = 1 [(predefined).cel = {
    id: "double.const"
    expression: "this != getField(rules, 'const') ? 'value must equal %s'.format([getField(rules, 'const')]) : ''"
  }];
  oneof less_than {
    // `lt` requires the field value to be less than the specified value (field <
    // value). If the field value is equal to or greater than the specified
    // value, an error message is generated.
    //
    // ```proto
    // message MyDouble {
    //   // value must be less than 10.0
    //   double value = 1 [(buf.validate.field).double.lt = 10.0];
    // }
    // ```
    double lt = 2 [(predefined).cel = {
      id: "double.lt"
      expression:
        "!has(rules.gte) && !has(rules.gt) && (this.isNan() || this >= rules.lt)"
        "? 'value must be less than %s'.format([rules.lt]) : ''"
    }];

    // `lte` requires the field value to be less than or equal to the specified value
    // (field <= value). If the field value is greater than the specified value,
    // an error message is generated.
    //
    // ```proto
    // message MyDouble {
    //   // value must be less than or equal to 10.0
    //   double value = 1 [(buf.validate.field).double.lte = 10.0];
    // }
    // ```
    double lte = 3 [(predefined).cel = {
      id: "double.lte"
      expression:
        "!has(rules.gte) && !has(rules.gt) && (this.isNan() || this > rules.lte)"
        "? 'value must be less than or equal to %s'.format([rules.lte]) : ''"
    }];
  }
  oneof greater_than {
    // `gt` requires the field value to be greater than the specified value
    // (exclusive). If the value of `gt` is larger than a specified `lt` or `lte`,
    // the range is reversed, and the field value must be outside the specified
    // range. If the field value doesn't meet the required conditions, an error
    // message is generated.
    //
    // ```proto
    // message MyDouble {
    //   // value must be greater than 5.0 [double.gt]
    //   double value = 1 [(buf.validate.field).double.gt = 5.0];
    //
    //   // value must be greater than 5 and less than 10.0 [double.gt_lt]
    //   double other_value = 2 [(buf.validate.field).double = { gt: 5.0, lt: 10.0 }];
    //
    //   // value must be greater than 10 or less than 5.0 [double.gt_lt_exclusive]
    //   double another_value = 3 [(buf.validate.field).double = { gt: 10.0, lt: 5.0 }];
    // }
    // ```
    double gt = 4 [
      (predefined).cel = {
        id: "double.gt"
        expression:
          "!has(rules.lt) && !has(rules.lte) && (this.isNan() || this <= rules.gt)"
          "? 'value must be greater than %s'.format([rules.gt]) : ''"
      },
      (predefined).cel = {
        id: "double.gt_lt"
        expression:
          "has(rules.lt) && rules.lt >= rules.gt && (this.isNan() || this >= rules.lt || this <= rules.gt)"
          "? 'value must be greater than %s and less than %s'.format([rules.gt, rules.lt]) : ''"
      },
      (predefined).cel = {
        id: "double.gt_lt_exclusive"
        expression:
          "has(rules.lt) && rules.lt < rules.gt && (this.isNan() || (rules.lt <= this && this <= rules.gt))"
          "? 'value must be greater than %s or less than %s'.format([rules.gt, rules.lt]) : ''"
      },
      (predefined).cel = {
        id: "double.gt_lte"
        expression:
          "has(rules.lte) && rules.lte >= rules.gt && (this.isNan() || this > rules.lte || this <= rules.gt)"
          "? 'value must be greater than %s and less than or equal to %s'.format([rules.gt, rules.lte]) : ''"
      },
      (predefined).cel = {
        id: "double.gt_lte_exclusive"
        expression:
          "has(rules.lte) && rules.lte < rules.gt && (this.isNan() || (rules.lte < this && this <= rules.gt))"
          "? 'value must be greater than %s or less than or equal to %s'.format([rules.gt, rules.lte]) : ''"
      }
    ];

    // `gte` requires the field value to be greater than or equal to the specified
    // value (exclusive). If the value of `gte` is larger than a specified `lt` or
    // `lte`, the range is reversed, and the field value must be outside the
    // specified range. If the field value doesn't meet the required conditions,
    // an error message is generated.
    //
    // ```proto
    // message MyDouble {
    //   // value must be greater than or equal to 5.0 [double.gte]
    //   double value = 1 [(buf.validate.field).double.gte = 5.0];
    //
    //   // value must be greater than or equal to 5.0 and less than 10.0 [double.gte_lt]
    //   double other_value = 2 [(buf.validate.field).double = { gte: 5.0, lt: 10.0 }];
    //
    //   // value must be greater than or equal to 10.0 or less than 5.0 [double.gte_lt_exclusive]
    //   double another_value = 3 [(buf.validate.field).double = { gte: 10.0, lt: 5.0 }];
    // }
    // ```
    double gte = 5 [
      (predefined).cel = {
        id: "double.gte"
        expression:
          "!has(rules.lt) && !has(rules.lte) && (this.isNan() || this < rules.gte)"
          "? 'value must be greater than or equal to %s'.format([rules.gte]) : ''"
      },
      (predefined).cel = {
        id: "double.gte_lt"
        expression:
          "has(rules.lt) && rules.lt >= rules.gte && (this.isNan() || this >= rules.lt || this < rules.gte)"
          "? 'value must be greater than or equal to %s and less than %s'.format([rules.gte, rules.lt]) : ''"
      },
      (predefined).cel = {
        id: "double.gte_lt_exclusive"
        expression:
          "has(rules.lt) && rules.lt < rules.gte && (this.isNan() || (rules.lt <= this && this < rules.gte))"
          "? 'value must be greater than or equal to %s or less than %s'.format([rules.gte, rules.lt]) : ''"
      },
      (predefined).cel = {
        id: "double.gte_lte"
        expression:
          "has(rules.lte) && rules.lte >= rules.gte && (this.isNan() || this > rules.lte || this < rules.gte)"
          "? 'value must be greater than or equal to %s and less than or equal to %s'.format([rules.gte, rules.lte]) : ''"
      },
      (predefined).cel = {
        id: "double.gte_lte_exclusive"
        expression:
          "has(rules.lte) && rules.lte < rules.gte && (this.isNan() || (rules.lte < this && this < rules.gte))"
          "? 'value must be greater than or equal to %s or less than or equal to %s'.format([rules.gte, rules.lte]) : ''"
      }
    ];
  }
  // `in` requires the field value to be equal to one of the specified values.
  // If the field value isn't one of the specified values, an error message is
  // generated.
  //
  // ```proto
  // message MyDouble {
  //   // value must be in list [1.0, 2.0, 3.0]
  //   double value = 1 [(buf.validate.field).double = { in: [1.0, 2.0, 3.0] }];
  // }
  // ```
  repeated double in = 6 [(predefined).cel = {
    id: "double.in"
    expression: "!(this in getField(rules, 'in')) ? 'value must be in list %s'.format([getField(rules, 'in')]) : ''"
  }];

  // `not_in` requires the field value to not be equal to any of the specified
  // values. If the field value is one of the specified values, an error
  // message is generated.
  //
  // ```proto
  // message MyDouble {
  //   // value must not be in list [1.0, 2.0, 3.0]
  //   double value = 1 [(buf.validate.field).double = { not_in: [1.0, 2.0, 3.0] }];
  // }
  // ```
  repeated double not_in = 7 [(predefined).cel = {
    id: "double.not_in"
    expression: "this in rules.not_in ? 'value must not be in list %s'.format([rules.not_in]) : ''"
  }];

  // `finite` requires the field value to be finite. If the field value is
  // infinite or NaN, an error message is generated.
  optional bool finite = 8 [(predefined).cel = {
    id: "double.finite"
    expression: "rules.finite ? (this.isNan() || this.isInf() ? 'value must be finite' : '') : ''"
  }];

  // `example` specifies values that the field may have. These values SHOULD
  // conform to other rules. `example` values will not impact validation
  // but may be used as helpful guidance on how to populate the given field.
  //
  // ```proto
  // message MyDouble {
  //   double value = 1 [
  //     (buf.validate.field).double.example = 1.0,
  //     (buf.validate.field).double.example = inf
  //   ];
  // }
  // ```
  repeated double example = 9 [(predefined).cel = {
    id: "double.example"
    expression: "true"
  }];

  // Extension fields in this range that have the (buf.validate.predefined)
  // option set will be treated as predefined field rules that can then be
  // set on the field options of other fields to apply field rules.
  // Extension numbers 1000 to 99999 are reserved for extension numbers that are
  // defined in the [Protobuf Global Extension Registry][1]. Extension numbers
  // above this range are reserved for extension numbers that are not explicitly
  // assigned. For rules defined in publicly-consumed schemas, use of extensions
  // above 99999 is discouraged due to the risk of conflicts.
  //
  // [1]: https://github.com/protocolbuffers/protobuf/blob/main/docs/options.md
  extensions 1000 to max;
}

// Int32Rules describes the rules applied to `int32` values. These
// rules may also be applied to the `google.protobuf.Int32Value` Well-Known-Type.
message Int32Rules {
  // `const` requires the field value to exactly match the specified value. If
  // the field value doesn't match, an error message is generated.
  //
  // ```proto
  // message MyInt32 {
  //   // value must equal 42
  //   int32 value = 1 [(buf.validate.field).int32.const = 42];
  // }
  // ```
  optional int32 const = 1 [(predefined).cel = {
    id: "int32.const"
    expression: "this != getField(rules, 'const') ? 'value must equal %s'.format([getField(rules, 'const')]) : ''"
  }];
  oneof less_than {
    // `lt` requires the field value to be less than the specified value (field
    // < value). If the field value is equal to or greater than the specified
    // value, an error message is generated.
    //
    // ```proto
    // message MyInt32 {
    //   // value must be less than 10
    //   int32 value = 1 [(buf.validate.field).int32.lt = 10];
    // }
    // ```
    int32 lt = 2 [(predefined).cel = {
      id: "int32.lt"
      expression:
        "!has(rules.gte) && !has(rules.gt) && this >= rules.lt"
        "? 'value must be less than %s'.format([rules.lt]) : ''"
    }];

    // `lte` requires the field value to be less than or equal to the specified
    // value (field <= value). If the field value is greater than the specified
    // value, an error message is generated.
    //
    // ```proto
    // message MyInt32 {
    //   // value must be less than or equal to 10
    //   int32 value = 1 [(buf.validate.field).int32.lte = 10];
    // }
    // ```
    int32 lte = 3 [(predefined).cel = {
      id: "int32.lte"
      expression:
        "!has(rules.gte) && !has(rules.gt) && this > rules.lte"
        "? 'value must be less than or equal to %s'.format([rules.lte]) : ''"
    }];
  }
  oneof greater_than {
    // `gt` requires the field value to be greater than the specified value
    // (exclusive). If the value of `gt` is larger than a specified `lt` or
    // `lte`, the range is reversed, and the field value must be outside the
    // specified range. If the field value doesn't meet the required conditions,
    // an error message is generated.
    //
    // ```proto
    // message MyInt32 {
    //   // value must be greater than 5 [int32.gt]
    //   int32 value = 1 [(buf.validate.field).int32.gt = 5];
    //
    //   // value must be greater than 5 and less than 10 [int32.gt_lt]
    //   int32 other_value = 2 [(buf.validate.field).int32 = { gt: 5, lt: 10 }];
    //
    //   // value must be greater than 10 or less than 5 [int32.gt_lt_exclusive]
    //   int32 another_value = 3 [(buf.validate.field).int32 = { gt: 10, lt: 5 }];
    // }
    // ```
    int32 gt = 4 [
      (predefined).cel = {
        id: "int32.gt"
        expression:
          "!has(rules.lt) && !has(rules.lte) && this <= rules.gt"
          "? 'value must be greater than %s'.format([rules.gt]) : ''"
      },
      (predefined).cel = {
        id: "int32.gt_lt"
        expression:
          "has(rules.lt) && rules.lt >= rules.gt && (this >= rules.lt || this <= rules.gt)"
          "? 'value must be greater than %s and less than %s'.format([rules.gt, rules.lt]) : ''"
      },
      (predefined).cel = {
        id: "int32.gt_lt_exclusive"
        expression:
          "has(rules.lt) && rules.lt < rules.gt && (rules.lt <= this && this <= rules.gt)"
          "? 'value must be greater than %s or less than %s'.format([rules.gt, rules.lt]) : ''"
      },
      (predefined).cel = {
        id: "int32.gt_lte"
        expression:
          "has(rules.lte) && rules.lte >= rules.gt && (this > rules.lte || this <= rules.gt)"
          "? 'value must be greater than %s and less than or equal to %s'.format([rules.gt, rules.lte]) : ''"
      },
      (predefined).cel = {
        id: "int32.gt_lte_exclusive"
        expression:
          "has(rules.lte) && rules.lte < rules.gt && (rules.lte < this && this <= rules.gt)"
          "? 'value must be greater than %s or less than or equal to %s'.format([rules.gt, rules.lte]) : ''"
      }
    ];

    // `gte` requires the field value to be greater than or equal to the specified value
    // (exclusive). If the value of `gte` is larger than a specified `lt` or
    // `lte`, the range is reversed, and the field value must be outside the
    // specified range. If the field value doesn't meet the required conditions,
    // an error message is generated.
    //
    // ```proto
    // message MyInt32 {
    //   // value must be greater than or equal to 5 [int32.gte]
    //   int32 value = 1 [(buf.validate.field).int32.gte = 5];
    //
    //   // value must be greater than or equal to 5 and less than 10 [int32.gte_lt]
    //   int32 other_value = 2 [(buf.validate.field).int32 = { gte: 5, lt: 10 }];
    //
    //   // value must be greater than or equal to 10 or less than 5 [int32.gte_lt_exclusive]
    //   int32 another_value = 3 [(buf.validate.field).int32 = { gte: 10, lt: 5 }];
    // }
    // ```
    int32 gte = 5 [
      (predefined).cel = {
        id: "int32.gte"
        expression:
          "!has(rules.lt) && !has(rules.lte) && this < rules.gte"
          "? 'value must be greater than or equal to %s'.format([rules.gte]) : ''"
      },
      (predefined).cel = {
        id: "int32.gte_lt"
        expression:
          "has(rules.lt) && rules.lt >= rules.gte && (this >= rules.lt || this < rules.gte)"
          "? 'value must be greater than or equal to %s and less than %s'.format([rules.gte, rules.lt]) : ''"
      },
      (predefined).cel = {
        id: "int32.gte_lt_exclusive"
        expression:
          "has(rules.lt) && rules.lt < rules.gte && (rules.lt <= this && this < rules.gte)"
          "? 'value must be greater than or equal to %s or less than %s'.format([rules.gte, rules.lt]) : ''"
      },
      (predefined).cel = {
        id: "int32.gte_lte"
        expression:
          "has(rules.lte) && rules.lte >= rules.gte && (this > rules.lte || this < rules.gte)"
          "? 'value must be greater than or equal to %s and less than or equal to %s'.format([rules.gte, rules.lte]) : ''"
      },
      (predefined).cel = {
        id: "int32.gte_lte_exclusive"
        expression:
          "has(rules.lte) && rules.lte < rules.gte && (rules.lte < this && this < rules.gte)"
          "? 'value must be greater than or equal to %s or less than or equal to %s'.format([rules.gte, rules.lte]) : ''"
      }
    ];
  }

  // `in` requires the field value to be equal to one of the specified values.
  // If the field value isn't one of the specified values, an error message is
  // generated.
  //
  // ```proto
  // message MyInt32 {
  //   // value must be in list [1, 2, 3]
  //   int32 value = 1 [(buf.validate.field).int32 = { in: [1, 2, 3] }];
  // }
  // ```
  repeated int32 in = 6 [(predefined).cel = {
    id: "int32.in"
    expression: "!(this in getField(rules, 'in')) ? 'value must be in list %s'.format([getField(rules, 'in')]) : ''"
  }];

  // `not_in` requires the field value to not be equal to any of the specified
  // values. If the field value is one of the specified values, an error message
  // is generated.
  //
  // ```proto
  // message MyInt32 {
  //   // value must not be in list [1, 2, 3]
  //   int32 value = 1 [(buf.validate.field).int32 = { not_in: [1, 2, 3] }];
  // }
  // ```
  repeated int32 not_in = 7 [(predefined).cel = {
    id: "int32.not_in"
    expression: "this in rules.not_in ? 'value must not be in list %s'.format([rules.not_in]) : ''"
  }];

  // `example` specifies values that the field may have. These values SHOULD
  // conform to other rules. `example` values will not impact validation
  // but may be used as helpful guidance on how to populate the given field.
  //
  // ```proto
  // message MyInt32 {
  //   int32 value = 1 [
  //     (buf.validate.field).int32.example = 1,
  //     (buf.validate.field).int32.example = -10
  //   ];
  // }
  // ```
  repeated int32 example = 8 [(predefined).cel = {
    id: "int32.example"
    expression: "true"
  }];

  // Extension fields in this range that have the (buf.validate.predefined)
  // option set will be treated as predefined field rules that can then be
  // set on the field options of other fields to apply field rules.
  // Extension numbers 1000 to 99999 are reserved for extension numbers that are
  // defined in the [Protobuf Global Extension Registry][1]. Extension numbers
  // above this range are reserved for extension numbers that are not explicitly
  // assigned. For rules defined in publicly-consumed schemas, use of extensions
  // above 99999 is discouraged due to the risk of conflicts.
  //
  // [1]: https://github.com/protocolbuffers/protobuf/blob/main/docs/options.md
  extensions 1000 to max;
}

// Int64Rules describes the rules applied to `int64` values. These
// rules may also be applied to the `google.protobuf.Int64Value` Well-Known-Type.
message Int64Rules {
  // `const` requires the field value to exactly match the specified value. If
  // the field value doesn't match, an error message is generated.
  //
  // ```proto
  // message MyInt64 {
  //   // value must equal 42
  //   int64 value = 1 [(buf.validate.field).int64.const = 42];
  // }
  // ```
  optional int64 const = 1 [(predefined).cel = {
    id: "int64.const"
    expression: "this != getField(rules, 'const') ? 'value must equal %s'.format([getField(rules, 'const')]) : ''"
  }];
  oneof less_than {
    // `lt` requires the field value to be less than the specified value (field <
    // value). If the field value is equal to or greater than the specified value,
    // an error message is generated.
    //
    // ```proto
    // message MyInt64 {
    //   // value must be less than 10
    //   int64 value = 1 [(buf.validate.field).int64.lt = 10];
    // }
    // ```
    int64 lt = 2 [(predefined).cel = {
      id: "int64.lt"
      expression:
        "!has(rules.gte) && !has(rules.gt) && this >= rules.lt"
        "? 'value must be less than %s'.format([rules.lt]) : ''"
    }];

    // `lte` requires the field value to be less than or equal to the specified
    // value (field <= value). If the field value is greater than the specified
    // value, an error message is generated.
    //
    // ```proto
    // message MyInt64 {
    //   // value must be less than or equal to 10
    //   int64 value = 1 [(buf.validate.field).int64.lte = 10];
    // }
    // ```
    int64 lte = 3 [(predefined).cel = {
      id: "int64.lte"
      expression:
        "!has(rules.gte) && !has(rules.gt) && this > rules.lte"
        "? 'value must be less than or equal to %s'.format([rules.lte]) : ''"
    }];
  }
  oneof greater_than {
    // `gt` requires the field value to be greater than the specified value
    // (exclusive). If the value of `gt` is larger than a specified `lt` or
    // `lte`, the range is reversed, and the field value must be outside the
    // specified range. If the field value doesn't meet the required conditions,
    // an error message is generated.
    //
    // ```proto
    // message MyInt64 {
    //   // value must be greater than 5 [int64.gt]
    //   int64 value = 1 [(buf.validate.field).int64.gt = 5];
    //
    //   // value must be greater than 5 and less than 10 [int64.gt_lt]
    //   int64 other_value = 2 [(buf.validate.field).int64 = { gt: 5, lt: 10 }];
    //
    //   // value must be greater than 10 or less than 5 [int64.gt_lt_exclusive]
    //   int64 another_value = 3 [(buf.validate.field).int64 = { gt: 10, lt: 5 }];
    // }
    // ```
    int64 gt = 4 [
      (predefined).cel = {
        id: "int64.gt"
        expression:
          "!has(rules.lt) && !has(rules.lte) && this <= rules.gt"
          "? 'value must be greater than %s'.format([rules.gt]) : ''"
      },
      (predefined).cel = {
        id: "int64.gt_lt"
        expression:
          "has(rules.lt) && rules.lt >= rules.gt && (this >= rules.lt || this <= rules.gt)"
          "? 'value must be greater than %s and less than %s'.format([rules.gt, rules.lt]) : ''"
      },
      (predefined).cel = {
        id: "int64.gt_lt_exclusive"
        expression:
          "has(rules.lt) && rules.lt < rules.gt && (rules.lt <= this && this <= rules.gt)"
          "? 'value must be greater than %s or less than %s'.format([rules.gt, rules.lt]) : ''"
      },
      (predefined).cel = {
        id: "int64.gt_lte"
        expression:
          "has(rules.lte) && rules.lte >= rules.gt && (this > rules.lte || this <= rules.gt)"
          "? 'value must be greater than %s and less than or equal to %s'.format([rules.gt, rules.lte]) : ''"
      },
      (predefined).cel = {
        id: "int64.gt_lte_exclusive"
        expression:
          "has(rules.lte) && rules.lte < rules.gt && (rules.lte < this && this <= rules.gt)"
          "? 'value must be greater than %s or less than or equal to %s'.format([rules.gt, rules.lte]) : ''"
      }
    ];

    // `gte` requires the field value to be greater than or equal to the specified
    // value (exclusive). If the value of `gte` is larger than a specified `lt`
    // or `lte`, the range is reversed, and the field value must be outside the
    // specified range. If the field value doesn't meet the required conditions,
    // an error message is generated.
    //
    // ```proto
    // message MyInt64 {
    //   // value must be greater than or equal to 5 [int64.gte]
    //   int64 value = 1 [(buf.validate.field).int64.gte = 5];
    //
    //   // value must be greater than or equal to 5 and less than 10 [int64.gte_lt]
    //   int64 other_value = 2 [(buf.validate.field).int64 = { gte: 5, lt: 10 }];
    //
    //   // value must be greater than or equal to 10 or less than 5 [int64.gte_lt_exclusive]
    //   int64 another_value = 3 [(buf.validate.field).int64 = { gte: 10, lt: 5 }];
    // }
    // ```
    int64 gte = 5 [
      (predefined).cel = {
        id: "int64.gte"
        expression:
          "!has(rules.lt) && !has(rules.lte) && this < rules.gte"
          "? 'value must be greater than or equal to %s'.format([rules.gte]) : ''"
      },
      (predefined).cel = {
        id: "int64.gte_lt"
        expression:
          "has(rules.lt) && rules.lt >= rules.gte && (this >= rules.lt || this < rules.gte)"
          "? 'value must be greater than or equal to %s and less than %s'.format([rules.gte, rules.lt]) : ''"
      },
      (predefined).cel = {
        id: "int64.gte_lt_exclusive"
        expression:
          "has(rules.lt) && rules.lt < rules.gte && (rules.lt <= this && this < rules.gte)"
          "? 'value must be greater than or equal to %s or less than %s'.format([rules.gte, rules.lt]) : ''"
      },
      (predefined).cel = {
        id: "int64.gte_lte"
        expression:
          "has(rules.lte) && rules.lte >= rules.gte && (this > rules.lte || this < rules.gte)"
          "? 'value must be greater than or equal to %s and less than or equal to %s'.format([rules.gte, rules.lte]) : ''"
      },
      (predefined).cel = {
        id: "int64.gte_lte_exclusive"
        expression:
          "has(rules.lte) && rules.lte < rules.gte && (rules.lte < this && this < rules.gte)"
          "? 'value must be greater than or equal to %s or less than or equal to %s'.format([rules.gte, rules.lte]) : ''"
      }
    ];
  }

  // `in` requires the field value to be equal to one of the specified values.
  // If the field value isn't one of the specified values, an error message is
  // generated.
  //
  // ```proto
  // message MyInt64 {
  //   // value must be in list [1, 2, 3]
  //   int64 value = 1 [(buf.validate.field).int64 = { in: [1, 2, 3] }];
  // }
  // ```
  repeated int64 in = 6 [(predefined).cel = {
    id: "int64.in"
    expression: "!(this in getField(rules, 'in')) ? 'value must be in list %s'.format([getField(rules, 'in')]) : ''"
  }];

  // `not_in` requires the field value to not be equal to any of the specified
  // values. If the field value is one of the specified values, an error
  // message is generated.
  //
  // ```proto
  // message MyInt64 {
  //   // value must not be in list [1, 2, 3]
  //   int64 value = 1 [(buf.validate.field).int64 = { not_in: [1, 2, 3] }];
  // }
  // ```
  repeated int64 not_in = 7 [(predefined).cel = {
    id: "int64.not_in"
    expression: "this in rules.not_in ? 'value must not be in list %s'.format([rules.not_in]) : ''"
  }];

  // `example` specifies values that the field may have. These values SHOULD
  // conform to other rules. `example` values will not impact validation
  // but may be used as helpful guidance on how to populate the given field.
  //
  // ```proto
  // message MyInt64 {
  //   int64 value = 1 [
  //     (buf.validate.field).int64.example = 1,
  //     (buf.validate.field).int64.example = -10
  //   ];
  // }
  // ```
  repeated int64 example = 9 [(predefined).cel = {
    id: "int64.example"
    expression: "true"
  }];

  // Extension fields in this range that have the (buf.validate.predefined)
  // option set will be treated as predefined field rules that can then be
  // set on the field options of other fields to apply field rules.
  // Extension numbers 1000 to 99999 are reserved for extension numbers that are
  // defined in the [Protobuf Global Extension Registry][1]. Extension numbers
  // above this range are reserved for extension numbers that are not explicitly
  // assigned. For rules defined in publicly-consumed schemas, use of extensions
  // above 99999 is discouraged due to the risk of conflicts.
  //
  // [1]: https://github.com/protocolbuffers/protobuf/blob/main/docs/options.md
  extensions 1000 to max;
}

// UInt32Rules describes the rules applied to `uint32` values. These
// rules may also be applied to the `google.protobuf.UInt32Value` Well-Known-Type.
message UInt32Rules {
  // `const` requires the field value to exactly match the specified value. If
  // the field value doesn't match, an error message is generated.
  //
  // ```proto
  // message MyUInt32 {
  //   // value must equal 42
  //   uint32 value = 1 [(buf.validate.field).uint32.const = 42];
  // }
  // ```
  optional uint32 const = 1 [(predefined).cel = {
    id: "uint32.const"
    expression: "this != getField(rules, 'const') ? 'value must equal %s'.format([getField(rules, 'const')]) : ''"
  }];
  oneof less_than {
    // `lt` requires the field value to be less than the specified value (field <
    // value). If the field value is equal to or greater than the specified value,
    // an error message is generated.
    //
    // ```proto
    // message MyUInt32 {
    //   // value must be less than 10
    //   uint32 value = 1 [(buf.validate.field).uint32.lt = 10];
    // }
    // ```
    uint32 lt = 2 [(predefined).cel = {
      id: "uint32.lt"
      expression:
        "!has(rules.gte) && !has(rules.gt) && this >= rules.lt"
        "? 'value must be less than %s'.format([rules.lt]) : ''"
    }];

    // `lte` requires the field value to be less than or equal to the specified
    // value (field <= value). If the field value is greater than the specified
    // value, an error message is generated.
    //
    // ```proto
    // message MyUInt32 {
    //   // value must be less than or equal to 10
    //   uint32 value = 1 [(buf.validate.field).uint32.lte = 10];
    // }
    // ```
    uint32 lte = 3 [(predefined).cel = {
      id: "uint32.lte"
      expression:
        "!has(rules.gte) && !has(rules.gt) && this > rules.lte"
        "? 'value must be less than or equal to %s'.format([rules.lte]) : ''"
    }];
  }
  oneof greater_than {
    // `gt` requires the field value to be greater than the specified value
    // (exclusive). If the value of `gt` is larger than a specified `lt` or
    // `lte`, the range is reversed, and the field value must be outside the
    // specified range. If the field value doesn't meet the required conditions,
    // an error message is generated.
    //
    // ```proto
    // message MyUInt32 {
    //   // value must be greater than 5 [uint32.gt]
    //   uint32 value = 1 [(buf.validate.field).uint32.gt = 5];
    //
    //   // value must be greater than 5 and less than 10 [uint32.gt_lt]
    //   uint32 other_value = 2 [(buf.validate.field).uint32 = { gt: 5, lt: 10 }];
    //
    //   // value must be greater than 10 or less than 5 [uint32.gt_lt_exclusive]
    //   uint32 another_value = 3 [(buf.validate.field).uint32 = { gt: 10, lt: 5 }];
    // }
    // ```
    uint32 gt = 4 [
      (predefined).cel = {
        id: "uint32.gt"
        expression:
          "!has(rules.lt) && !has(rules.lte) && this <= rules.gt"
          "? 'value must be greater than %s'.format([rules.gt]) : ''"
      },
      (predefined).cel = {
        id: "uint32.gt_lt"
        expression:
          "has(rules.lt) && rules.lt >= rules.gt && (this >= rules.lt || this <= rules.gt)"
          "? 'value must be greater than %s and less than %s'.format([rules.gt, rules.lt]) : ''"
      },
      (predefined).cel = {
        id: "uint32.gt_lt_exclusive"
        expression:
          "has(rules.lt) && rules.lt < rules.gt && (rules.lt <= this && this <= rules.gt)"
          "? 'value must be greater than %s or less than %s'.format([rules.gt, rules.lt]) : ''"
      },
      (predefined).cel = {
        id: "uint32.gt_lte"
        expression:
          "has(rules.lte) && rules.lte >= rules.gt && (this > rules.lte || this <= rules.gt)"
          "? 'value must be greater than %s and less than or equal to %s'.format([rules.gt, rules.lte]) : ''"
      },
      (predefined).cel = {
        id: "uint32.gt_lte_exclusive"
        expression:
          "has(rules.lte) && rules.lte < rules.gt && (rules.lte < this && this <= rules.gt)"
          "? 'value must be greater than %s or less than or equal to %s'.format([rules.gt, rules.lte]) : ''"
      }
    ];

    // `gte` requires the field value to be greater than or equal to the specified
    // value (exclusive). If the value of `gte` is larger than a specified `lt`
    // or `lte`, the range is reversed, and the field value must be outside the
    // specified range. If the field value doesn't meet the required conditions,
    // an error message is generated.
    //
    // ```proto
    // message MyUInt32 {
    //   // value must be greater than or equal to 5 [uint32.gte]
    //   uint32 value = 1 [(buf.validate.field).uint32.gte = 5];
    //
    //   // value must be greater than or equal to 5 and less than 10 [uint32.gte_lt]
    //   uint32 other_value = 2 [(buf.validate.field).uint32 = { gte: 5, lt: 10 }];
    //
    //   // value must be greater than or equal to 10 or less than 5 [uint32.gte_lt_exclusive]
    //   uint32 another_value = 3 [(buf.validate.field).uint32 = { gte: 10, lt: 5 }];
    // }
    // ```
    uint32 gte = 5 [
      (predefined).cel = {
        id: "uint32.gte"
        expression:
          "!has(rules.lt) && !has(rules.lte) && this < rules.gte"
          "? 'value must be greater than or equal to %s'.format([rules.gte]) : ''"
      },
      (predefined).cel = {
        id: "uint32.gte_lt"
        expression:
          "has(rules.lt) && rules.lt >= rules.gte && (this >= rules.lt || this < rules.gte)"
          "? 'value must be greater than or equal to %s and less than %s'.format([rules.gte, rules.lt]) : ''"
      },
      (predefined).cel = {
        id: "uint32.gte_lt_exclusive"
        expression:
          "has(rules.lt) && rules.lt < rules.gte && (rules.lt <= this && this < rules.gte)"
          "? 'value must be greater than or equal to %s or less than %s'.format([rules.gte, rules.lt]) : ''"
      },
      (predefined).cel = {
        id: "uint32.gte_lte"
        expression:
          "has(rules.lte) && rules.lte >= rules.gte && (this > rules.lte || this < rules.gte)"
          "? 'value must be greater than or equal to %s and less than or equal to %s'.format([rules.gte, rules.lte]) : ''"
      },
      (predefined).cel = {
        id: "uint32.gte_lte_exclusive"
        expression:
          "has(rules.lte) && rules.lte < rules.gte && (rules.lte < this && this < rules.gte)"
          "? 'value must be greater than or equal to %s or less than or equal to %s'.format([rules.gte, rules.lte]) : ''"
      }
    ];
  }

  // `in` requires the field value to be equal to one of the specified values.
  // If the field value isn't one of the specified values, an error message is
  // generated.
  //
  // ```proto
  // message MyUInt32 {
  //   // value must be in list [1, 2, 3]
  //   uint32 value = 1 [(buf.validate.field).uint32 = { in: [1, 2, 3] }];
  // }
  // ```
  repeated uint32 in = 6 [(predefined).cel = {
    id: "uint32.in"
    expression: "!(this in getField(rules, 'in')) ? 'value must be in list %s'.format([getField(rules, 'in')]) : ''"
  }];

  // `not_in` requires the field value to not be equal to any of the specified
  // values. If the field value is one of the specified values, an error
  // message is generated.
  //
  // ```proto
  // message MyUInt32 {
  //   // value must not be in list [1, 2, 3]
  //   uint32 value = 1 [(buf.validate.field).uint32 = { not_in: [1, 2, 3] }];
  // }
  // ```
  repeated uint32 not_in = 7 [(predefined).cel = {
    id: "uint32.not_in"
    expression: "this in rules.not_in ? 'value must not be in list %s'.format([rules.not_in]) : ''"
  }];

  // `example` specifies values that the field may have. These values SHOULD
  // conform to other rules. `example` values will not impact validation
  // but may be used as helpful guidance on how to populate the given field.
  //
  // ```proto
  // message MyUInt32 {
  //   uint32 value = 1 [
  //     (buf.validate.field).uint32.example = 1,
  //     (buf.validate.field).uint32.example = 10
  //   ];
  // }
  // ```
  repeated uint32 example = 8 [(predefined).cel = {
    id: "uint32.example"
    expression: "true"
  }];

  // Extension fields in this range that have the (buf.validate.predefined)
  // option set will be treated as predefined field rules that can then be
  // set on the field options of other fields to apply field rules.
  // Extension numbers 1000 to 99999 are reserved for extension numbers that are
  // defined in the [Protobuf Global Extension Registry][1]. Extension numbers
  // above this range are reserved for extension numbers that are not explicitly
  // assigned. For rules defined in publicly-consumed schemas, use of extensions
  // above 99999 is discouraged due to the risk of conflicts.
  //
  // [1]: https://github.com/protocolbuffers/protobuf/blob/main/docs/options.md
  extensions 1000 to max;
}

// UInt64Rules describes the rules applied to `uint64` values. These
// rules may also be applied to the `google.protobuf.UInt64Value` Well-Known-Type.
message UInt64Rules {
  // `const` requires the field value to exactly match the specified value. If
  // the field value doesn't match, an error message is generated.
  //
  // ```proto
  // message MyUInt64 {
  //   // value must equal 42
  //   uint64 value = 1 [(buf.validate.field).uint64.const = 42];
  // }
  // ```
  optional uint64 const = 1 [(predefined).cel = {
    id: "uint64.const"
    expression: "this != getField(rules, 'const') ? 'value must equal %s'.format([getField(rules, 'const')]) : ''"
  }];
  oneof less_than {
    // `lt` requires the field value to be less than the specified value (field <
    // value). If the field value is equal to or greater than the specified value,
    // an error message is generated.
    //
    // ```proto
    // message MyUInt64 {
    //   // value must be less than 10
    //   uint64 value = 1 [(buf.validate.field).uint64.lt = 10];
    // }
    // ```
    uint64 lt = 2 [(predefined).cel = {
      id: "uint64.lt"
      expression:
        "!has(rules.gte) && !has(rules.gt) && this >= rules.lt"
        "? 'value must be less than %s'.format([rules.lt]) : ''"
    }];

    // `lte` requires the field value to be less than or equal to the specified
    // value (field <= value). If the field value is greater than the specified
    // value, an error message is generated.
    //
    // ```proto
    // message MyUInt64 {
    //   // value must be less than or equal to 10
    //   uint64 value = 1 [(buf.validate.field).uint64.lte = 10];
    // }
    // ```
    uint64 lte = 3 [(predefined).cel = {
      id: "uint64.lte"
      expression:
        "!has(rules.gte) && !has(rules.gt) && this > rules.lte"
        "? 'value must be less than or equal to %s'.format([rules.lte]) : ''"
    }];
  }
  oneof greater_than {
    // `gt` requires the field value to be greater than the specified value
    // (exclusive). If the value of `gt` is larger than a specified `lt` or
    // `lte`, the range is reversed, and the field value must be outside the
    // specified range. If the field value doesn't meet the required conditions,
    // an error message is generated.
    //
    // ```proto
    // message MyUInt64 {
    //   // value must be greater than 5 [uint64.gt]
    //   uint64 value = 1 [(buf.validate.field).uint64.gt = 5];
    //
    //   // value must be greater than 5 and less than 10 [uint64.gt_lt]
    //   uint64 other_value = 2 [(buf.validate.field).uint64 = { gt: 5, lt: 10 }];
    //
    //   // value must be greater than 10 or less than 5 [uint64.gt_lt_exclusive]
    //   uint64 another_value = 3 [(buf.validate.field).uint64 = { gt: 10, lt: 5 }];
    // }
    // ```
    uint64 gt = 4 [
      (predefined).cel = {
        id: "uint64.gt"
        expression:
          "!has(rules.lt) && !has(rules.lte) && this <= rules.gt"
          "? 'value must be greater than %s'.format([rules.gt]) : ''"
      },
      (predefined).cel = {
        id: "uint64.gt_lt"
        expression:
          "has(rules.lt) && rules.lt >= rules.gt && (this >= rules.lt || this <= rules.gt)"
          "? 'value must be greater than %s and less than %s'.format([rules.gt, rules.lt]) : ''"
      },
      (predefined).cel = {
        id: "uint64.gt_lt_exclusive"
        expression:
          "has(rules.lt) && rules.lt < rules.gt && (rules.lt <= this && this <= rules.gt)"
          "? 'value must be greater than %s or less than %s'.format([rules.gt, rules.lt]) : ''"
      },
      (predefined).cel = {
        id: "uint64.gt_lte"
        expression:
          "has(rules.lte) && rules.lte >= rules.gt && (this > rules.lte || this <= rules.gt)"
          "? 'value must be greater than %s and less than or equal to %s'.format([rules.gt, rules.lte]) : ''"
      },
      (predefined).cel = {
        id: "uint64.gt_lte_exclusive"
        expression:
          "has(rules.lte) && rules.lte < rules.gt && (rules.lte < this && this <= rules.gt)"
          "? 'value must be greater than %s or less than or equal to %s'.format([rules.gt, rules.lte]) : ''"
      }
    ];

    // `gte` requires the field value to be greater than or equal to the specified
    // value (exclusive). If the value of `gte` is larger than a specified `lt`
    // or `lte`, the range is reversed, and the field value must be outside the
    // specified range. If the field value doesn't meet the required conditions,
    // an error message is generated.
    //
    // ```proto
    // message MyUInt64 {
    //   // value must be greater than or equal to 5 [uint64.gte]
    //   uint64 value = 1 [(buf.validate.field).uint64.gte = 5];
    //
    //   // value must be greater than or equal to 5 and less than 10 [uint64.gte_lt]
    //   uint64 other_value = 2 [(buf.validate.field).uint64 = { gte: 5, lt: 10 }];
    //
    //   // value must be greater than or equal to 10 or less than 5 [uint64.gte_lt_exclusive]
    //   uint64 another_value = 3 [(buf.validate.field).uint64 = { gte: 10, lt: 5 }];
    // }
    // ```
    uint64 gte = 5 [
      (predefined).cel = {
        id: "uint64.gte"
        expression:
          "!has(rules.lt) && !has(rules.lte) && this < rules.gte"
          "? 'value must be greater than or equal to %s'.format([rules.gte]) : ''"
      },
      (predefined).cel = {
        id: "uint64.gte_lt"
        expression:
          "has(rules.lt) && rules.lt >= rules.gte && (this >= rules.lt || this < rules.gte)"
          "? 'value must be greater than or equal to %s and less than %s'.format([rules.gte, rules.lt]) : ''"
      },
      (predefined).cel = {
        id: "uint64.gte_lt_exclusive"
        expression:
          "has(rules.lt) && rules.lt < rules.gte && (rules.lt <= this && this < rules.gte)"
          "? 'value must be greater than or equal to %s or less than %s'.format([rules.gte, rules.lt]) : ''"
      },
      (predefined).cel = {
        id: "uint64.gte_lte"
        expression:
          "has(rules.lte) && rules.lte >= rules.gte && (this > rules.lte || this < rules.gte)"
          "? 'value must be greater than or equal to %s and less than or equal to %s'.format([rules.gte, rules.lte]) : ''"
      },
      (predefined).cel = {
        id: "uint64.gte_lte_exclusive"
        expression:
          "has(rules.lte) && rules.lte < rules.gte && (rules.lte < this && this < rules.gte)"
          "? 'value must be greater than or equal to %s or less than or equal to %s'.format([rules.gte, rules.lte]) : ''"
      }
    ];
  }
  // `in` requires the field value to be equal to one of the specified values.
  // If the field value isn't one of the specified values, an error message is
  // generated.
  //
  // ```proto
  // message MyUInt64 {
  //   // value must be in list [1, 2, 3]
  //   uint64 value = 1 [(buf.validate.field).uint64 = { in: [1, 2, 3] }];
  // }
  // ```
  repeated uint64 in = 6 [(predefined).cel = {
    id: "uint64.in"
    expression: "!(this in getField(rules, 'in')) ? 'value must be in list %s'.format([getField(rules, 'in')]) : ''"
  }];

  // `not_in` requires the field value to not be equal to any of the specified
  // values. If the field value is one of the specified values, an error
  // message is generated.
  //
  // ```proto
  // message MyUInt64 {
  //   // value must not be in list [1, 2, 3]
  //   uint64 value = 1 [(buf.validate.field).uint64 = { not_in: [1, 2, 3] }];
  // }
  // ```
  repeated uint64 not_in = 7 [(predefined).cel = {
    id: "uint64.not_in"
    expression: "this in rules.not_in ? 'value must not be in list %s'.format([rules.not_in]) : ''"
  }];

  // `example` specifies values that the field may have. These values SHOULD
  // conform to other rules. `example` values will not impact validation
  // but may be used as helpful guidance on how to populate the given field.
  //
  // ```proto
  // message MyUInt64 {
  //   uint64 value = 1 [
  //     (buf.validate.field).uint64.example = 1,
  //     (buf.validate.field).uint64.example = -10
  //   ];
  // }
  // ```
  repeated uint64 example = 8 [(predefined).cel = {
    id: "uint64.example"
    expression: "true"
  }];

  // Extension fields in this range that have the (buf.validate.predefined)
  // option set will be treated as predefined field rules that can then be
  // set on the field options of other fields to apply field rules.
  // Extension numbers 1000 to 99999 are reserved for extension numbers that are
  // defined in the [Protobuf Global Extension Registry][1]. Extension numbers
  // above this range are reserved for extension numbers that are not explicitly
  // assigned. For rules defined in publicly-consumed schemas, use of extensions
  // above 99999 is discouraged due to the risk of conflicts.
  //
  // [1]: https://github.com/protocolbuffers/protobuf/blob/main/docs/options.md
  extensions 1000 to max;
}

// SInt32Rules describes the rules applied to `sint32` values.
message SInt32Rules {
  // `const` requires the field value to exactly match the specified value. If
  // the field value doesn't match, an error message is generated.
  //
  // ```proto
  // message MySInt32 {
  //   // value must equal 42
  //   sint32 value = 1 [(buf.validate.field).sint32.const = 42];
  // }
  // ```
  optional sint32 const = 1 [(predefined).cel = {
    id: "sint32.const"
    expression: "this != getField(rules, 'const') ? 'value must equal %s'.format([getField(rules, 'const')]) : ''"
  }];
  oneof less_than {
    // `lt` requires the field value to be less than the specified value (field
    // < value). If the field value is equal to or greater than the specified
    // value, an error message is generated.
    //
    // ```proto
    // message MySInt32 {
    //   // value must be less than 10
    //   sint32 value = 1 [(buf.validate.field).sint32.lt = 10];
    // }
    // ```
    sint32 lt = 2 [(predefined).cel = {
      id: "sint32.lt"
      expression:
        "!has(rules.gte) && !has(rules.gt) && this >= rules.lt"
        "? 'value must be less than %s'.format([rules.lt]) : ''"
    }];

    // `lte` requires the field value to be less than or equal to the specified
    // value (field <= value). If the field value is greater than the specified
    // value, an error message is generated.
    //
    // ```proto
    // message MySInt32 {
    //   // value must be less than or equal to 10
    //   sint32 value = 1 [(buf.validate.field).sint32.lte = 10];
    // }
    // ```
    sint32 lte = 3 [(predefined).cel = {
      id: "sint32.lte"
      expression:
        "!has(rules.gte) && !has(rules.gt) && this > rules.lte"
        "? 'value must be less than or equal to %s'.format([rules.lte]) : ''"
    }];
  }
  oneof greater_than {
    // `gt` requires the field value to be greater than the specified value
    // (exclusive). If the value of `gt` is larger than a specified `lt` or
    // `lte`, the range is reversed, and the field value must be outside the
    // specified range. If the field value doesn't meet the required conditions,
    // an error message is generated.
    //
    // ```proto
    // message MySInt32 {
    //   // value must be greater than 5 [sint32.gt]
    //   sint32 value = 1 [(buf.validate.field).sint32.gt = 5];
    //
    //   // value must be greater than 5 and less than 10 [sint32.gt_lt]
    //   sint32 other_value = 2 [(buf.validate.field).sint32 = { gt: 5, lt: 10 }];
    //
    //   // value must be greater than 10 or less than 5 [sint32.gt_lt_exclusive]
    //   sint32 another_value = 3 [(buf.validate.field).sint32 = { gt: 10, lt: 5 }];
    // }
    // ```
    sint32 gt = 4 [
      (predefined).cel = {
        id: "sint32.gt"
        expression:
          "!has(rules.lt) && !has(rules.lte) && this <= rules.gt"
          "? 'value must be greater than %s'.format([rules.gt]) : ''"
      },
      (predefined).cel = {
        id: "sint32.gt_lt"
        expression:
          "has(rules.lt) && rules.lt >= rules.gt && (this >= rules.lt || this <= rules.gt)"
          "? 'value must be greater than %s and less than %s'.format([rules.gt, rules.lt]) : ''"
      },
      (predefined).cel = {
        id: "sint32.gt_lt_exclusive"
        expression:
          "has(rules.lt) && rules.lt < rules.gt && (rules.lt <= this && this <= rules.gt)"
          "? 'value must be greater than %s or less than %s'.format([rules.gt, rules.lt]) : ''"
      },
      (predefined).cel = {
        id: "sint32.gt_lte"
        expression:
          "has(rules.lte) && rules.lte >= rules.gt && (this > rules.lte || this <= rules.gt)"
          "? 'value must be greater than %s and less than or equal to %s'.format([rules.gt, rules.lte]) : ''"
      },
      (predefined).cel = {
        id: "sint32.gt_lte_exclusive"
        expression:
          "has(rules.lte) && rules.lte < rules.gt && (rules.lte < this && this <= rules.gt)"
          "? 'value must be greater than %s or less than or equal to %s'.format([rules.gt, rules.lte]) : ''"
      }
    ];

    // `gte` requires the field value to be greater than or equal to the specified
    // value (exclusive). If the value of `gte` is larger than a specified `lt`
    // or `lte`, the range is reversed, and the field value must be outside the
    // specified range. If the field value doesn't meet the required conditions,
    // an error message is generated.
    //
    // ```proto
    // message MySInt32 {
    //  // value must be greater than or equal to 5 [sint32.gte]
    //  sint32 value = 1 [(buf.validate.field).sint32.gte = 5];
    //
    //  // value must be greater than or equal to 5 and less than 10 [sint32.gte_lt]
    //  sint32 other_value = 2 [(buf.validate.field).sint32 = { gte: 5, lt: 10 }];
    //
    //  // value must be greater than or equal to 10 or less than 5 [sint32.gte_lt_exclusive]
    //  sint32 another_value = 3 [(buf.validate.field).sint32 = { gte: 10, lt: 5 }];
    // }
    // ```
    sint32 gte = 5 [
      (predefined).cel = {
        id: "sint32.gte"
        expression:
          "!has(rules.lt) && !has(rules.lte) && this < rules.gte"
          "? 'value must be greater than or equal to %s'.format([rules.gte]) : ''"
      },
      (predefined).cel = {
        id: "sint32.gte_lt"
        expression:
          "has(rules.lt) && rules.lt >= rules.gte && (this >= rules.lt || this < rules.gte)"
          "? 'value must be greater than or equal to %s and less than %s'.format([rules.gte, rules.lt]) : ''"
      },
      (predefined).cel = {
        id: "sint32.gte_lt_exclusive"
        expression:
          "has(rules.lt) && rules.lt < rules.gte && (rules.lt <= this && this < rules.gte)"
          "? 'value must be greater than or equal to %s or less than %s'.format([rules.gte, rules.lt]) : ''"
      },
      (predefined).cel = {
        id: "sint32.gte_lte"
        expression:
          "has(rules.lte) && rules.lte >= rules.gte && (this > rules.lte || this < rules.gte)"
          "? 'value must be greater than or equal to %s and less than or equal to %s'.format([rules.gte, rules.lte]) : ''"
      },
      (predefined).cel = {
        id: "sint32.gte_lte_exclusive"
        expression:
          "has(rules.lte) && rules.lte < rules.gte && (rules.lte < this && this < rules.gte)"
          "? 'value must be greater than or equal to %s or less than or equal to %s'.format([rules.gte, rules.lte]) : ''"
      }
    ];
  }

  // `in` requires the field value to be equal to one of the specified values.
  // If the field value isn't one of the specified values, an error message is
  // generated.
  //
  // ```proto
  // message MySInt32 {
  //   // value must be in list [1, 2, 3]
  //   sint32 value = 1 [(buf.validate.field).sint32 = { in: [1, 2, 3] }];
  // }
  // ```
  repeated sint32 in = 6 [(predefined).cel = {
    id: "sint32.in"
    expression: "!(this in getField(rules, 'in')) ? 'value must be in list %s'.format([getField(rules, 'in')]) : ''"
  }];

  // `not_in` requires the field value to not be equal to any of the specified
  // values. If the field value is one of the specified values, an error
  // message is generated.
  //
  // ```proto
  // message MySInt32 {
  //   // value must not be in list [1, 2, 3]
  //   sint32 value = 1 [(buf.validate.field).sint32 = { not_in: [1, 2, 3] }];
  // }
  // ```
  repeated sint32 not_in = 7 [(predefined).cel = {
    id: "sint32.not_in"
    expression: "this in rules.not_in ? 'value must not be in list %s'.format([rules.not_in]) : ''"
  }];

  // `example` specifies values that the field may have. These values SHOULD
  // conform to other rules. `example` values will not impact validation
  // but may be used as helpful guidance on how to populate the given field.
  //
  // ```proto
  // message MySInt32 {
  //   sint32 value = 1 [
  //     (buf.validate.field).sint32.example = 1,
  //     (buf.validate.field).sint32.example = -10
  //   ];
  // }
  // ```
  repeated sint32 example = 8 [(predefined).cel = {
    id: "sint32.example"
    expression: "true"
  }];

  // Extension fields in this range that have the (buf.validate.predefined)
  // option set will be treated as predefined field rules that can then be
  // set on the field options of other fields to apply field rules.
  // Extension numbers 1000 to 99999 are reserved for extension numbers that are
  // defined in the [Protobuf Global Extension Registry][1]. Extension numbers
  // above this range are reserved for extension numbers that are not explicitly
  // assigned. For rules defined in publicly-consumed schemas, use of extensions
  // above 99999 is discouraged due to the risk of conflicts.
  //
  // [1]: https://github.com/protocolbuffers/protobuf/blob/main/docs/options.md
  extensions 1000 to max;
}

// SInt64Rules describes the rules applied to `sint64` values.
message SInt64Rules {
  // `const` requires the field value to exactly match the specified value. If
  // the field value doesn't match, an error message is generated.
  //
  // ```proto
  // message MySInt64 {
  //   // value must equal 42
  //   sint64 value = 1 [(buf.validate.field).sint64.const = 42];
  // }
  // ```
  optional sint64 const = 1 [(predefined).cel = {
    id: "sint64.const"
    expression: "this != getField(rules, 'const') ? 'value must equal %s'.format([getField(rules, 'const')]) : ''"
  }];
  oneof less_than {
    // `lt` requires the field value to be less than the specified value (field
    // < value). If the field value is equal to or greater than the specified
    // value, an error message is generated.
    //
    // ```proto
    // message MySInt64 {
    //   // value must be less than 10
    //   sint64 value = 1 [(buf.validate.field).sint64.lt = 10];
    // }
    // ```
    sint64 lt = 2 [(predefined).cel = {
      id: "sint64.lt"
      expression:
        "!has(rules.gte) && !has(rules.gt) && this >= rules.lt"
        "? 'value must be less than %s'.format([rules.lt]) : ''"
    }];

    // `lte` requires the field value to be less than or equal to the specified
    // value (field <= value). If the field value is greater than the specified
    // value, an error message is generated.
    //
    // ```proto
    // message MySInt64 {
    //   // value must be less than or equal to 10
    //   sint64 value = 1 [(buf.validate.field).sint64.lte = 10];
    // }
    // ```
    sint64 lte = 3 [(predefined).cel = {
      id: "sint64.lte"
      expression:
        "!has(rules.gte) && !has(rules.gt) && this > rules.lte"
        "? 'value must be less than or equal to %s'.format([rules.lte]) : ''"
    }];
  }
  oneof greater_than {
    // `gt` requires the field value to be greater than the specified value
    // (exclusive). If the value of `gt` is larger than a specified `lt` or
    // `lte`, the range is reversed, and the field value must be outside the
    // specified range. If the field value doesn't meet the required conditions,
    // an error message is generated.
    //
    // ```proto
    // message MySInt64 {
    //   // value must be greater than 5 [sint64.gt]
    //   sint64 value = 1 [(buf.validate.field).sint64.gt = 5];
    //
    //   // value must be greater than 5 and less than 10 [sint64.gt_lt]
    //   sint64 other_value = 2 [(buf.validate.field).sint64 = { gt: 5, lt: 10 }];
    //
    //   // value must be greater than 10 or less than 5 [sint64.gt_lt_exclusive]
    //   sint64 another_value = 3 [(buf.validate.field).sint64 = { gt: 10, lt: 5 }];
    // }
    // ```
    sint64 gt = 4 [
      (predefined).cel = {
        id: "sint64.gt"
        expression:
          "!has(rules.lt) && !has(rules.lte) && this <= rules.gt"
          "? 'value must be greater than %s'.format([rules.gt]) : ''"
      },
      (predefined).cel = {
        id: "sint64.gt_lt"
        expression:
          "has(rules.lt) && rules.lt >= rules.gt && (this >= rules.lt || this <= rules.gt)"
          "? 'value must be greater than %s and less than %s'.format([rules.gt, rules.lt]) : ''"
      },
      (predefined).cel = {
        id: "sint64.gt_lt_exclusive"
        expression:
          "has(rules.lt) && rules.lt < rules.gt && (rules.lt <= this && this <= rules.gt)"
          "? 'value must be greater than %s or less than %s'.format([rules.gt, rules.lt]) : ''"
      },
      (predefined).cel = {
        id: "sint64.gt_lte"
        expression:
          "has(rules.lte) && rules.lte >= rules.gt && (this > rules.lte || this <= rules.gt)"
          "? 'value must be greater than %s and less than or equal to %s'.format([rules.gt, rules.lte]) : ''"
      },
      (predefined).cel = {
        id: "sint64.gt_lte_exclusive"
        expression:
          "has(rules.lte) && rules.lte < rules.gt && (rules.lte < this && this <= rules.gt)"
          "? 'value must be greater than %s or less than or equal to %s'.format([rules.gt, rules.lte]) : ''"
      }
    ];

    // `gte` requires the field value to be greater than or equal to the specified
    // value (exclusive). If the value of `gte` is larger than a specified `lt`
    // or `lte`, the range is reversed, and the field value must be outside the
    // specified range. If the field value doesn't meet the required conditions,
    // an error message is generated.
    //
    // ```proto
    // message MySInt64 {
    //   // value must be greater than or equal to 5 [sint64.gte]
    //   sint64 value = 1 [(buf.validate.field).sint64.gte = 5];
    //
    //   // value must be greater than or equal to 5 and less than 10 [sint64.gte_lt]
    //   sint64 other_value = 2 [(buf.validate.field).sint64 = { gte: 5, lt: 10 }];
    //
    //   // value must be greater than or equal to 10 or less than 5 [sint64.gte_lt_exclusive]
    //   sint64 another_value = 3 [(buf.validate.field).sint64 = { gte: 10, lt: 5 }];
    // }
    // ```
    sint64 gte = 5 [
      (predefined).cel = {
        id: "sint64.gte"
        expression:
          "!has(rules.lt) && !has(rules.lte) && this < rules.gte"
          "? 'value must be greater than or equal to %s'.format([rules.gte]) : ''"
      },
      (predefined).cel = {
        id: "sint64.gte_lt"
        expression:
          "has(rules.lt) && rules.lt >= rules.gte && (this >= rules.lt || this < rules.gte)"
          "? 'value must be greater than or equal to %s and less than %s'.format([rules.gte, rules.lt]) : ''"
      },
      (predefined).cel = {
        id: "sint64.gte_lt_exclusive"
        expression:
          "has(rules.lt) && rules.lt < rules.gte && (rules.lt <= this && this < rules.gte)"
          "? 'value must be greater than or equal to %s or less than %s'.format([rules.gte, rules.lt]) : ''"
      },
      (predefined).cel = {
        id: "sint64.gte_lte"
        expression:
          "has(rules.lte) && rules.lte >= rules.gte && (this > rules.lte || this < rules.gte)"
          "? 'value must be greater than or equal to %s and less than or equal to %s'.format([rules.gte, rules.lte]) : ''"
      },
      (predefined).cel = {
        id: "sint64.gte_lte_exclusive"
        expression:
          "has(rules.lte) && rules.lte < rules.gte && (rules.lte < this && this < rules.gte)"
          "? 'value must be greater than or equal to %s or less than or equal to %s'.format([rules.gte, rules.lte]) : ''"
      }
    ];
  }

  // `in` requires the field value to be equal to one of the specified values.
  // If the field value isn't one of the specified values, an error message
  // is generated.
  //
  // ```proto
  // message MySInt64 {
  //   // value must be in list [1, 2, 3]
  //   sint64 value = 1 [(buf.validate.field).sint64 = { in: [1, 2, 3] }];
  // }
  // ```
  repeated sint64 in = 6 [(predefined).cel = {
    id: "sint64.in"
    expression: "!(this in getField(rules, 'in')) ? 'value must be in list %s'.format([getField(rules, 'in')]) : ''"
  }];

  // `not_in` requires the field value to not be equal to any of the specified
  // values. If the field value is one of the specified values, an error
  // message is generated.
  //
  // ```proto
  // message MySInt64 {
  //   // value must not be in list [1, 2, 3]
  //   sint64 value = 1 [(buf.validate.field).sint64 = { not_in: [1, 2, 3] }];
  // }
  // ```
  repeated sint64 not_in = 7 [(predefined).cel = {
    id: "sint64.not_in"
    expression: "this in rules.not_in ? 'value must not be in list %s'.format([rules.not_in]) : ''"
  }];

  // `example` specifies values that the field may have. These values SHOULD
  // conform to other rules. `example` values will not impact validation
  // but may be used as helpful guidance on how to populate the given field.
  //
  // ```proto
  // message MySInt64 {
  //   sint64 value = 1 [
  //     (buf.validate.field).sint64.example = 1,
  //     (buf.validate.field).sint64.example = -10
  //   ];
  // }
  // ```
  repeated sint64 example = 8 [(predefined).cel = {
    id: "sint64.example"
    expression: "true"
  }];

  // Extension fields in this range that have the (buf.validate.predefined)
  // option set will be treated as predefined field rules that can then be
  // set on the field options of other fields to apply field rules.
  // Extension numbers 1000 to 99999 are reserved for extension numbers that are
  // defined in the [Protobuf Global Extension Registry][1]. Extension numbers
  // above this range are reserved for extension numbers that are not explicitly
  // assigned. For rules defined in publicly-consumed schemas, use of extensions
  // above 99999 is discouraged due to the risk of conflicts.
  //
  // [1]: https://github.com/protocolbuffers/protobuf/blob/main/docs/options.md
  extensions 1000 to max;
}

// Fixed32Rules describes the rules applied to `fixed32` values.
message Fixed32Rules {
  // `const` requires the field value to exactly match the specified value.
  // If the field value doesn't match, an error message is generated.
  //
  // ```proto
  // message MyFixed32 {
  //   // value must equal 42
  //   fixed32 value = 1 [(buf.validate.field).fixed32.const = 42];
  // }
  // ```
  optional fixed32 const = 1 [(predefined).cel = {
    id: "fixed32.const"
    expression: "this != getField(rules, 'const') ? 'value must equal %s'.format([getField(rules, 'const')]) : ''"
  }];
  oneof less_than {
    // `lt` requires the field value to be less than the specified value (field <
    // value). If the field value is equal to or greater than the specified value,
    // an error message is generated.
    //
    // ```proto
    // message MyFixed32 {
    //   // value must be less than 10
    //   fixed32 value = 1 [(buf.validate.field).fixed32.lt = 10];
    // }
    // ```
    fixed32 lt = 2 [(predefined).cel = {
      id: "fixed32.lt"
      expression:
        "!has(rules.gte) && !has(rules.gt) && this >= rules.lt"
        "? 'value must be less than %s'.format([rules.lt]) : ''"
    }];

    // `lte` requires the field value to be less than or equal to the specified
    // value (field <= value). If the field value is greater than the specified
    // value, an error message is generated.
    //
    // ```proto
    // message MyFixed32 {
    //   // value must be less than or equal to 10
    //   fixed32 value = 1 [(buf.validate.field).fixed32.lte = 10];
    // }
    // ```
    fixed32 lte = 3 [(predefined).cel = {
      id: "fixed32.lte"
      expression:
        "!has(rules.gte) && !has(rules.gt) && this > rules.lte"
        "? 'value must be less than or equal to %s'.format([rules.lte]) : ''"
    }];
  }
  oneof greater_than {
    // `gt` requires the field value to be greater than the specified value
    // (exclusive). If the value of `gt` is larger than a specified `lt` or
    // `lte`, the range is reversed, and the field value must be outside the
    // specified range. If the field value doesn't meet the required conditions,
    // an error message is generated.
    //
    // ```proto
    // message MyFixed32 {
    //   // value must be greater than 5 [fixed32.gt]
    //   fixed32 value = 1 [(buf.validate.field).fixed32.gt = 5];
    //
    //   // value must be greater than 5 and less than 10 [fixed32.gt_lt]
    //   fixed32 other_value = 2 [(buf.validate.field).fixed32 = { gt: 5, lt: 10 }];
    //
    //   // value must be greater than 10 or less than 5 [fixed32.gt_lt_exclusive]
    //   fixed32 another_value = 3 [(buf.validate.field).fixed32 = { gt: 10, lt: 5 }];
    // }
    // ```
    fixed32 gt = 4 [
      (predefined).cel = {
        id: "fixed32.gt"
        expression:
          "!has(rules.lt) && !has(rules.lte) && this <= rules.gt"
          "? 'value must be greater than %s'.format([rules.gt]) : ''"
      },
      (predefined).cel = {
        id: "fixed32.gt_lt"
        expression:
          "has(rules.lt) && rules.lt >= rules.gt && (this >= rules.lt || this <= rules.gt)"
          "? 'value must be greater than %s and less than %s'.format([rules.gt, rules.lt]) : ''"
      },
      (predefined).cel = {
        id: "fixed32.gt_lt_exclusive"
        expression:
          "has(rules.lt) && rules.lt < rules.gt && (rules.lt <= this && this <= rules.gt)"
          "? 'value must be greater than %s or less than %s'.format([rules.gt, rules.lt]) : ''"
      },
      (predefined).cel = {
        id: "fixed32.gt_lte"
        expression:
          "has(rules.lte) && rules.lte >= rules.gt && (this > rules.lte || this <= rules.gt)"
          "? 'value must be greater than %s and less than or equal to %s'.format([rules.gt, rules.lte]) : ''"
      },
      (predefined).cel = {
        id: "fixed32.gt_lte_exclusive"
        expression:
          "has(rules.lte) && rules.lte < rules.gt && (rules.lte < this && this <= rules.gt)"
          "? 'value must be greater than %s or less than or equal to %s'.format([rules.gt, rules.lte]) : ''"
      }
    ];

    // `gte` requires the field value to be greater than or equal to the specified
    // value (exclusive). If the value of `gte` is larger than a specified `lt`
    // or `lte`, the range is reversed, and the field value must be outside the
    // specified range. If the field value doesn't meet the required conditions,
    // an error message is generated.
    //
    // ```proto
    // message MyFixed32 {
    //   // value must be greater than or equal to 5 [fixed32.gte]
    //   fixed32 value = 1 [(buf.validate.field).fixed32.gte = 5];
    //
    //   // value must be greater than or equal to 5 and less than 10 [fixed32.gte_lt]
    //   fixed32 other_value = 2 [(buf.validate.field).fixed32 = { gte: 5, lt: 10 }];
    //
    //   // value must be greater than or equal to 10 or less than 5 [fixed32.gte_lt_exclusive]
    //   fixed32 another_value = 3 [(buf.validate.field).fixed32 = { gte: 10, lt: 5 }];
    // }
    // ```
    fixed32 gte = 5 [
      (predefined).cel = {
        id: "fixed32.gte"
        expression:
          "!has(rules.lt) && !has(rules.lte) && this < rules.gte"
          "? 'value must be greater than or equal to %s'.format([rules.gte]) : ''"
      },
      (predefined).cel = {
        id: "fixed32.gte_lt"
        expression:
          "has(rules.lt) && rules.lt >= rules.gte && (this >= rules.lt || this < rules.gte)"
          "? 'value must be greater than or equal to %s and less than %s'.format([rules.gte, rules.lt]) : ''"
      },
      (predefined).cel = {
        id: "fixed32.gte_lt_exclusive"
        expression:
          "has(rules.lt) && rules.lt < rules.gte && (rules.lt <= this && this < rules.gte)"
          "? 'value must be greater than or equal to %s or less than %s'.format([rules.gte, rules.lt]) : ''"
      },
      (predefined).cel = {
        id: "fixed32.gte_lte"
        expression:
          "has(rules.lte) && rules.lte >= rules.gte && (this > rules.lte || this < rules.gte)"
          "? 'value must be greater than or equal to %s and less than or equal to %s'.format([rules.gte, rules.lte]) : ''"
      },
      (predefined).cel = {
        id: "fixed32.gte_lte_exclusive"
        expression:
          "has(rules.lte) && rules.lte < rules.gte && (rules.lte < this && this < rules.gte)"
          "? 'value must be greater than or equal to %s or less than or equal to %s'.format([rules.gte, rules.lte]) : ''"
      }
    ];
  }

  // `in` requires the field value to be equal to one of the specified values.
  // If the field value isn't one of the specified values, an error message
  // is generated.
  //
  // ```proto
  // message MyFixed32 {
  //   // value must be in list [1, 2, 3]
  //   fixed32 value = 1 [(buf.validate.field).fixed32 = { in: [1, 2, 3] }];
  // }
  // ```
  repeated fixed32 in = 6 [(predefined).cel = {
    id: "fixed32.in"
    expression: "!(this in getField(rules, 'in')) ? 'value must be in list %s'.format([getField(rules, 'in')]) : ''"
  }];

  // `not_in` requires the field value to not be equal to any of the specified
  // values. If the field value is one of the specified values, an error
  // message is generated.
  //
  // ```proto
  // message MyFixed32 {
  //   // value must not be in list [1, 2, 3]
  //   fixed32 value = 1 [(buf.validate.field).fixed32 = { not_in: [1, 2, 3] }];
  // }
  // ```
  repeated fixed32 not_in = 7 [(predefined).cel = {
    id: "fixed32.not_in"
    expression: "this in rules.not_in ? 'value must not be in list %s'.format([rules.not_in]) : ''"
  }];

  // `example` specifies values that the field may have. These values SHOULD
  // conform to other rules. `example` values will not impact validation
  // but may be used as helpful guidance on how to populate the given field.
  //
  // ```proto
  // message MyFixed32 {
  //   fixed32 value = 1 [
  //     (buf.validate.field).fixed32.example = 1,
  //     (buf.validate.field).fixed32.example = 2
  //   ];
  // }
  // ```
  repeated fixed32 example = 8 [(predefined).cel = {
    id: "fixed32.example"
    expression: "true"
  }];

  // Extension fields in this range that have the (buf.validate.predefined)
  // option set will be treated as predefined field rules that can then be
  // set on the field options of other fields to apply field rules.
  // Extension numbers 1000 to 99999 are reserved for extension numbers that are
  // defined in the [Protobuf Global Extension Registry][1]. Extension numbers
  // above this range are reserved for extension numbers that are not explicitly
  // assigned. For rules defined in publicly-consumed schemas, use of extensions
  // above 99999 is discouraged due to the risk of conflicts.
  //
  // [1]: https://github.com/protocolbuffers/protobuf/blob/main/docs/options.md
  extensions 1000 to max;
}

// Fixed64Rules describes the rules applied to `fixed64` values.
message Fixed64Rules {
  // `const` requires the field value to exactly match the specified value. If
  // the field value doesn't match, an error message is generated.
  //
  // ```proto
  // message MyFixed64 {
  //   // value must equal 42
  //   fixed64 value = 1 [(buf.validate.field).fixed64.const = 42];
  // }
  // ```
  optional fixed64 const = 1 [(predefined).cel = {
    id: "fixed64.const"
    expression: "this != getField(rules, 'const') ? 'value must equal %s'.format([getField(rules, 'const')]) : ''"
  }];
  oneof less_than {
    // `lt` requires the field value to be less than the specified value (field <
    // value). If the field value is equal to or greater than the specified value,
    // an error message is generated.
    //
    // ```proto
    // message MyFixed64 {
    //   // value must be less than 10
    //   fixed64 value = 1 [(buf.validate.field).fixed64.lt = 10];
    // }
    // ```
    fixed64 lt = 2 [(predefined).cel = {
      id: "fixed64.lt"
      expression:
        "!has(rules.gte) && !has(rules.gt) && this >= rules.lt"
        "? 'value must be less than %s'.format([rules.lt]) : ''"
    }];

    // `lte` requires the field value to be less than or equal to the specified
    // value (field <= value). If the field value is greater than the specified
    // value, an error message is generated.
    //
    // ```proto
    // message MyFixed64 {
    //   // value must be less than or equal to 10
    //   fixed64 value = 1 [(buf.validate.field).fixed64.lte = 10];
    // }
    // ```
    fixed64 lte = 3 [(predefined).cel = {
      id: "fixed64.lte"
      expression:
        "!has(rules.gte) && !has(rules.gt) && this > rules.lte"
        "? 'value must be less than or equal to %s'.format([rules.lte]) : ''"
    }];
  }
  oneof greater_than {
    // `gt` requires the field value to be greater than the specified value
    // (exclusive). If the value of `gt` is larger than a specified `lt` or
    // `lte`, the range is reversed, and the field value must be outside the
    // specified range. If the field value doesn't meet the required conditions,
    // an error message is generated.
    //
    // ```proto
    // message MyFixed64 {
    //   // value must be greater than 5 [fixed64.gt]
    //   fixed64 value = 1 [(buf.validate.field).fixed64.gt = 5];
    //
    //   // value must be greater than 5 and less than 10 [fixed64.gt_lt]
    //   fixed64 other_value = 2 [(buf.validate.field).fixed64 = { gt: 5, lt: 10 }];
    //
    //   // value must be greater than 10 or less than 5 [fixed64.gt_lt_exclusive]
    //   fixed64 another_value = 3 [(buf.validate.field).fixed64 = { gt: 10, lt: 5 }];
    // }
    // ```
    fixed64 gt = 4 [
      (predefined).cel = {
        id: "fixed64.gt"
        expression:
          "!has(rules.lt) && !has(rules.lte) && this <= rules.gt"
          "? 'value must be greater than %s'.format([rules.gt]) : ''"
      },
      (predefined).cel = {
        id: "fixed64.gt_lt"
        expression:
          "has(rules.lt) && rules.lt >= rules.gt && (this >= rules.lt || this <= rules.gt)"
          "? 'value must be greater than %s and less than %s'.format([rules.gt, rules.lt]) : ''"
      },
      (predefined).cel = {
        id: "fixed64.gt_lt_exclusive"
        expression:
          "has(rules.lt) && rules.lt < rules.gt && (rules.lt <= this && this <= rules.gt)"
          "? 'value must be greater than %s or less than %s'.format([rules.gt, rules.lt]) : ''"
      },
      (predefined).cel = {
        id: "fixed64.gt_lte"
        expression:
          "has(rules.lte) && rules.lte >= rules.gt && (this > rules.lte || this <= rules.gt)"
          "? 'value must be greater than %s and less than or equal to %s'.format([rules.gt, rules.lte]) : ''"
      },
      (predefined).cel = {
        id: "fixed64.gt_lte_exclusive"
        expression:
          "has(rules.lte) && rules.lte < rules.gt && (rules.lte < this && this <= rules.gt)"
          "? 'value must be greater than %s or less than or equal to %s'.format([rules.gt, rules.lte]) : ''"
      }
    ];

    // `gte` requires the field value to be greater than or equal to the specified
    // value (exclusive). If the value of `gte` is larger than a specified `lt`
    // or `lte`, the range is reversed, and the field value must be outside the
    // specified range. If the field value doesn't meet the required conditions,
    // an error message is generated.
    //
    // ```proto
    // message MyFixed64 {
    //   // value must be greater than or equal to 5 [fixed64.gte]
    //   fixed64 value = 1 [(buf.validate.field).fixed64.gte = 5];
    //
    //   // value must be greater than or equal to 5 and less than 10 [fixed64.gte_lt]
    //   fixed64 other_value = 2 [(buf.validate.field).fixed64 = { gte: 5, lt: 10 }];
    //
    //   // value must be greater than or equal to 10 or less than 5 [fixed64.gte_lt_exclusive]
    //   fixed64 another_value = 3 [(buf.validate.field).fixed64 = { gte: 10, lt: 5 }];
    // }
    // ```
    fixed64 gte = 5 [
      (predefined).cel = {
        id: "fixed64.gte"
        expression:
          "!has(rules.lt) && !has(rules.lte) && this < rules.gte"
          "? 'value must be greater than or equal to %s'.format([rules.gte]) : ''"
      },
      (predefined).cel = {
        id: "fixed64.gte_lt"
        expression:
          "has(rules.lt) && rules.lt >= rules.gte && (this >= rules.lt || this < rules.gte)"
          "? 'value must be greater than or equal to %s and less than %s'.format([rules.gte, rules.lt]) : ''"
      },
      (predefined).cel = {
        id: "fixed64.gte_lt_exclusive"
        expression:
          "has(rules.lt) && rules.lt < rules.gte && (rules.lt <= this && this < rules.gte)"
          "? 'value must be greater than or equal to %s or less than %s'.format([rules.gte, rules.lt]) : ''"
      },
      (predefined).cel = {
        id: "fixed64.gte_lte"
        expression:
          "has(rules.lte) && rules.lte >= rules.gte && (this > rules.lte || this < rules.gte)"
          "? 'value must be greater than or equal to %s and less than or equal to %s'.format([rules.gte, rules.lte]) : ''"
      },
      (predefined).cel = {
        id: "fixed64.gte_lte_exclusive"
        expression:
          "has(rules.lte) && rules.lte < rules.gte && (rules.lte < this && this < rules.gte)"
          "? 'value must be greater than or equal to %s or less than or equal to %s'.format([rules.gte, rules.lte]) : ''"
      }
    ];
  }

  // `in` requires the field value to be equal to one of the specified values.
  // If the field value isn't one of the specified values, an error message is
  // generated.
  //
  // ```proto
  // message MyFixed64 {
  //   // value must be in list [1, 2, 3]
  //   fixed64 value = 1 [(buf.validate.field).fixed64 = { in: [1, 2, 3] }];
  // }
  // ```
  repeated fixed64 in = 6 [(predefined).cel = {
    id: "fixed64.in"
    expression: "!(this in getField(rules, 'in')) ? 'value must be in list %s'.format([getField(rules, 'in')]) : ''"
  }];

  // `not_in` requires the field value to not be equal to any of the specified
  // values. If the field value is one of the specified values, an error
  // message is generated.
  //
  // ```proto
  // message MyFixed64 {
  //   // value must not be in list [1, 2, 3]
  //   fixed64 value = 1 [(buf.validate.field).fixed64 = { not_in: [1, 2, 3] }];
  // }
  // ```
  repeated fixed64 not_in = 7 [(predefined).cel = {
    id: "fixed64.not_in"
    expression: "this in rules.not_in ? 'value must not be in list %s'.format([rules.not_in]) : ''"
  }];

  // `example` specifies values that the field may have. These values SHOULD
  // conform to other rules. `example` values will not impact validation
  // but may be used as helpful guidance on how to populate the given field.
  //
  // ```proto
  // message MyFixed64 {
  //   fixed64 value = 1 [
  //     (buf.validate.field).fixed64.example = 1,
  //     (buf.validate.field).fixed64.example = 2
  //   ];
  // }
  // ```
  repeated fixed64 example = 8 [(predefined).cel = {
    id: "fixed64.example"
    expression: "true"
  }];

  // Extension fields in this range that have the (buf.validate.predefined)
  // option set will be treated as predefined field rules that can then be
  // set on the field options of other fields to apply field rules.
  // Extension numbers 1000 to 99999 are reserved for extension numbers that are
  // defined in the [Protobuf Global Extension Registry][1]. Extension numbers
  // above this range are reserved for extension numbers that are not explicitly
  // assigned. For rules defined in publicly-consumed schemas, use of extensions
  // above 99999 is discouraged due to the risk of conflicts.
  //
  // [1]: https://github.com/protocolbuffers/protobuf/blob/main/docs/options.md
  extensions 1000 to max;
}

// SFixed32Rules describes the rules applied to `fixed32` values.
message SFixed32Rules {
  // `const` requires the field value to exactly match the specified value. If
  // the field value doesn't match, an error message is generated.
  //
  // ```proto
  // message MySFixed32 {
  //   // value must equal 42
  //   sfixed32 value = 1 [(buf.validate.field).sfixed32.const = 42];
  // }
  // ```
  optional sfixed32 const = 1 [(predefined).cel = {
    id: "sfixed32.const"
    expression: "this != getField(rules, 'const') ? 'value must equal %s'.format([getField(rules, 'const')]) : ''"
  }];
  oneof less_than {
    // `lt` requires the field value to be less than the specified value (field <
    // value). If the field value is equal to or greater than the specified value,
    // an error message is generated.
    //
    // ```proto
    // message MySFixed32 {
    //   // value must be less than 10
    //   sfixed32 value = 1 [(buf.validate.field).sfixed32.lt = 10];
    // }
    // ```
    sfixed32 lt = 2 [(predefined).cel = {
      id: "sfixed32.lt"
      expression:
        "!has(rules.gte) && !has(rules.gt) && this >= rules.lt"
        "? 'value must be less than %s'.format([rules.lt]) : ''"
    }];

    // `lte` requires the field value to be less than or equal to the specified
    // value (field <= value). If the field value is greater than the specified
    // value, an error message is generated.
    //
    // ```proto
    // message MySFixed32 {
    //   // value must be less than or equal to 10
    //   sfixed32 value = 1 [(buf.validate.field).sfixed32.lte = 10];
    // }
    // ```
    sfixed32 lte = 3 [(predefined).cel = {
      id: "sfixed32.lte"
      expression:
        "!has(rules.gte) && !has(rules.gt) && this > rules.lte"
        "? 'value must be less than or equal to %s'.format([rules.lte]) : ''"
    }];
  }
  oneof greater_than {
    // `gt` requires the field value to be greater than the specified value
    // (exclusive). If the value of `gt` is larger than a specified `lt` or
    // `lte`, the range is reversed, and the field value must be outside the
    // specified range. If the field value doesn't meet the required conditions,
    // an error message is generated.
    //
    // ```proto
    // message MySFixed32 {
    //   // value must be greater than 5 [sfixed32.gt]
    //   sfixed32 value = 1 [(buf.validate.field).sfixed32.gt = 5];
    //
    //   // value must be greater than 5 and less than 10 [sfixed32.gt_lt]
    //   sfixed32 other_value = 2 [(buf.validate.field).sfixed32 = { gt: 5, lt: 10 }];
    //
    //   // value must be greater than 10 or less than 5 [sfixed32.gt_lt_exclusive]
    //   sfixed32 another_value = 3 [(buf.validate.field).sfixed32 = { gt: 10, lt: 5 }];
    // }
    // ```
    sfixed32 gt = 4 [
      (predefined).cel = {
        id: "sfixed32.gt"
        expression:
          "!has(rules.lt) && !has(rules.lte) && this <= rules.gt"
          "? 'value must be greater than %s'.format([rules.gt]) : ''"
      },
      (predefined).cel = {
        id: "sfixed32.gt_lt"
        expression:
          "has(rules.lt) && rules.lt >= rules.gt && (this >= rules.lt || this <= rules.gt)"
          "? 'value must be greater than %s and less than %s'.format([rules.gt, rules.lt]) : ''"
      },
      (predefined).cel = {
        id: "sfixed32.gt_lt_exclusive"
        expression:
          "has(rules.lt) && rules.lt < rules.gt && (rules.lt <= this && this <= rules.gt)"
          "? 'value must be greater than %s or less than %s'.format([rules.gt, rules.lt]) : ''"
      },
      (predefined).cel = {
        id: "sfixed32.gt_lte"
        expression:
          "has(rules.lte) && rules.lte >= rules.gt && (this > rules.lte || this <= rules.gt)"
          "? 'value must be greater than %s and less than or equal to %s'.format([rules.gt, rules.lte]) : ''"
      },
      (predefined).cel = {
        id: "sfixed32.gt_lte_exclusive"
        expression:
          "has(rules.lte) && rules.lte < rules.gt && (rules.lte < this && this <= rules.gt)"
          "? 'value must be greater than %s or less than or equal to %s'.format([rules.gt, rules.lte]) : ''"
      }
    ];

    // `gte` requires the field value to be greater than or equal to the specified
    // value (exclusive). If the value of `gte` is larger than a specified `lt`
    // or `lte`, the range is reversed, and the field value must be outside the
    // specified range. If the field value doesn't meet the required conditions,
    // an error message is generated.
    //
    // ```proto
    // message MySFixed32 {
    //   // value must be greater than or equal to 5 [sfixed32.gte]
    //   sfixed32 value = 1 [(buf.validate.field).sfixed32.gte = 5];
    //
    //   // value must be greater than or equal to 5 and less than 10 [sfixed32.gte_lt]
    //   sfixed32 other_value = 2 [(buf.validate.field).sfixed32 = { gte: 5, lt: 10 }];
    //
    //   // value must be greater than or equal to 10 or less than 5 [sfixed32.gte_lt_exclusive]
    //   sfixed32 another_value = 3 [(buf.validate.field).sfixed32 = { gte: 10, lt: 5 }];
    // }
    // ```
    sfixed32 gte = 5 [
      (predefined).cel = {
        id: "sfixed32.gte"
        expression:
          "!has(rules.lt) && !has(rules.lte) && this < rules.gte"
          "? 'value must be greater than or equal to %s'.format([rules.gte]) : ''"
      },
      (predefined).cel = {
        id: "sfixed32.gte_lt"
        expression:
          "has(rules.lt) && rules.lt >= rules.gte && (this >= rules.lt || this < rules.gte)"
          "? 'value must be greater than or equal to %s and less than %s'.format([rules.gte, rules.lt]) : ''"
      },
      (predefined).cel = {
        id: "sfixed32.gte_lt_exclusive"
        expression:
          "has(rules.lt) && rules.lt < rules.gte && (rules.lt <= this && this < rules.gte)"
          "? 'value must be greater than or equal to %s or less than %s'.format([rules.gte, rules.lt]) : ''"
      },
      (predefined).cel = {
        id: "sfixed32.gte_lte"
        expression:
          "has(rules.lte) && rules.lte >= rules.gte && (this > rules.lte || this < rules.gte)"
          "? 'value must be greater than or equal to %s and less than or equal to %s'.format([rules.gte, rules.lte]) : ''"
      },
      (predefined).cel = {
        id: "sfixed32.gte_lte_exclusive"
        expression:
          "has(rules.lte) && rules.lte < rules.gte && (rules.lte < this && this < rules.gte)"
          "? 'value must be greater than or equal to %s or less than or equal to %s'.format([rules.gte, rules.lte]) : ''"
      }
    ];
  }

  // `in` requires the field value to be equal to one of the specified values.
  // If the field value isn't one of the specified values, an error message is
  // generated.
  //
  // ```proto
  // message MySFixed32 {
  //   // value must be in list [1, 2, 3]
  //   sfixed32 value = 1 [(buf.validate.field).sfixed32 = { in: [1, 2, 3] }];
  // }
  // ```
  repeated sfixed32 in = 6 [(predefined).cel = {
    id: "sfixed32.in"
    expression: "!(this in getField(rules, 'in')) ? 'value must be in list %s'.format([getField(rules, 'in')]) : ''"
  }];

  // `not_in` requires the field value to not be equal to any of the specified
  // values. If the field value is one of the specified values, an error
  // message is generated.
  //
  // ```proto
  // message MySFixed32 {
  //   // value must not be in list [1, 2, 3]
  //   sfixed32 value = 1 [(buf.validate.field).sfixed32 = { not_in: [1, 2, 3] }];
  // }
  // ```
  repeated sfixed32 not_in = 7 [(predefined).cel = {
    id: "sfixed32.not_in"
    expression: "this in rules.not_in ? 'value must not be in list %s'.format([rules.not_in]) : ''"
  }];

  // `example` specifies values that the field may have. These values SHOULD
  // conform to other rules. `example` values will not impact validation
  // but may be used as helpful guidance on how to populate the given field.
  //
  // ```proto
  // message MySFixed32 {
  //   sfixed32 value = 1 [
  //     (buf.validate.field).sfixed32.example = 1,
  //     (buf.validate.field).sfixed32.example = 2
  //   ];
  // }
  // ```
  repeated sfixed32 example = 8 [(predefined).cel = {
    id: "sfixed32.example"
    expression: "true"
  }];

  // Extension fields in this range that have the (buf.validate.predefined)
  // option set will be treated as predefined field rules that can then be
  // set on the field options of other fields to apply field rules.
  // Extension numbers 1000 to 99999 are reserved for extension numbers that are
  // defined in the [Protobuf Global Extension Registry][1]. Extension numbers
  // above this range are reserved for extension numbers that are not explicitly
  // assigned. For rules defined in publicly-consumed schemas, use of extensions
  // above 99999 is discouraged due to the risk of conflicts.
  //
  // [1]: https://github.com/protocolbuffers/protobuf/blob/main/docs/options.md
  extensions 1000 to max;
}

// SFixed64Rules describes the rules applied to `fixed64` values.
message SFixed64Rules {
  // `const` requires the field value to exactly match the specified value. If
  // the field value doesn't match, an error message is generated.
  //
  // ```proto
  // message MySFixed64 {
  //   // value must equal 42
  //   sfixed64 value = 1 [(buf.validate.field).sfixed64.const = 42];
  // }
  // ```
  optional sfixed64 const = 1 [(predefined).cel = {
    id: "sfixed64.const"
    expression: "this != getField(rules, 'const') ? 'value must equal %s'.format([getField(rules, 'const')]) : ''"
  }];
  oneof less_than {
    // `lt` requires the field value to be less than the specified value (field <
    // value). If the field value is equal to or greater than the specified value,
    // an error message is generated.
    //
    // ```proto
    // message MySFixed64 {
    //   // value must be less than 10
    //   sfixed64 value = 1 [(buf.validate.field).sfixed64.lt = 10];
    // }
    // ```
    sfixed64 lt = 2 [(predefined).cel = {
      id: "sfixed64.lt"
      expression:
        "!has(rules.gte) && !has(rules.gt) && this >= rules.lt"
        "? 'value must be less than %s'.format([rules.lt]) : ''"
    }];

    // `lte` requires the field value to be less than or equal to the specified
    // value (field <= value). If the field value is greater than the specified
    // value, an error message is generated.
    //
    // ```proto
    // message MySFixed64 {
    //   // value must be less than or equal to 10
    //   sfixed64 value = 1 [(buf.validate.field).sfixed64.lte = 10];
    // }
    // ```
    sfixed64 lte = 3 [(predefined).cel = {
      id: "sfixed64.lte"
      expression:
        "!has(rules.gte) && !has(rules.gt) && this > rules.lte"
        "? 'value must be less than or equal to %s'.format([rules.lte]) : ''"
    }];
  }
  oneof greater_than {
    // `gt` requires the field value to be greater than the specified value
    // (exclusive). If the value of `gt` is larger than a specified `lt` or
    // `lte`, the range is reversed, and the field value must be outside the
    // specified range. If the field value doesn't meet the required conditions,
    // an error message is generated.
    //
    // ```proto
    // message MySFixed64 {
    //   // value must be greater than 5 [sfixed64.gt]
    //   sfixed64 value = 1 [(buf.validate.field).sfixed64.gt = 5];
    //
    //   // value must be greater than 5 and less than 10 [sfixed64.gt_lt]
    //   sfixed64 other_value = 2 [(buf.validate.field).sfixed64 = { gt: 5, lt: 10 }];
    //
    //   // value must be greater than 10 or less than 5 [sfixed64.gt_lt_exclusive]
    //   sfixed64 another_value = 3 [(buf.validate.field).sfixed64 = { gt: 10, lt: 5 }];
    // }
    // ```
    sfixed64 gt = 4 [
      (predefined).cel = {
        id: "sfixed64.gt"
        expression:
          "!has(rules.lt) && !has(rules.lte) && this <= rules.gt"
          "? 'value must be greater than %s'.format([rules.gt]) : ''"
      },
      (predefined).cel = {
        id: "sfixed64.gt_lt"
        expression:
          "has(rules.lt) && rules.lt >= rules.gt && (this >= rules.lt || this <= rules.gt)"
          "? 'value must be greater than %s and less than %s'.format([rules.gt, rules.lt]) : ''"
      },
      (predefined).cel = {
        id: "sfixed64.gt_lt_exclusive"
        expression:
          "has(rules.lt) && rules.lt < rules.gt && (rules.lt <= this && this <= rules.gt)"
          "? 'value must be greater than %s or less than %s'.format([rules.gt, rules.lt]) : ''"
      },
      (predefined).cel = {
        id: "sfixed64.gt_lte"
        expression:
          "has(rules.lte) && rules.lte >= rules.gt && (this > rules.lte || this <= rules.gt)"
          "? 'value must be greater than %s and less than or equal to %s'.format([rules.gt, rules.lte]) : ''"
      },
      (predefined).cel = {
        id: "sfixed64.gt_lte_exclusive"
        expression:
          "has(rules.lte) && rules.lte < rules.gt && (rules.lte < this && this <= rules.gt)"
          "? 'value must be greater than %s or less than or equal to %s'.format([rules.gt, rules.lte]) : ''"
      }
    ];

    // `gte` requires the field value to be greater than or equal to the specified
    // value (exclusive). If the value of `gte` is larger than a specified `lt`
    // or `lte`, the range is reversed, and the field value must be outside the
    // specified range. If the field value doesn't meet the required conditions,
    // an error message is generated.
    //
    // ```proto
    // message MySFixed64 {
    //   // value must be greater than or equal to 5 [sfixed64.gte]
    //   sfixed64 value = 1 [(buf.validate.field).sfixed64.gte = 5];
    //
    //   // value must be greater than or equal to 5 and less than 10 [sfixed64.gte_lt]
    //   sfixed64 other_value = 2 [(buf.validate.field).sfixed64 = { gte: 5, lt: 10 }];
    //
    //   // value must be greater than or equal to 10 or less than 5 [sfixed64.gte_lt_exclusive]
    //   sfixed64 another_value = 3 [(buf.validate.field).sfixed64 = { gte: 10, lt: 5 }];
    // }
    // ```
    sfixed64 gte = 5 [
      (predefined).cel = {
        id: "sfixed64.gte"
        expression:
          "!has(rules.lt) && !has(rules.lte) && this < rules.gte"
          "? 'value must be greater than or equal to %s'.format([rules.gte]) : ''"
      },
      (predefined).cel = {
        id: "sfixed64.gte_lt"
        expression:
          "has(rules.lt) && rules.lt >= rules.gte && (this >= rules.lt || this < rules.gte)"
          "? 'value must be greater than or equal to %s and less than %s'.format([rules.gte, rules.lt]) : ''"
      },
      (predefined).cel = {
        id: "sfixed64.gte_lt_exclusive"
        expression:
          "has(rules.lt) && rules.lt < rules.gte && (rules.lt <= this && this < rules.gte)"
          "? 'value must be greater than or equal to %s or less than %s'.format([rules.gte, rules.lt]) : ''"
      },
      (predefined).cel = {
        id: "sfixed64.gte_lte"
        expression:
          "has(rules.lte) && rules.lte >= rules.gte && (this > rules.lte || this < rules.gte)"
          "? 'value must be greater than or equal to %s and less than or equal to %s'.format([rules.gte, rules.lte]) : ''"
      },
      (predefined).cel = {
        id: "sfixed64.gte_lte_exclusive"
        expression:
          "has(rules.lte) && rules.lte < rules.gte && (rules.lte < this && this < rules.gte)"
          "? 'value must be greater than or equal to %s or less than or equal to %s'.format([rules.gte, rules.lte]) : ''"
      }
    ];
  }

  // `in` requires the field value to be equal to one of the specified values.
  // If the field value isn't one of the specified values, an error message is
  // generated.
  //
  // ```proto
  // message MySFixed64 {
  //   // value must be in list [1, 2, 3]
  //   sfixed64 value = 1 [(buf.validate.field).sfixed64 = { in: [1, 2, 3] }];
  // }
  // ```
  repeated sfixed64 in = 6 [(predefined).cel = {
    id: "sfixed64.in"
    expression: "!(this in getField(rules, 'in')) ? 'value must be in list %s'.format([getField(rules, 'in')]) : ''"
  }];

  // `not_in` requires the field value to not be equal to any of the specified
  // values. If the field value is one of the specified values, an error
  // message is generated.
  //
  // ```proto
  // message MySFixed64 {
  //   // value must not be in list [1, 2, 3]
  //   sfixed64 value = 1 [(buf.validate.field).sfixed64 = { not_in: [1, 2, 3] }];
  // }
  // ```
  repeated sfixed64 not_in = 7 [(predefined).cel = {
    id: "sfixed64.not_in"
    expression: "this in rules.not_in ? 'value must not be in list %s'.format([rules.not_in]) : ''"
  }];

  // `example` specifies values that the field may have. These values SHOULD
  // conform to other rules. `example` values will not impact validation
  // but may be used as helpful guidance on how to populate the given field.
  //
  // ```proto
  // message MySFixed64 {
  //   sfixed64 value = 1 [
  //     (buf.validate.field).sfixed64.example = 1,
  //     (buf.validate.field).sfixed64.example = 2
  //   ];
  // }
  // ```
  repeated sfixed64 example = 8 [(predefined).cel = {
    id: "sfixed64.example"
    expression: "true"
  }];

  // Extension fields in this range that have the (buf.validate.predefined)
  // option set will be treated as predefined field rules that can then be
  // set on the field options of other fields to apply field rules.
  // Extension numbers 1000 to 99999 are reserved for extension numbers that are
  // defined in the [Protobuf Global Extension Registry][1]. Extension numbers
  // above this range are reserved for extension numbers that are not explicitly
  // assigned. For rules defined in publicly-consumed schemas, use of extensions
  // above 99999 is discouraged due to the risk of conflicts.
  //
  // [1]: https://github.com/protocolbuffers/protobuf/blob/main/docs/options.md
  extensions 1000 to max;
}

// BoolRules describes the rules applied to `bool` values. These rules
// may also be applied to the `google.protobuf.BoolValue` Well-Known-Type.
message BoolRules {
  // `const` requires the field value to exactly match the specified boolean value.
  // If the field value doesn't match, an error message is generated.
  //
  // ```proto
  // message MyBool {
  //   // value must equal true
  //   bool value = 1 [(buf.validate.field).bool.const = true];
  // }
  // ```
  optional bool const = 1 [(predefined).cel = {
    id: "bool.const"
    expression: "this != getField(rules, 'const') ? 'value must equal %s'.format([getField(rules, 'const')]) : ''"
  }];

  // `example` specifies values that the field may have. These values SHOULD
  // conform to other rules. `example` values will not impact validation
  // but may be used as helpful guidance on how to populate the given field.
  //
  // ```proto
  // message MyBool {
  //   bool value = 1 [
  //     (buf.validate.field).bool.example = 1,
  //     (buf.validate.field).bool.example = 2
  //   ];
  // }
  // ```
  repeated bool example = 2 [(predefined).cel = {
    id: "bool.example"
    expression: "true"
  }];

  // Extension fields in this range that have the (buf.validate.predefined)
  // option set will be treated as predefined field rules that can then be
  // set on the field options of other fields to apply field rules.
  // Extension numbers 1000 to 99999 are reserved for extension numbers that are
  // defined in the [Protobuf Global Extension Registry][1]. Extension numbers
  // above this range are reserved for extension numbers that are not explicitly
  // assigned. For rules defined in publicly-consumed schemas, use of extensions
  // above 99999 is discouraged due to the risk of conflicts.
  //
  // [1]: https://github.com/protocolbuffers/protobuf/blob/main/docs/options.md
  extensions 1000 to max;
}

// StringRules describes the rules applied to `string` values These
// rules may also be applied to the `google.protobuf.StringValue` Well-Known-Type.
message StringRules {
  // `const` requires the field value to exactly match the specified value. If
  // the field value doesn't match, an error message is generated.
  //
  // ```proto
  // message MyString {
  //   // value must equal `hello`
  //   string value = 1 [(buf.validate.field).string.const = "hello"];
  // }
  // ```
  optional string const = 1 [(predefined).cel = {
    id: "string.const"
    expression: "this != getField(rules, 'const') ? 'value must equal `%s`'.format([getField(rules, 'const')]) : ''"
  }];

  // `len` dictates that the field value must have the specified
  // number of characters (Unicode code points), which may differ from the number
  // of bytes in the string. If the field value does not meet the specified
  // length, an error message will be generated.
  //
  // ```proto
  // message MyString {
  //   // value length must be 5 characters
  //   string value = 1 [(buf.validate.field).string.len = 5];
  // }
  // ```
  optional uint64 len = 19 [(predefined).cel = {
    id: "string.len"
    expression: "uint(this.size()) != rules.len ? 'value length must be %s characters'.format([rules.len]) : ''"
  }];

  // `min_len` specifies that the field value must have at least the specified
  // number of characters (Unicode code points), which may differ from the number
  // of bytes in the string. If the field value contains fewer characters, an error
  // message will be generated.
  //
  // ```proto
  // message MyString {
  //   // value length must be at least 3 characters
  //   string value = 1 [(buf.validate.field).string.min_len = 3];
  // }
  // ```
  optional uint64 min_len = 2 [(predefined).cel = {
    id: "string.min_len"
    expression: "uint(this.size()) < rules.min_len ? 'value length must be at least %s characters'.format([rules.min_len]) : ''"
  }];

  // `max_len` specifies that the field value must have no more than the specified
  // number of characters (Unicode code points), which may differ from the
  // number of bytes in the string. If the field value contains more characters,
  // an error message will be generated.
  //
  // ```proto
  // message MyString {
  //   // value length must be at most 10 characters
  //   string value = 1 [(buf.validate.field).string.max_len = 10];
  // }
  // ```
  optional uint64 max_len = 3 [(predefined).cel = {
    id: "string.max_len"
    expression: "uint(this.size()) > rules.max_len ? 'value length must be at most %s characters'.format([rules.max_len]) : ''"
  }];

  // `len_bytes` dictates that the field value must have the specified number of
  // bytes. If the field value does not match the specified length in bytes,
  // an error message will be generated.
  //
  // ```proto
  // message MyString {
  //   // value length must be 6 bytes
  //   string value = 1 [(buf.validate.field).string.len_bytes = 6];
  // }
  // ```
  optional uint64 len_bytes = 20 [(predefined).cel = {
    id: "string.len_bytes"
    expression: "uint(bytes(this).size()) != rules.len_bytes ? 'value length must be %s bytes'.format([rules.len_bytes]) : ''"
  }];

  // `min_bytes` specifies that the field value must have at least the specified
  // number of bytes. If the field value contains fewer bytes, an error message
  // will be generated.
  //
  // ```proto
  // message MyString {
  //   // value length must be at least 4 bytes
  //   string value = 1 [(buf.validate.field).string.min_bytes = 4];
  // }
  //
  // ```
  optional uint64 min_bytes = 4 [(predefined).cel = {
    id: "string.min_bytes"
    expression: "uint(bytes(this).size()) < rules.min_bytes ? 'value length must be at least %s bytes'.format([rules.min_bytes]) : ''"
  }];

  // `max_bytes` specifies that the field value must have no more than the
  //specified number of bytes. If the field value contains more bytes, an
  // error message will be generated.
  //
  // ```proto
  // message MyString {
  //   // value length must be at most 8 bytes
  //   string value = 1 [(buf.validate.field).string.max_bytes = 8];
  // }
  // ```
  optional uint64 max_bytes = 5 [(predefined).cel = {
    id: "string.max_bytes"
    expression: "uint(bytes(this).size()) > rules.max_bytes ? 'value length must be at most %s bytes'.format([rules.max_bytes]) : ''"
  }];

  // `pattern` specifies that the field value must match the specified
  // regular expression (RE2 syntax), with the expression provided without any
  // delimiters. If the field value doesn't match the regular expression, an
  // error message will be generated.
  //
  // ```proto
  // message MyString {
  //   // value does not match regex pattern `^[a-zA-Z]//$`
  //   string value = 1 [(buf.validate.field).string.pattern = "^[a-zA-Z]//$"];
  // }
  // ```
  optional string pattern = 6 [(predefined).cel = {
    id: "string.pattern"
    expression: "!this.matches(rules.pattern) ? 'value does not match regex pattern `%s`'.format([rules.pattern]) : ''"
  }];

  // `prefix` specifies that the field value must have the
  //specified substring at the beginning of the string. If the field value
  // doesn't start with the specified prefix, an error message will be
  // generated.
  //
  // ```proto
  // message MyString {
  //   // value does not have prefix `pre`
  //   string value = 1 [(buf.validate.field).string.prefix = "pre"];
  // }
  // ```
  optional string prefix = 7 [(predefined).cel = {
    id: "string.prefix"
    expression: "!this.startsWith(rules.prefix) ? 'value does not have prefix `%s`'.format([rules.prefix]) : ''"
  }];

  // `suffix` specifies that the field value must have the
  //specified substring at the end of the string. If the field value doesn't
  // end with the specified suffix, an error message will be generated.
  //
  // ```proto
  // message MyString {
  //   // value does not have suffix `post`
  //   string value = 1 [(buf.validate.field).string.suffix = "post"];
  // }
  // ```
  optional string suffix = 8 [(predefined).cel = {
    id: "string.suffix"
    expression: "!this.endsWith(rules.suffix) ? 'value does not have suffix `%s`'.format([rules.suffix]) : ''"
  }];

  // `contains` specifies that the field value must have the
  //specified substring anywhere in the string. If the field value doesn't
  // contain the specified substring, an error message will be generated.
  //
  // ```proto
  // message MyString {
  //   // value does not contain substring `inside`.
  //   string value = 1 [(buf.validate.field).string.contains = "inside"];
  // }
  // ```
  optional string contains = 9 [(predefined).cel = {
    id: "string.contains"
    expression: "!this.contains(rules.contains) ? 'value does not contain substring `%s`'.format([rules.contains]) : ''"
  }];

  // `not_contains` specifies that the field value must not have the
  //specified substring anywhere in the string. If the field value contains
  // the specified substring, an error message will be generated.
  //
  // ```proto
  // message MyString {
  //   // value contains substring `inside`.
  //   string value = 1 [(buf.validate.field).string.not_contains = "inside"];
  // }
  // ```
  optional string not_contains = 23 [(predefined).cel = {
    id: "string.not_contains"
    expression: "this.contains(rules.not_contains) ? 'value contains substring `%s`'.format([rules.not_contains]) : ''"
  }];

  // `in` specifies that the field value must be equal to one of the specified
  // values. If the field value isn't one of the specified values, an error
  // message will be generated.
  //
  // ```proto
  // message MyString {
  //   // value must be in list ["apple", "banana"]
  //   string value = 1 [(buf.validate.field).string.in = "apple", (buf.validate.field).string.in = "banana"];
  // }
  // ```
  repeated string in = 10 [(predefined).cel = {
    id: "string.in"
    expression: "!(this in getField(rules, 'in')) ? 'value must be in list %s'.format([getField(rules, 'in')]) : ''"
  }];

  // `not_in` specifies that the field value cannot be equal to any
  // of the specified values. If the field value is one of the specified values,
  // an error message will be generated.
  // ```proto
  // message MyString {
  //   // value must not be in list ["orange", "grape"]
  //   string value = 1 [(buf.validate.field).string.not_in = "orange", (buf.validate.field).string.not_in = "grape"];
  // }
  // ```
  repeated string not_in = 11 [(predefined).cel = {
    id: "string.not_in"
    expression: "this in rules.not_in ? 'value must not be in list %s'.format([rules.not_in]) : ''"
  }];

  // `WellKnown` rules provide advanced rules against common string
  // patterns.
  oneof well_known {
    // `email` specifies that the field value must be a valid email address, for
    // example "foo@example.com".
    //
    // Conforms to the definition for a valid email address from the [HTML standard](https://html.spec.whatwg.org/multipage/input.html#valid-e-mail-address).
    // Note that this standard willfully deviates from [RFC 5322](https://datatracker.ietf.org/doc/html/rfc5322),
    // which allows many unexpected forms of email addresses and will easily match
    // a typographical error.
    //
    // If the field value isn't a valid email address, an error message will be generated.
    //
    // ```proto
    // message MyString {
    //   // value must be a valid email address
    //   string value = 1 [(buf.validate.field).string.email = true];
    // }
    // ```
    bool email = 12 [
      (predefined).cel = {
        id: "string.email"
        message: "value must be a valid email address"
        expression: "!rules.email || this == '' || this.isEmail()"
      },
      (predefined).cel = {
        id: "string.email_empty"
        message: "value is empty, which is not a valid email address"
        expression: "!rules.email || this != ''"
      }
    ];

    // `hostname` specifies that the field value must be a valid hostname, for
    // example "foo.example.com".
    //
    // A valid hostname follows the rules below:
    // - The name consists of one or more labels, separated by a dot (".").
    // - Each label can be 1 to 63 alphanumeric characters.
    // - A label can contain hyphens ("-"), but must not start or end with a hyphen.
    // - The right-most label must not be digits only.
    // - The name can have a trailing dotfor example, "foo.example.com.".
    // - The name can be 253 characters at most, excluding the optional trailing dot.
    //
    // If the field value isn't a valid hostname, an error message will be generated.
    //
    // ```proto
    // message MyString {
    //   // value must be a valid hostname
    //   string value = 1 [(buf.validate.field).string.hostname = true];
    // }
    // ```
    bool hostname = 13 [
      (predefined).cel = {
        id: "string.hostname"
        message: "value must be a valid hostname"
        expression: "!rules.hostname || this == '' || this.isHostname()"
      },
      (predefined).cel = {
        id: "string.hostname_empty"
        message: "value is empty, which is not a valid hostname"
        expression: "!rules.hostname || this != ''"
      }
    ];

    // `ip` specifies that the field value must be a valid IP (v4 or v6) address.
    //
    // IPv4 addresses are expected in the dotted decimal formatfor example, "192.168.5.21".
    // IPv6 addresses are expected in their text representationfor example, "::1",
    // or "2001:0DB8:ABCD:0012::0".
    //
    // Both formats are well-defined in the internet standard [RFC 3986](https://datatracker.ietf.org/doc/html/rfc3986).
    // Zone identifiers for IPv6 addresses (for example, "fe80::a%en1") are supported.
    //
    // If the field value isn't a valid IP address, an error message will be
    // generated.
    //
    // ```proto
    // message MyString {
    //   // value must be a valid IP address
    //   string value = 1 [(buf.validate.field).string.ip = true];
    // }
    // ```
    bool ip = 14 [
      (predefined).cel = {
        id: "string.ip"
        message: "value must be a valid IP address"
        expression: "!rules.ip || this == '' || this.isIp()"
      },
      (predefined).cel = {
        id: "string.ip_empty"
        message: "value is empty, which is not a valid IP address"
        expression: "!rules.ip || this != ''"
      }
    ];

    // `ipv4` specifies that the field value must be a valid IPv4 addressfor
    // example "192.168.5.21". If the field value isn't a valid IPv4 address, an
    // error message will be generated.
    //
    // ```proto
    // message MyString {
    //   // value must be a valid IPv4 address
    //   string value = 1 [(buf.validate.field).string.ipv4 = true];
    // }
    // ```
    bool ipv4 = 15 [
      (predefined).cel = {
        id: "string.ipv4"
        message: "value must be a valid IPv4 address"
        expression: "!rules.ipv4 || this == '' || this.isIp(4)"
      },
      (predefined).cel = {
        id: "string.ipv4_empty"
        message: "value is empty, which is not a valid IPv4 address"
        expression: "!rules.ipv4 || this != ''"
      }
    ];

    // `ipv6` specifies that the field value must be a valid IPv6 addressfor
    // example "::1", or "d7a:115c:a1e0:ab12:4843:cd96:626b:430b". If the field
    // value is not a valid IPv6 address, an error message will be generated.
    //
    // ```proto
    // message MyString {
    //   // value must be a valid IPv6 address
    //   string value = 1 [(buf.validate.field).string.ipv6 = true];
    // }
    // ```
    bool ipv6 = 16 [
      (predefined).cel = {
        id: "string.ipv6"
        message: "value must be a valid IPv6 address"
        expression: "!rules.ipv6 || this == '' || this.isIp(6)"
      },
      (predefined).cel = {
        id: "string.ipv6_empty"
        message: "value is empty, which is not a valid IPv6 address"
        expression: "!rules.ipv6 || this != ''"
      }
    ];

    // `uri` specifies that the field value must be a valid URI, for example
    // "https://example.com/foo/bar?baz=quux#frag".
    //
    // URI is defined in the internet standard [RFC 3986](https://datatracker.ietf.org/doc/html/rfc3986).
    // Zone Identifiers in IPv6 address literals are supported ([RFC 6874](https://datatracker.ietf.org/doc/html/rfc6874)).
    //
    // If the field value isn't a valid URI, an error message will be generated.
    //
    // ```proto
    // message MyString {
    //   // value must be a valid URI
    //   string value = 1 [(buf.validate.field).string.uri = true];
    // }
    // ```
    bool uri = 17 [
      (predefined).cel = {
        id: "string.uri"
        message: "value must be a valid URI"
        expression: "!rules.uri || this == '' || this.isUri()"
      },
      (predefined).cel = {
        id: "string.uri_empty"
        message: "value is empty, which is not a valid URI"
        expression: "!rules.uri || this != ''"
      }
    ];

    // `uri_ref` specifies that the field value must be a valid URI Referenceeither
    // a URI such as "https://example.com/foo/bar?baz=quux#frag", or a Relative
    // Reference such as "./foo/bar?query".
    //
    // URI, URI Reference, and Relative Reference are defined in the internet
    // standard [RFC 3986](https://datatracker.ietf.org/doc/html/rfc3986). Zone
    // Identifiers in IPv6 address literals are supported ([RFC 6874](https://datatracker.ietf.org/doc/html/rfc6874)).
    //
    // If the field value isn't a valid URI Reference, an error message will be
    // generated.
    //
    // ```proto
    // message MyString {
    //   // value must be a valid URI Reference
    //   string value = 1 [(buf.validate.field).string.uri_ref = true];
    // }
    // ```
    bool uri_ref = 18 [(predefined).cel = {
      id: "string.uri_ref"
      message: "value must be a valid URI Reference"
      expression: "!rules.uri_ref || this.isUriRef()"
    }];

    // `address` specifies that the field value must be either a valid hostname
    // (for example, "example.com"), or a valid IP (v4 or v6) address (for example,
    // "192.168.0.1", or "::1"). If the field value isn't a valid hostname or IP,
    // an error message will be generated.
    //
    // ```proto
    // message MyString {
    //   // value must be a valid hostname, or ip address
    //   string value = 1 [(buf.validate.field).string.address = true];
    // }
    // ```
    bool address = 21 [
      (predefined).cel = {
        id: "string.address"
        message: "value must be a valid hostname, or ip address"
        expression: "!rules.address || this == '' || this.isHostname() || this.isIp()"
      },
      (predefined).cel = {
        id: "string.address_empty"
        message: "value is empty, which is not a valid hostname, or ip address"
        expression: "!rules.address || this != ''"
      }
    ];

    // `uuid` specifies that the field value must be a valid UUID as defined by
    // [RFC 4122](https://datatracker.ietf.org/doc/html/rfc4122#section-4.1.2). If the
    // field value isn't a valid UUID, an error message will be generated.
    //
    // ```proto
    // message MyString {
    //   // value must be a valid UUID
    //   string value = 1 [(buf.validate.field).string.uuid = true];
    // }
    // ```
    bool uuid = 22 [
      (predefined).cel = {
        id: "string.uuid"
        message: "value must be a valid UUID"
        expression: "!rules.uuid || this == '' || this.matches('^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$')"
      },
      (predefined).cel = {
        id: "string.uuid_empty"
        message: "value is empty, which is not a valid UUID"
        expression: "!rules.uuid || this != ''"
      }
    ];

    // `tuuid` (trimmed UUID) specifies that the field value must be a valid UUID as
    // defined by [RFC 4122](https://datatracker.ietf.org/doc/html/rfc4122#section-4.1.2) with all dashes
    // omitted. If the field value isn't a valid UUID without dashes, an error message
    // will be generated.
    //
    // ```proto
    // message MyString {
    //   // value must be a valid trimmed UUID
    //   string value = 1 [(buf.validate.field).string.tuuid = true];
    // }
    // ```
    bool tuuid = 33 [
      (predefined).cel = {
        id: "string.tuuid"
        message: "value must be a valid trimmed UUID"
        expression: "!rules.tuuid || this == '' || this.matches('^[0-9a-fA-F]{32}$')"
      },
      (predefined).cel = {
        id: "string.tuuid_empty"
        message: "value is empty, which is not a valid trimmed UUID"
        expression: "!rules.tuuid || this != ''"
      }
    ];

    // `ip_with_prefixlen` specifies that the field value must be a valid IP
    // (v4 or v6) address with prefix lengthfor example, "192.168.5.21/16" or
    // "2001:0DB8:ABCD:0012::F1/64". If the field value isn't a valid IP with
    // prefix length, an error message will be generated.
    //
    // ```proto
    // message MyString {
    //   // value must be a valid IP with prefix length
    //    string value = 1 [(buf.validate.field).string.ip_with_prefixlen = true];
    // }
    // ```
    bool ip_with_prefixlen = 26 [
      (predefined).cel = {
        id: "string.ip_with_prefixlen"
        message: "value must be a valid IP prefix"
        expression: "!rules.ip_with_prefixlen || this == '' || this.isIpPrefix()"
      },
      (predefined).cel = {
        id: "string.ip_with_prefixlen_empty"
        message: "value is empty, which is not a valid IP prefix"
        expression: "!rules.ip_with_prefixlen || this != ''"
      }
    ];

    // `ipv4_with_prefixlen` specifies that the field value must be a valid
    // IPv4 address with prefix lengthfor example, "192.168.5.21/16". If the
    // field value isn't a valid IPv4 address with prefix length, an error
    // message will be generated.
    //
    // ```proto
    // message MyString {
    //   // value must be a valid IPv4 address with prefix length
    //    string value = 1 [(buf.validate.field).string.ipv4_with_prefixlen = true];
    // }
    // ```
    bool ipv4_with_prefixlen = 27 [
      (predefined).cel = {
        id: "string.ipv4_with_prefixlen"
        message: "value must be a valid IPv4 address with prefix length"
        expression: "!rules.ipv4_with_prefixlen || this == '' || this.isIpPrefix(4)"
      },
      (predefined).cel = {
        id: "string.ipv4_with_prefixlen_empty"
        message: "value is empty, which is not a valid IPv4 address with prefix length"
        expression: "!rules.ipv4_with_prefixlen || this != ''"
      }
    ];

    // `ipv6_with_prefixlen` specifies that the field value must be a valid
    // IPv6 address with prefix lengthfor example, "2001:0DB8:ABCD:0012::F1/64".
    // If the field value is not a valid IPv6 address with prefix length,
    // an error message will be generated.
    //
    // ```proto
    // message MyString {
    //   // value must be a valid IPv6 address prefix length
    //    string value = 1 [(buf.validate.field).string.ipv6_with_prefixlen = true];
    // }
    // ```
    bool ipv6_with_prefixlen = 28 [
      (predefined).cel = {
        id: "string.ipv6_with_prefixlen"
        message: "value must be a valid IPv6 address with prefix length"
        expression: "!rules.ipv6_with_prefixlen || this == '' || this.isIpPrefix(6)"
      },
      (predefined).cel = {
        id: "string.ipv6_with_prefixlen_empty"
        message: "value is empty, which is not a valid IPv6 address with prefix length"
        expression: "!rules.ipv6_with_prefixlen || this != ''"
      }
    ];

    // `ip_prefix` specifies that the field value must be a valid IP (v4 or v6)
    // prefixfor example, "192.168.0.0/16" or "2001:0DB8:ABCD:0012::0/64".
    //
    // The prefix must have all zeros for the unmasked bits. For example,
    // "2001:0DB8:ABCD:0012::0/64" designates the left-most 64 bits for the
    // prefix, and the remaining 64 bits must be zero.
    //
    // If the field value isn't a valid IP prefix, an error message will be
    // generated.
    //
    // ```proto
    // message MyString {
    //   // value must be a valid IP prefix
    //    string value = 1 [(buf.validate.field).string.ip_prefix = true];
    // }
    // ```
    bool ip_prefix = 29 [
      (predefined).cel = {
        id: "string.ip_prefix"
        message: "value must be a valid IP prefix"
        expression: "!rules.ip_prefix || this == '' || this.isIpPrefix(true)"
      },
      (predefined).cel = {
        id: "string.ip_prefix_empty"
        message: "value is empty, which is not a valid IP prefix"
        expression: "!rules.ip_prefix || this != ''"
      }
    ];

    // `ipv4_prefix` specifies that the field value must be a valid IPv4
    // prefix, for example "192.168.0.0/16".
    //
    // The prefix must have all zeros for the unmasked bits. For example,
    // "192.168.0.0/16" designates the left-most 16 bits for the prefix,
    // and the remaining 16 bits must be zero.
    //
    // If the field value isn't a valid IPv4 prefix, an error message
    // will be generated.
    //
    // ```proto
    // message MyString {
    //   // value must be a valid IPv4 prefix
    //    string value = 1 [(buf.validate.field).string.ipv4_prefix = true];
    // }
    // ```
    bool ipv4_prefix = 30 [
      (predefined).cel = {
        id: "string.ipv4_prefix"
        message: "value must be a valid IPv4 prefix"
        expression: "!rules.ipv4_prefix || this == '' || this.isIpPrefix(4, true)"
      },
      (predefined).cel = {
        id: "string.ipv4_prefix_empty"
        message: "value is empty, which is not a valid IPv4 prefix"
        expression: "!rules.ipv4_prefix || this != ''"
      }
    ];

    // `ipv6_prefix` specifies that the field value must be a valid IPv6 prefixfor
    // example, "2001:0DB8:ABCD:0012::0/64".
    //
    // The prefix must have all zeros for the unmasked bits. For example,
    // "2001:0DB8:ABCD:0012::0/64" designates the left-most 64 bits for the
    // prefix, and the remaining 64 bits must be zero.
    //
    // If the field value is not a valid IPv6 prefix, an error message will be
    // generated.
    //
    // ```proto
    // message MyString {
    //   // value must be a valid IPv6 prefix
    //    string value = 1 [(buf.validate.field).string.ipv6_prefix = true];
    // }
    // ```
    bool ipv6_prefix = 31 [
      (predefined).cel = {
        id: "string.ipv6_prefix"
        message: "value must be a valid IPv6 prefix"
        expression: "!rules.ipv6_prefix || this == '' || this.isIpPrefix(6, true)"
      },
      (predefined).cel = {
        id: "string.ipv6_prefix_empty"
        message: "value is empty, which is not a valid IPv6 prefix"
        expression: "!rules.ipv6_prefix || this != ''"
      }
    ];

    // `host_and_port` specifies that the field value must be valid host/port
    // pairfor example, "example.com:8080".
    //
    // The host can be one of:
    //- An IPv4 address in dotted decimal formatfor example, "192.168.5.21".
    //- An IPv6 address enclosed in square bracketsfor example, "[2001:0DB8:ABCD:0012::F1]".
    //- A hostnamefor example, "example.com".
    //
    // The port is separated by a colon. It must be non-empty, with a decimal number
    // in the range of 0-65535, inclusive.
    bool host_and_port = 32 [
      (predefined).cel = {
        id: "string.host_and_port"
        message: "value must be a valid host (hostname or IP address) and port pair"
        expression: "!rules.host_and_port || this == '' || this.isHostAndPort(true)"
      },
      (predefined).cel = {
        id: "string.host_and_port_empty"
        message: "value is empty, which is not a valid host and port pair"
        expression: "!rules.host_and_port || this != ''"
      }
    ];

    // `ulid` specifies that the field value must be a valid ULID (Universally Unique
    // Lexicographically Sortable Identifier) as defined by the [ULID specification](https://github.com/ulid/spec).
    // If the field value isn't a valid ULID, an error message will be generated.
    //
    // ```proto
    // message MyString {
    //   // value must be a valid ULID
    //   string value = 1 [(buf.validate.field).string.ulid = true];
    // }
    // ```
    bool ulid = 35 [
      (predefined).cel = {
        id: "string.ulid"
        message: "value must be a valid ULID"
        expression: "!rules.ulid || this == '' || this.matches('^[0-7][0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{25}$')"
      },
      (predefined).cel = {
        id: "string.ulid_empty"
        message: "value is empty, which is not a valid ULID"
        expression: "!rules.ulid || this != ''"
      }
    ];

    // `well_known_regex` specifies a common well-known pattern
    // defined as a regex. If the field value doesn't match the well-known
    // regex, an error message will be generated.
    //
    // ```proto
    // message MyString {
    //   // value must be a valid HTTP header value
    //   string value = 1 [(buf.validate.field).string.well_known_regex = KNOWN_REGEX_HTTP_HEADER_VALUE];
    // }
    // ```
    //
    // #### KnownRegex
    //
    // `well_known_regex` contains some well-known patterns.
    //
    // | Name                          | Number | Description                               |
    // |-------------------------------|--------|-------------------------------------------|
    // | KNOWN_REGEX_UNSPECIFIED       | 0      |                                           |
    // | KNOWN_REGEX_HTTP_HEADER_NAME  | 1      | HTTP header name as defined by [RFC 7230](https://datatracker.ietf.org/doc/html/rfc7230#section-3.2)  |
    // | KNOWN_REGEX_HTTP_HEADER_VALUE | 2      | HTTP header value as defined by [RFC 7230](https://datatracker.ietf.org/doc/html/rfc7230#section-3.2.4) |
    KnownRegex well_known_regex = 24 [
      (predefined).cel = {
        id: "string.well_known_regex.header_name"
        message: "value must be a valid HTTP header name"
        expression:
          "rules.well_known_regex != 1 || this == '' || this.matches(!has(rules.strict) || rules.strict ?"
          "'^:?[0-9a-zA-Z!#$%&\\'*+-.^_|~\\x60]+$' :"
          "'^[^\\u0000\\u000A\\u000D]+$')"
      },
      (predefined).cel = {
        id: "string.well_known_regex.header_name_empty"
        message: "value is empty, which is not a valid HTTP header name"
        expression: "rules.well_known_regex != 1 || this != ''"
      },
      (predefined).cel = {
        id: "string.well_known_regex.header_value"
        message: "value must be a valid HTTP header value"
        expression:
          "rules.well_known_regex != 2 || this.matches(!has(rules.strict) || rules.strict ?"
          "'^[^\\u0000-\\u0008\\u000A-\\u001F\\u007F]*$' :"
          "'^[^\\u0000\\u000A\\u000D]*$')"
      }
    ];
  }

  // This applies to regexes `HTTP_HEADER_NAME` and `HTTP_HEADER_VALUE` to
  // enable strict header validation. By default, this is true, and HTTP header
  // validations are [RFC-compliant](https://datatracker.ietf.org/doc/html/rfc7230#section-3). Setting to false will enable looser
  // validations that only disallow `\r\n\0` characters, which can be used to
  // bypass header matching rules.
  //
  // ```proto
  // message MyString {
  //   // The field `value` must have be a valid HTTP headers, but not enforced with strict rules.
  //   string value = 1 [(buf.validate.field).string.strict = false];
  // }
  // ```
  optional bool strict = 25;

  // `example` specifies values that the field may have. These values SHOULD
  // conform to other rules. `example` values will not impact validation
  // but may be used as helpful guidance on how to populate the given field.
  //
  // ```proto
  // message MyString {
  //   string value = 1 [
  //     (buf.validate.field).string.example = "hello",
  //     (buf.validate.field).string.example = "world"
  //   ];
  // }
  // ```
  repeated string example = 34 [(predefined).cel = {
    id: "string.example"
    expression: "true"
  }];

  // Extension fields in this range that have the (buf.validate.predefined)
  // option set will be treated as predefined field rules that can then be
  // set on the field options of other fields to apply field rules.
  // Extension numbers 1000 to 99999 are reserved for extension numbers that are
  // defined in the [Protobuf Global Extension Registry][1]. Extension numbers
  // above this range are reserved for extension numbers that are not explicitly
  // assigned. For rules defined in publicly-consumed schemas, use of extensions
  // above 99999 is discouraged due to the risk of conflicts.
  //
  // [1]: https://github.com/protocolbuffers/protobuf/blob/main/docs/options.md
  extensions 1000 to max;
}

// KnownRegex contains some well-known patterns.
enum KnownRegex {
  KNOWN_REGEX_UNSPECIFIED = 0;

  // HTTP header name as defined by [RFC 7230](https://datatracker.ietf.org/doc/html/rfc7230#section-3.2).
  KNOWN_REGEX_HTTP_HEADER_NAME = 1;

  // HTTP header value as defined by [RFC 7230](https://datatracker.ietf.org/doc/html/rfc7230#section-3.2.4).
  KNOWN_REGEX_HTTP_HEADER_VALUE = 2;
}

// BytesRules describe the rules applied to `bytes` values. These rules
// may also be applied to the `google.protobuf.BytesValue` Well-Known-Type.
message BytesRules {
  // `const` requires the field value to exactly match the specified bytes
  // value. If the field value doesn't match, an error message is generated.
  //
  // ```proto
  // message MyBytes {
  //   // value must be "\x01\x02\x03\x04"
  //   bytes value = 1 [(buf.validate.field).bytes.const = "\x01\x02\x03\x04"];
  // }
  // ```
  optional bytes const = 1 [(predefined).cel = {
    id: "bytes.const"
    expression: "this != getField(rules, 'const') ? 'value must be %x'.format([getField(rules, 'const')]) : ''"
  }];

  // `len` requires the field value to have the specified length in bytes.
  // If the field value doesn't match, an error message is generated.
  //
  // ```proto
  // message MyBytes {
  //   // value length must be 4 bytes.
  //   optional bytes value = 1 [(buf.validate.field).bytes.len = 4];
  // }
  // ```
  optional uint64 len = 13 [(predefined).cel = {
    id: "bytes.len"
    expression: "uint(this.size()) != rules.len ? 'value length must be %s bytes'.format([rules.len]) : ''"
  }];

  // `min_len` requires the field value to have at least the specified minimum
  // length in bytes.
  // If the field value doesn't meet the requirement, an error message is generated.
  //
  // ```proto
  // message MyBytes {
  //   // value length must be at least 2 bytes.
  //   optional bytes value = 1 [(buf.validate.field).bytes.min_len = 2];
  // }
  // ```
  optional uint64 min_len = 2 [(predefined).cel = {
    id: "bytes.min_len"
    expression: "uint(this.size()) < rules.min_len ? 'value length must be at least %s bytes'.format([rules.min_len]) : ''"
  }];

  // `max_len` requires the field value to have at most the specified maximum
  // length in bytes.
  // If the field value exceeds the requirement, an error message is generated.
  //
  // ```proto
  // message MyBytes {
  //   // value must be at most 6 bytes.
  //   optional bytes value = 1 [(buf.validate.field).bytes.max_len = 6];
  // }
  // ```
  optional uint64 max_len = 3 [(predefined).cel = {
    id: "bytes.max_len"
    expression: "uint(this.size()) > rules.max_len ? 'value must be at most %s bytes'.format([rules.max_len]) : ''"
  }];

  // `pattern` requires the field value to match the specified regular
  // expression ([RE2 syntax](https://github.com/google/re2/wiki/Syntax)).
  // The value of the field must be valid UTF-8 or validation will fail with a
  // runtime error.
  // If the field value doesn't match the pattern, an error message is generated.
  //
  // ```proto
  // message MyBytes {
  //   // value must match regex pattern "^[a-zA-Z0-9]+$".
  //   optional bytes value = 1 [(buf.validate.field).bytes.pattern = "^[a-zA-Z0-9]+$"];
  // }
  // ```
  optional string pattern = 4 [(predefined).cel = {
    id: "bytes.pattern"
    expression: "!string(this).matches(rules.pattern) ? 'value must match regex pattern `%s`'.format([rules.pattern]) : ''"
  }];

  // `prefix` requires the field value to have the specified bytes at the
  // beginning of the string.
  // If the field value doesn't meet the requirement, an error message is generated.
  //
  // ```proto
  // message MyBytes {
  //   // value does not have prefix \x01\x02
  //   optional bytes value = 1 [(buf.validate.field).bytes.prefix = "\x01\x02"];
  // }
  // ```
  optional bytes prefix = 5 [(predefined).cel = {
    id: "bytes.prefix"
    expression: "!this.startsWith(rules.prefix) ? 'value does not have prefix %x'.format([rules.prefix]) : ''"
  }];

  // `suffix` requires the field value to have the specified bytes at the end
  // of the string.
  // If the field value doesn't meet the requirement, an error message is generated.
  //
  // ```proto
  // message MyBytes {
  //   // value does not have suffix \x03\x04
  //   optional bytes value = 1 [(buf.validate.field).bytes.suffix = "\x03\x04"];
  // }
  // ```
  optional bytes suffix = 6 [(predefined).cel = {
    id: "bytes.suffix"
    expression: "!this.endsWith(rules.suffix) ? 'value does not have suffix %x'.format([rules.suffix]) : ''"
  }];

  // `contains` requires the field value to have the specified bytes anywhere in
  // the string.
  // If the field value doesn't meet the requirement, an error message is generated.
  //
  // ```proto
  // message MyBytes {
  //   // value does not contain \x02\x03
  //   optional bytes value = 1 [(buf.validate.field).bytes.contains = "\x02\x03"];
  // }
  // ```
  optional bytes contains = 7 [(predefined).cel = {
    id: "bytes.contains"
    expression: "!this.contains(rules.contains) ? 'value does not contain %x'.format([rules.contains]) : ''"
  }];

  // `in` requires the field value to be equal to one of the specified
  // values. If the field value doesn't match any of the specified values, an
  // error message is generated.
  //
  // ```proto
  // message MyBytes {
  //   // value must in ["\x01\x02", "\x02\x03", "\x03\x04"]
  //   optional bytes value = 1 [(buf.validate.field).bytes.in = {"\x01\x02", "\x02\x03", "\x03\x04"}];
  // }
  // ```
  repeated bytes in = 8 [(predefined).cel = {
    id: "bytes.in"
    expression: "getField(rules, 'in').size() > 0 && !(this in getField(rules, 'in')) ? 'value must be in list %s'.format([getField(rules, 'in')]) : ''"
  }];

  // `not_in` requires the field value to be not equal to any of the specified
  // values.
  // If the field value matches any of the specified values, an error message is
  // generated.
  //
  // ```proto
  // message MyBytes {
  //   // value must not in ["\x01\x02", "\x02\x03", "\x03\x04"]
  //   optional bytes value = 1 [(buf.validate.field).bytes.not_in = {"\x01\x02", "\x02\x03", "\x03\x04"}];
  // }
  // ```
  repeated bytes not_in = 9 [(predefined).cel = {
    id: "bytes.not_in"
    expression: "this in rules.not_in ? 'value must not be in list %s'.format([rules.not_in]) : ''"
  }];

  // WellKnown rules provide advanced rules against common byte
  // patterns
  oneof well_known {
    // `ip` ensures that the field `value` is a valid IP address (v4 or v6) in byte format.
    // If the field value doesn't meet this rule, an error message is generated.
    //
    // ```proto
    // message MyBytes {
    //   // value must be a valid IP address
    //   optional bytes value = 1 [(buf.validate.field).bytes.ip = true];
    // }
    // ```
    bool ip = 10 [
      (predefined).cel = {
        id: "bytes.ip"
        message: "value must be a valid IP address"
        expression: "!rules.ip || this.size() == 0 || this.size() == 4 || this.size() == 16"
      },
      (predefined).cel = {
        id: "bytes.ip_empty"
        message: "value is empty, which is not a valid IP address"
        expression: "!rules.ip || this.size() != 0"
      }
    ];

    // `ipv4` ensures that the field `value` is a valid IPv4 address in byte format.
    // If the field value doesn't meet this rule, an error message is generated.
    //
    // ```proto
    // message MyBytes {
    //   // value must be a valid IPv4 address
    //   optional bytes value = 1 [(buf.validate.field).bytes.ipv4 = true];
    // }
    // ```
    bool ipv4 = 11 [
      (predefined).cel = {
        id: "bytes.ipv4"
        message: "value must be a valid IPv4 address"
        expression: "!rules.ipv4 || this.size() == 0 || this.size() == 4"
      },
      (predefined).cel = {
        id: "bytes.ipv4_empty"
        message: "value is empty, which is not a valid IPv4 address"
        expression: "!rules.ipv4 || this.size() != 0"
      }
    ];

    // `ipv6` ensures that the field `value` is a valid IPv6 address in byte format.
    // If the field value doesn't meet this rule, an error message is generated.
    // ```proto
    // message MyBytes {
    //   // value must be a valid IPv6 address
    //   optional bytes value = 1 [(buf.validate.field).bytes.ipv6 = true];
    // }
    // ```
    bool ipv6 = 12 [
      (predefined).cel = {
        id: "bytes.ipv6"
        message: "value must be a valid IPv6 address"
        expression: "!rules.ipv6 || this.size() == 0 || this.size() == 16"
      },
      (predefined).cel = {
        id: "bytes.ipv6_empty"
        message: "value is empty, which is not a valid IPv6 address"
        expression: "!rules.ipv6 || this.size() != 0"
      }
    ];

    // `uuid` ensures that the field `value` encodes the 128-bit UUID data as
    // defined by [RFC 4122](https://datatracker.ietf.org/doc/html/rfc4122#section-4.1.2).
    // The field must contain exactly 16 bytes
    // representing the UUID. If the field value isn't a valid UUID, an error
    // message will be generated.
    //
    // ```proto
    // message MyBytes {
    //   // value must be a valid UUID
    //   optional bytes value = 1 [(buf.validate.field).bytes.uuid = true];
    // }
    // ```
    bool uuid = 15 [
      (predefined).cel = {
        id: "bytes.uuid"
        message: "value must be a valid UUID"
        expression: "!rules.uuid || this.size() == 0 || this.size() == 16"
      },
      (predefined).cel = {
        id: "bytes.uuid_empty"
        message: "value is empty, which is not a valid UUID"
        expression: "!rules.uuid || this.size() != 0"
      }
    ];
  }

  // `example` specifies values that the field may have. These values SHOULD
  // conform to other rules. `example` values will not impact validation
  // but may be used as helpful guidance on how to populate the given field.
  //
  // ```proto
  // message MyBytes {
  //   bytes value = 1 [
  //     (buf.validate.field).bytes.example = "\x01\x02",
  //     (buf.validate.field).bytes.example = "\x02\x03"
  //   ];
  // }
  // ```
  repeated bytes example = 14 [(predefined).cel = {
    id: "bytes.example"
    expression: "true"
  }];

  // Extension fields in this range that have the (buf.validate.predefined)
  // option set will be treated as predefined field rules that can then be
  // set on the field options of other fields to apply field rules.
  // Extension numbers 1000 to 99999 are reserved for extension numbers that are
  // defined in the [Protobuf Global Extension Registry][1]. Extension numbers
  // above this range are reserved for extension numbers that are not explicitly
  // assigned. For rules defined in publicly-consumed schemas, use of extensions
  // above 99999 is discouraged due to the risk of conflicts.
  //
  // [1]: https://github.com/protocolbuffers/protobuf/blob/main/docs/options.md
  extensions 1000 to max;
}

// EnumRules describe the rules applied to `enum` values.
message EnumRules {
  // `const` requires the field value to exactly match the specified enum value.
  // If the field value doesn't match, an error message is generated.
  //
  // ```proto
  // enum MyEnum {
  //   MY_ENUM_UNSPECIFIED = 0;
  //   MY_ENUM_VALUE1 = 1;
  //   MY_ENUM_VALUE2 = 2;
  // }
  //
  // message MyMessage {
  //   // The field `value` must be exactly MY_ENUM_VALUE1.
  //   MyEnum value = 1 [(buf.validate.field).enum.const = 1];
  // }
  // ```
  optional int32 const = 1 [(predefined).cel = {
    id: "enum.const"
    expression: "this != getField(rules, 'const') ? 'value must equal %s'.format([getField(rules, 'const')]) : ''"
  }];

  // `defined_only` requires the field value to be one of the defined values for
  // this enum, failing on any undefined value.
  //
  // ```proto
  // enum MyEnum {
  //   MY_ENUM_UNSPECIFIED = 0;
  //   MY_ENUM_VALUE1 = 1;
  //   MY_ENUM_VALUE2 = 2;
  // }
  //
  // message MyMessage {
  //   // The field `value` must be a defined value of MyEnum.
  //   MyEnum value = 1 [(buf.validate.field).enum.defined_only = true];
  // }
  // ```
  optional bool defined_only = 2;

  // `in` requires the field value to be equal to one of the
  //specified enum values. If the field value doesn't match any of the
  //specified values, an error message is generated.
  //
  // ```proto
  // enum MyEnum {
  //   MY_ENUM_UNSPECIFIED = 0;
  //   MY_ENUM_VALUE1 = 1;
  //   MY_ENUM_VALUE2 = 2;
  // }
  //
  // message MyMessage {
  //   // The field `value` must be equal to one of the specified values.
  //   MyEnum value = 1 [(buf.validate.field).enum = { in: [1, 2]}];
  // }
  // ```
  repeated int32 in = 3 [(predefined).cel = {
    id: "enum.in"
    expression: "!(this in getField(rules, 'in')) ? 'value must be in list %s'.format([getField(rules, 'in')]) : ''"
  }];

  // `not_in` requires the field value to be not equal to any of the
  //specified enum values. If the field value matches one of the specified
  // values, an error message is generated.
  //
  // ```proto
  // enum MyEnum {
  //   MY_ENUM_UNSPECIFIED = 0;
  //   MY_ENUM_VALUE1 = 1;
  //   MY_ENUM_VALUE2 = 2;
  // }
  //
  // message MyMessage {
  //   // The field `value` must not be equal to any of the specified values.
  //   MyEnum value = 1 [(buf.validate.field).enum = { not_in: [1, 2]}];
  // }
  // ```
  repeated int32 not_in = 4 [(predefined).cel = {
    id: "enum.not_in"
    expression: "this in rules.not_in ? 'value must not be in list %s'.format([rules.not_in]) : ''"
  }];

  // `example` specifies values that the field may have. These values SHOULD
  // conform to other rules. `example` values will not impact validation
  // but may be used as helpful guidance on how to populate the given field.
  //
  // ```proto
  // enum MyEnum {
  //   MY_ENUM_UNSPECIFIED = 0;
  //   MY_ENUM_VALUE1 = 1;
  //   MY_ENUM_VALUE2 = 2;
  // }
  //
  // message MyMessage {
  //     (buf.validate.field).enum.example = 1,
  //     (buf.validate.field).enum.example = 2
  // }
  // ```
  repeated int32 example = 5 [(predefined).cel = {
    id: "enum.example"
    expression: "true"
  }];

  // Extension fields in this range that have the (buf.validate.predefined)
  // option set will be treated as predefined field rules that can then be
  // set on the field options of other fields to apply field rules.
  // Extension numbers 1000 to 99999 are reserved for extension numbers that are
  // defined in the [Protobuf Global Extension Registry][1]. Extension numbers
  // above this range are reserved for extension numbers that are not explicitly
  // assigned. For rules defined in publicly-consumed schemas, use of extensions
  // above 99999 is discouraged due to the risk of conflicts.
  //
  // [1]: https://github.com/protocolbuffers/protobuf/blob/main/docs/options.md
  extensions 1000 to max;
}

// RepeatedRules describe the rules applied to `repeated` values.
message RepeatedRules {
  // `min_items` requires that this field must contain at least the specified
  // minimum number of items.
  //
  // Note that `min_items = 1` is equivalent to setting a field as `required`.
  //
  // ```proto
  // message MyRepeated {
  //   // value must contain at least  2 items
  //   repeated string value = 1 [(buf.validate.field).repeated.min_items = 2];
  // }
  // ```
  optional uint64 min_items = 1 [(predefined).cel = {
    id: "repeated.min_items"
    expression: "uint(this.size()) < rules.min_items ? 'value must contain at least %d item(s)'.format([rules.min_items]) : ''"
  }];

  // `max_items` denotes that this field must not exceed a
  // certain number of items as the upper limit. If the field contains more
  // items than specified, an error message will be generated, requiring the
  // field to maintain no more than the specified number of items.
  //
  // ```proto
  // message MyRepeated {
  //   // value must contain no more than 3 item(s)
  //   repeated string value = 1 [(buf.validate.field).repeated.max_items = 3];
  // }
  // ```
  optional uint64 max_items = 2 [(predefined).cel = {
    id: "repeated.max_items"
    expression: "uint(this.size()) > rules.max_items ? 'value must contain no more than %s item(s)'.format([rules.max_items]) : ''"
  }];

  // `unique` indicates that all elements in this field must
  // be unique. This rule is strictly applicable to scalar and enum
  // types, with message types not being supported.
  //
  // ```proto
  // message MyRepeated {
  //   // repeated value must contain unique items
  //   repeated string value = 1 [(buf.validate.field).repeated.unique = true];
  // }
  // ```
  optional bool unique = 3 [(predefined).cel = {
    id: "repeated.unique"
    message: "repeated value must contain unique items"
    expression: "!rules.unique || this.unique()"
  }];

  // `items` details the rules to be applied to each item
  // in the field. Even for repeated message fields, validation is executed
  // against each item unless `ignore` is specified.
  //
  // ```proto
  // message MyRepeated {
  //   // The items in the field `value` must follow the specified rules.
  //   repeated string value = 1 [(buf.validate.field).repeated.items = {
  //     string: {
  //       min_len: 3
  //       max_len: 10
  //     }
  //   }];
  // }
  // ```
  //
  // Note that the `required` rule does not apply. Repeated items
  // cannot be unset.
  optional FieldRules items = 4;

  // Extension fields in this range that have the (buf.validate.predefined)
  // option set will be treated as predefined field rules that can then be
  // set on the field options of other fields to apply field rules.
  // Extension numbers 1000 to 99999 are reserved for extension numbers that are
  // defined in the [Protobuf Global Extension Registry][1]. Extension numbers
  // above this range are reserved for extension numbers that are not explicitly
  // assigned. For rules defined in publicly-consumed schemas, use of extensions
  // above 99999 is discouraged due to the risk of conflicts.
  //
  // [1]: https://github.com/protocolbuffers/protobuf/blob/main/docs/options.md
  extensions 1000 to max;
}

// MapRules describe the rules applied to `map` values.
message MapRules {
  // Specifies the minimum number of key-value pairs allowed. If the field has
  // fewer key-value pairs than specified, an error message is generated.
  //
  // ```proto
  // message MyMap {
  //   // The field `value` must have at least 2 key-value pairs.
  //   map<string, string> value = 1 [(buf.validate.field).map.min_pairs = 2];
  // }
  // ```
  optional uint64 min_pairs = 1 [(predefined).cel = {
    id: "map.min_pairs"
    expression: "uint(this.size()) < rules.min_pairs ? 'map must be at least %d entries'.format([rules.min_pairs]) : ''"
  }];

  // Specifies the maximum number of key-value pairs allowed. If the field has
  // more key-value pairs than specified, an error message is generated.
  //
  // ```proto
  // message MyMap {
  //   // The field `value` must have at most 3 key-value pairs.
  //   map<string, string> value = 1 [(buf.validate.field).map.max_pairs = 3];
  // }
  // ```
  optional uint64 max_pairs = 2 [(predefined).cel = {
    id: "map.max_pairs"
    expression: "uint(this.size()) > rules.max_pairs ? 'map must be at most %d entries'.format([rules.max_pairs]) : ''"
  }];

  // Specifies the rules to be applied to each key in the field.
  //
  // ```proto
  // message MyMap {
  //   // The keys in the field `value` must follow the specified rules.
  //   map<string, string> value = 1 [(buf.validate.field).map.keys = {
  //     string: {
  //       min_len: 3
  //       max_len: 10
  //     }
  //   }];
  // }
  // ```
  //
  // Note that the `required` rule does not apply. Map keys cannot be unset.
  optional FieldRules keys = 4;

  // Specifies the rules to be applied to the value of each key in the
  // field. Message values will still have their validations evaluated unless
  // `ignore` is specified.
  //
  // ```proto
  // message MyMap {
  //   // The values in the field `value` must follow the specified rules.
  //   map<string, string> value = 1 [(buf.validate.field).map.values = {
  //     string: {
  //       min_len: 5
  //       max_len: 20
  //     }
  //   }];
  // }
  // ```
  // Note that the `required` rule does not apply. Map values cannot be unset.
  optional FieldRules values = 5;

  // Extension fields in this range that have the (buf.validate.predefined)
  // option set will be treated as predefined field rules that can then be
  // set on the field options of other fields to apply field rules.
  // Extension numbers 1000 to 99999 are reserved for extension numbers that are
  // defined in the [Protobuf Global Extension Registry][1]. Extension numbers
  // above this range are reserved for extension numbers that are not explicitly
  // assigned. For rules defined in publicly-consumed schemas, use of extensions
  // above 99999 is discouraged due to the risk of conflicts.
  //
  // [1]: https://github.com/protocolbuffers/protobuf/blob/main/docs/options.md
  extensions 1000 to max;
}

// AnyRules describe rules applied exclusively to the `google.protobuf.Any` well-known type.
message AnyRules {
  // `in` requires the field's `type_url` to be equal to one of the
  //specified values. If it doesn't match any of the specified values, an error
  // message is generated.
  //
  // ```proto
  // message MyAny {
  //   //  The `value` field must have a `type_url` equal to one of the specified values.
  //   google.protobuf.Any value = 1 [(buf.validate.field).any = {
  //       in: ["type.googleapis.com/MyType1", "type.googleapis.com/MyType2"]
  //   }];
  // }
  // ```
  repeated string in = 2;

  // requires the field's type_url to be not equal to any of the specified values. If it matches any of the specified values, an error message is generated.
  //
  // ```proto
  // message MyAny {
  //   //  The `value` field must not have a `type_url` equal to any of the specified values.
  //   google.protobuf.Any value = 1 [(buf.validate.field).any = {
  //       not_in: ["type.googleapis.com/ForbiddenType1", "type.googleapis.com/ForbiddenType2"]
  //   }];
  // }
  // ```
  repeated string not_in = 3;
}

// DurationRules describe the rules applied exclusively to the `google.protobuf.Duration` well-known type.
message DurationRules {
  // `const` dictates that the field must match the specified value of the `google.protobuf.Duration` type exactly.
  // If the field's value deviates from the specified value, an error message
  // will be generated.
  //
  // ```proto
  // message MyDuration {
  //   // value must equal 5s
  //   google.protobuf.Duration value = 1 [(buf.validate.field).duration.const = "5s"];
  // }
  // ```
  optional google.protobuf.Duration const = 2 [(predefined).cel = {
    id: "duration.const"
    expression: "this != getField(rules, 'const') ? 'value must equal %s'.format([getField(rules, 'const')]) : ''"
  }];
  oneof less_than {
    // `lt` stipulates that the field must be less than the specified value of the `google.protobuf.Duration` type,
    // exclusive. If the field's value is greater than or equal to the specified
    // value, an error message will be generated.
    //
    // ```proto
    // message MyDuration {
    //   // value must be less than 5s
    //   google.protobuf.Duration value = 1 [(buf.validate.field).duration.lt = "5s"];
    // }
    // ```
    google.protobuf.Duration lt = 3 [(predefined).cel = {
      id: "duration.lt"
      expression:
        "!has(rules.gte) && !has(rules.gt) && this >= rules.lt"
        "? 'value must be less than %s'.format([rules.lt]) : ''"
    }];

    // `lte` indicates that the field must be less than or equal to the specified
    // value of the `google.protobuf.Duration` type, inclusive. If the field's value is greater than the specified value,
    // an error message will be generated.
    //
    // ```proto
    // message MyDuration {
    //   // value must be less than or equal to 10s
    //   google.protobuf.Duration value = 1 [(buf.validate.field).duration.lte = "10s"];
    // }
    // ```
    google.protobuf.Duration lte = 4 [(predefined).cel = {
      id: "duration.lte"
      expression:
        "!has(rules.gte) && !has(rules.gt) && this > rules.lte"
        "? 'value must be less than or equal to %s'.format([rules.lte]) : ''"
    }];
  }
  oneof greater_than {
    // `gt` requires the duration field value to be greater than the specified
    // value (exclusive). If the value of `gt` is larger than a specified `lt`
    // or `lte`, the range is reversed, and the field value must be outside the
    // specified range. If the field value doesn't meet the required conditions,
    // an error message is generated.
    //
    // ```proto
    // message MyDuration {
    //   // duration must be greater than 5s [duration.gt]
    //   google.protobuf.Duration value = 1 [(buf.validate.field).duration.gt = { seconds: 5 }];
    //
    //   // duration must be greater than 5s and less than 10s [duration.gt_lt]
    //   google.protobuf.Duration another_value = 2 [(buf.validate.field).duration = { gt: { seconds: 5 }, lt: { seconds: 10 } }];
    //
    //   // duration must be greater than 10s or less than 5s [duration.gt_lt_exclusive]
    //   google.protobuf.Duration other_value = 3 [(buf.validate.field).duration = { gt: { seconds: 10 }, lt: { seconds: 5 } }];
    // }
    // ```
    google.protobuf.Duration gt = 5 [
      (predefined).cel = {
        id: "duration.gt"
        expression:
          "!has(rules.lt) && !has(rules.lte) && this <= rules.gt"
          "? 'value must be greater than %s'.format([rules.gt]) : ''"
      },
      (predefined).cel = {
        id: "duration.gt_lt"
        expression:
          "has(rules.lt) && rules.lt >= rules.gt && (this >= rules.lt || this <= rules.gt)"
          "? 'value must be greater than %s and less than %s'.format([rules.gt, rules.lt]) : ''"
      },
      (predefined).cel = {
        id: "duration.gt_lt_exclusive"
        expression:
          "has(rules.lt) && rules.lt < rules.gt && (rules.lt <= this && this <= rules.gt)"
          "? 'value must be greater than %s or less than %s'.format([rules.gt, rules.lt]) : ''"
      },
      (predefined).cel = {
        id: "duration.gt_lte"
        expression:
          "has(rules.lte) && rules.lte >= rules.gt && (this > rules.lte || this <= rules.gt)"
          "? 'value must be greater than %s and less than or equal to %s'.format([rules.gt, rules.lte]) : ''"
      },
      (predefined).cel = {
        id: "duration.gt_lte_exclusive"
        expression:
          "has(rules.lte) && rules.lte < rules.gt && (rules.lte < this && this <= rules.gt)"
          "? 'value must be greater than %s or less than or equal to %s'.format([rules.gt, rules.lte]) : ''"
      }
    ];

    // `gte` requires the duration field value to be greater than or equal to the
    // specified value (exclusive). If the value of `gte` is larger than a
    // specified `lt` or `lte`, the range is reversed, and the field value must
    // be outside the specified range. If the field value doesn't meet the
    // required conditions, an error message is generated.
    //
    // ```proto
    // message MyDuration {
    //  // duration must be greater than or equal to 5s [duration.gte]
    //  google.protobuf.Duration value = 1 [(buf.validate.field).duration.gte = { seconds: 5 }];
    //
    //  // duration must be greater than or equal to 5s and less than 10s [duration.gte_lt]
    //  google.protobuf.Duration another_value = 2 [(buf.validate.field).duration = { gte: { seconds: 5 }, lt: { seconds: 10 } }];
    //
    //  // duration must be greater than or equal to 10s or less than 5s [duration.gte_lt_exclusive]
    //  google.protobuf.Duration other_value = 3 [(buf.validate.field).duration = { gte: { seconds: 10 }, lt: { seconds: 5 } }];
    // }
    // ```
    google.protobuf.Duration gte = 6 [
      (predefined).cel = {
        id: "duration.gte"
        expression:
          "!has(rules.lt) && !has(rules.lte) && this < rules.gte"
          "? 'value must be greater than or equal to %s'.format([rules.gte]) : ''"
      },
      (predefined).cel = {
        id: "duration.gte_lt"
        expression:
          "has(rules.lt) && rules.lt >= rules.gte && (this >= rules.lt || this < rules.gte)"
          "? 'value must be greater than or equal to %s and less than %s'.format([rules.gte, rules.lt]) : ''"
      },
      (predefined).cel = {
        id: "duration.gte_lt_exclusive"
        expression:
          "has(rules.lt) && rules.lt < rules.gte && (rules.lt <= this && this < rules.gte)"
          "? 'value must be greater than or equal to %s or less than %s'.format([rules.gte, rules.lt]) : ''"
      },
      (predefined).cel = {
        id: "duration.gte_lte"
        expression:
          "has(rules.lte) && rules.lte >= rules.gte && (this > rules.lte || this < rules.gte)"
          "? 'value must be greater than or equal to %s and less than or equal to %s'.format([rules.gte, rules.lte]) : ''"
      },
      (predefined).cel = {
        id: "duration.gte_lte_exclusive"
        expression:
          "has(rules.lte) && rules.lte < rules.gte && (rules.lte < this && this < rules.gte)"
          "? 'value must be greater than or equal to %s or less than or equal to %s'.format([rules.gte, rules.lte]) : ''"
      }
    ];
  }

  // `in` asserts that the field must be equal to one of the specified values of the `google.protobuf.Duration` type.
  // If the field's value doesn't correspond to any of the specified values,
  // an error message will be generated.
  //
  // ```proto
  // message MyDuration {
  //   // value must be in list [1s, 2s, 3s]
  //   google.protobuf.Duration value = 1 [(buf.validate.field).duration.in = ["1s", "2s", "3s"]];
  // }
  // ```
  repeated google.protobuf.Duration in = 7 [(predefined).cel = {
    id: "duration.in"
    expression: "!(this in getField(rules, 'in')) ? 'value must be in list %s'.format([getField(rules, 'in')]) : ''"
  }];

  // `not_in` denotes that the field must not be equal to
  // any of the specified values of the `google.protobuf.Duration` type.
  // If the field's value matches any of these values, an error message will be
  // generated.
  //
  // ```proto
  // message MyDuration {
  //   // value must not be in list [1s, 2s, 3s]
  //   google.protobuf.Duration value = 1 [(buf.validate.field).duration.not_in = ["1s", "2s", "3s"]];
  // }
  // ```
  repeated google.protobuf.Duration not_in = 8 [(predefined).cel = {
    id: "duration.not_in"
    expression: "this in rules.not_in ? 'value must not be in list %s'.format([rules.not_in]) : ''"
  }];

  // `example` specifies values that the field may have. These values SHOULD
  // conform to other rules. `example` values will not impact validation
  // but may be used as helpful guidance on how to populate the given field.
  //
  // ```proto
  // message MyDuration {
  //   google.protobuf.Duration value = 1 [
  //     (buf.validate.field).duration.example = { seconds: 1 },
  //     (buf.validate.field).duration.example = { seconds: 2 },
  //   ];
  // }
  // ```
  repeated google.protobuf.Duration example = 9 [(predefined).cel = {
    id: "duration.example"
    expression: "true"
  }];

  // Extension fields in this range that have the (buf.validate.predefined)
  // option set will be treated as predefined field rules that can then be
  // set on the field options of other fields to apply field rules.
  // Extension numbers 1000 to 99999 are reserved for extension numbers that are
  // defined in the [Protobuf Global Extension Registry][1]. Extension numbers
  // above this range are reserved for extension numbers that are not explicitly
  // assigned. For rules defined in publicly-consumed schemas, use of extensions
  // above 99999 is discouraged due to the risk of conflicts.
  //
  // [1]: https://github.com/protocolbuffers/protobuf/blob/main/docs/options.md
  extensions 1000 to max;
}

// FieldMaskRules describe rules applied exclusively to the `google.protobuf.FieldMask` well-known type.
message FieldMaskRules {
  // `const` dictates that the field must match the specified value of the `google.protobuf.FieldMask` type exactly.
  // If the field's value deviates from the specified value, an error message
  // will be generated.
  //
  // ```proto
  // message MyFieldMask {
  //   // value must equal ["a"]
  //   google.protobuf.FieldMask value = 1 [(buf.validate.field).field_mask.const = {
  //       paths: ["a"]
  //   }];
  // }
  // ```
  optional google.protobuf.FieldMask const = 1 [(predefined).cel = {
    id: "field_mask.const"
    expression: "this.paths != getField(rules, 'const').paths ? 'value must equal paths %s'.format([getField(rules, 'const').paths]) : ''"
  }];

  // `in` requires the field value to only contain paths matching specified
  // values or their subpaths.
  // If any of the field value's paths doesn't match the rule,
  // an error message is generated.
  // See: https://protobuf.dev/reference/protobuf/google.protobuf/#field-mask
  //
  // ```proto
  // message MyFieldMask {
  //   //  The `value` FieldMask must only contain paths listed in `in`.
  //   google.protobuf.FieldMask value = 1 [(buf.validate.field).field_mask = {
  //       in: ["a", "b", "c.a"]
  //   }];
  // }
  // ```
  repeated string in = 2 [(predefined).cel = {
    id: "field_mask.in"
    expression: "!this.paths.all(p, p in getField(rules, 'in') || getField(rules, 'in').exists(f, p.startsWith(f+'.'))) ? 'value must only contain paths in %s'.format([getField(rules, 'in')]) : ''"
  }];

  // `not_in` requires the field value to not contain paths matching specified
  // values or their subpaths.
  // If any of the field value's paths matches the rule,
  // an error message is generated.
  // See: https://protobuf.dev/reference/protobuf/google.protobuf/#field-mask
  //
  // ```proto
  // message MyFieldMask {
  //   //  The `value` FieldMask shall not contain paths listed in `not_in`.
  //   google.protobuf.FieldMask value = 1 [(buf.validate.field).field_mask = {
  //       not_in: ["forbidden", "immutable", "c.a"]
  //   }];
  // }
  // ```
  repeated string not_in = 3 [(predefined).cel = {
    id: "field_mask.not_in"
    expression: "!this.paths.all(p, !(p in getField(rules, 'not_in') || getField(rules, 'not_in').exists(f, p.startsWith(f+'.')))) ? 'value must not contain any paths in %s'.format([getField(rules, 'not_in')]) : ''"
  }];

  // `example` specifies values that the field may have. These values SHOULD
  // conform to other rules. `example` values will not impact validation
  // but may be used as helpful guidance on how to populate the given field.
  //
  // ```proto
  // message MyFieldMask {
  //   google.protobuf.FieldMask value = 1 [
  //     (buf.validate.field).field_mask.example = { paths: ["a", "b"] },
  //     (buf.validate.field).field_mask.example = { paths: ["c.a", "d"] },
  //   ];
  // }
  // ```
  repeated google.protobuf.FieldMask example = 4 [(predefined).cel = {
    id: "field_mask.example"
    expression: "true"
  }];

  // Extension fields in this range that have the (buf.validate.predefined)
  // option set will be treated as predefined field rules that can then be
  // set on the field options of other fields to apply field rules.
  // Extension numbers 1000 to 99999 are reserved for extension numbers that are
  // defined in the [Protobuf Global Extension Registry][1]. Extension numbers
  // above this range are reserved for extension numbers that are not explicitly
  // assigned. For rules defined in publicly-consumed schemas, use of extensions
  // above 99999 is discouraged due to the risk of conflicts.
  //
  // [1]: https://github.com/protocolbuffers/protobuf/blob/main/docs/options.md
  extensions 1000 to max;
}

// TimestampRules describe the rules applied exclusively to the `google.protobuf.Timestamp` well-known type.
message TimestampRules {
  // `const` dictates that this field, of the `google.protobuf.Timestamp` type, must exactly match the specified value. If the field value doesn't correspond to the specified timestamp, an error message will be generated.
  //
  // ```proto
  // message MyTimestamp {
  //   // value must equal 2023-05-03T10:00:00Z
  //   google.protobuf.Timestamp created_at = 1 [(buf.validate.field).timestamp.const = {seconds: 1727998800}];
  // }
  // ```
  optional google.protobuf.Timestamp const = 2 [(predefined).cel = {
    id: "timestamp.const"
    expression: "this != getField(rules, 'const') ? 'value must equal %s'.format([getField(rules, 'const')]) : ''"
  }];
  oneof less_than {
    // requires the duration field value to be less than the specified value (field < value). If the field value doesn't meet the required conditions, an error message is generated.
    //
    // ```proto
    // message MyDuration {
    //   // duration must be less than 'P3D' [duration.lt]
    //   google.protobuf.Duration value = 1 [(buf.validate.field).duration.lt = { seconds: 259200 }];
    // }
    // ```
    google.protobuf.Timestamp lt = 3 [(predefined).cel = {
      id: "timestamp.lt"
      expression:
        "!has(rules.gte) && !has(rules.gt) && this >= rules.lt"
        "? 'value must be less than %s'.format([rules.lt]) : ''"
    }];

    // requires the timestamp field value to be less than or equal to the specified value (field <= value). If the field value doesn't meet the required conditions, an error message is generated.
    //
    // ```proto
    // message MyTimestamp {
    //   // timestamp must be less than or equal to '2023-05-14T00:00:00Z' [timestamp.lte]
    //   google.protobuf.Timestamp value = 1 [(buf.validate.field).timestamp.lte = { seconds: 1678867200 }];
    // }
    // ```
    google.protobuf.Timestamp lte = 4 [(predefined).cel = {
      id: "timestamp.lte"
      expression:
        "!has(rules.gte) && !has(rules.gt) && this > rules.lte"
        "? 'value must be less than or equal to %s'.format([rules.lte]) : ''"
    }];

    // `lt_now` specifies that this field, of the `google.protobuf.Timestamp` type, must be less than the current time. `lt_now` can only be used with the `within` rule.
    //
    // ```proto
    // message MyTimestamp {
    //  // value must be less than now
    //   google.protobuf.Timestamp created_at = 1 [(buf.validate.field).timestamp.lt_now = true];
    // }
    // ```
    bool lt_now = 7 [(predefined).cel = {
      id: "timestamp.lt_now"
      expression: "(rules.lt_now && this > now) ? 'value must be less than now' : ''"
    }];
  }
  oneof greater_than {
    // `gt` requires the timestamp field value to be greater than the specified
    // value (exclusive). If the value of `gt` is larger than a specified `lt`
    // or `lte`, the range is reversed, and the field value must be outside the
    // specified range. If the field value doesn't meet the required conditions,
    // an error message is generated.
    //
    // ```proto
    // message MyTimestamp {
    //   // timestamp must be greater than '2023-01-01T00:00:00Z' [timestamp.gt]
    //   google.protobuf.Timestamp value = 1 [(buf.validate.field).timestamp.gt = { seconds: 1672444800 }];
    //
    //   // timestamp must be greater than '2023-01-01T00:00:00Z' and less than '2023-01-02T00:00:00Z' [timestamp.gt_lt]
    //   google.protobuf.Timestamp another_value = 2 [(buf.validate.field).timestamp = { gt: { seconds: 1672444800 }, lt: { seconds: 1672531200 } }];
    //
    //   // timestamp must be greater than '2023-01-02T00:00:00Z' or less than '2023-01-01T00:00:00Z' [timestamp.gt_lt_exclusive]
    //   google.protobuf.Timestamp other_value = 3 [(buf.validate.field).timestamp = { gt: { seconds: 1672531200 }, lt: { seconds: 1672444800 } }];
    // }
    // ```
    google.protobuf.Timestamp gt = 5 [
      (predefined).cel = {
        id: "timestamp.gt"
        expression:
          "!has(rules.lt) && !has(rules.lte) && this <= rules.gt"
          "? 'value must be greater than %s'.format([rules.gt]) : ''"
      },
      (predefined).cel = {
        id: "timestamp.gt_lt"
        expression:
          "has(rules.lt) && rules.lt >= rules.gt && (this >= rules.lt || this <= rules.gt)"
          "? 'value must be greater than %s and less than %s'.format([rules.gt, rules.lt]) : ''"
      },
      (predefined).cel = {
        id: "timestamp.gt_lt_exclusive"
        expression:
          "has(rules.lt) && rules.lt < rules.gt && (rules.lt <= this && this <= rules.gt)"
          "? 'value must be greater than %s or less than %s'.format([rules.gt, rules.lt]) : ''"
      },
      (predefined).cel = {
        id: "timestamp.gt_lte"
        expression:
          "has(rules.lte) && rules.lte >= rules.gt && (this > rules.lte || this <= rules.gt)"
          "? 'value must be greater than %s and less than or equal to %s'.format([rules.gt, rules.lte]) : ''"
      },
      (predefined).cel = {
        id: "timestamp.gt_lte_exclusive"
        expression:
          "has(rules.lte) && rules.lte < rules.gt && (rules.lte < this && this <= rules.gt)"
          "? 'value must be greater than %s or less than or equal to %s'.format([rules.gt, rules.lte]) : ''"
      }
    ];

    // `gte` requires the timestamp field value to be greater than or equal to the
    // specified value (exclusive). If the value of `gte` is larger than a
    // specified `lt` or `lte`, the range is reversed, and the field value
    // must be outside the specified range. If the field value doesn't meet
    // the required conditions, an error message is generated.
    //
    // ```proto
    // message MyTimestamp {
    //   // timestamp must be greater than or equal to '2023-01-01T00:00:00Z' [timestamp.gte]
    //   google.protobuf.Timestamp value = 1 [(buf.validate.field).timestamp.gte = { seconds: 1672444800 }];
    //
    //   // timestamp must be greater than or equal to '2023-01-01T00:00:00Z' and less than '2023-01-02T00:00:00Z' [timestamp.gte_lt]
    //   google.protobuf.Timestamp another_value = 2 [(buf.validate.field).timestamp = { gte: { seconds: 1672444800 }, lt: { seconds: 1672531200 } }];
    //
    //   // timestamp must be greater than or equal to '2023-01-02T00:00:00Z' or less than '2023-01-01T00:00:00Z' [timestamp.gte_lt_exclusive]
    //   google.protobuf.Timestamp other_value = 3 [(buf.validate.field).timestamp = { gte: { seconds: 1672531200 }, lt: { seconds: 1672444800 } }];
    // }
    // ```
    google.protobuf.Timestamp gte = 6 [
      (predefined).cel = {
        id: "timestamp.gte"
        expression:
          "!has(rules.lt) && !has(rules.lte) && this < rules.gte"
          "? 'value must be greater than or equal to %s'.format([rules.gte]) : ''"
      },
      (predefined).cel = {
        id: "timestamp.gte_lt"
        expression:
          "has(rules.lt) && rules.lt >= rules.gte && (this >= rules.lt || this < rules.gte)"
          "? 'value must be greater than or equal to %s and less than %s'.format([rules.gte, rules.lt]) : ''"
      },
      (predefined).cel = {
        id: "timestamp.gte_lt_exclusive"
        expression:
          "has(rules.lt) && rules.lt < rules.gte && (rules.lt <= this && this < rules.gte)"
          "? 'value must be greater than or equal to %s or less than %s'.format([rules.gte, rules.lt]) : ''"
      },
      (predefined).cel = {
        id: "timestamp.gte_lte"
        expression:
          "has(rules.lte) && rules.lte >= rules.gte && (this > rules.lte || this < rules.gte)"
          "? 'value must be greater than or equal to %s and less than or equal to %s'.format([rules.gte, rules.lte]) : ''"
      },
      (predefined).cel = {
        id: "timestamp.gte_lte_exclusive"
        expression:
          "has(rules.lte) && rules.lte < rules.gte && (rules.lte < this && this < rules.gte)"
          "? 'value must be greater than or equal to %s or less than or equal to %s'.format([rules.gte, rules.lte]) : ''"
      }
    ];

    // `gt_now` specifies that this field, of the `google.protobuf.Timestamp` type, must be greater than the current time. `gt_now` can only be used with the `within` rule.
    //
    // ```proto
    // message MyTimestamp {
    //   // value must be greater than now
    //   google.protobuf.Timestamp created_at = 1 [(buf.validate.field).timestamp.gt_now = true];
    // }
    // ```
    bool gt_now = 8 [(predefined).cel = {
      id: "timestamp.gt_now"
      expression: "(rules.gt_now && this < now) ? 'value must be greater than now' : ''"
    }];
  }

  // `within` specifies that this field, of the `google.protobuf.Timestamp` type, must be within the specified duration of the current time. If the field value isn't within the duration, an error message is generated.
  //
  // ```proto
  // message MyTimestamp {
  //   // value must be within 1 hour of now
  //   google.protobuf.Timestamp created_at = 1 [(buf.validate.field).timestamp.within = {seconds: 3600}];
  // }
  // ```
  optional google.protobuf.Duration within = 9 [(predefined).cel = {
    id: "timestamp.within"
    expression: "this < now-rules.within || this > now+rules.within ? 'value must be within %s of now'.format([rules.within]) : ''"
  }];

  // `example` specifies values that the field may have. These values SHOULD
  // conform to other rules. `example` values will not impact validation
  // but may be used as helpful guidance on how to populate the given field.
  //
  // ```proto
  // message MyTimestamp {
  //   google.protobuf.Timestamp value = 1 [
  //     (buf.validate.field).timestamp.example = { seconds: 1672444800 },
  //     (buf.validate.field).timestamp.example = { seconds: 1672531200 },
  //   ];
  // }
  // ```
  repeated google.protobuf.Timestamp example = 10 [(predefined).cel = {
    id: "timestamp.example"
    expression: "true"
  }];

  // Extension fields in this range that have the (buf.validate.predefined)
  // option set will be treated as predefined field rules that can then be
  // set on the field options of other fields to apply field rules.
  // Extension numbers 1000 to 99999 are reserved for extension numbers that are
  // defined in the [Protobuf Global Extension Registry][1]. Extension numbers
  // above this range are reserved for extension numbers that are not explicitly
  // assigned. For rules defined in publicly-consumed schemas, use of extensions
  // above 99999 is discouraged due to the risk of conflicts.
  //
  // [1]: https://github.com/protocolbuffers/protobuf/blob/main/docs/options.md
  extensions 1000 to max;
}

// `Violations` is a collection of `Violation` messages. This message type is returned by
// Protovalidate when a proto message fails to meet the requirements set by the `Rule` validation rules.
// Each individual violation is represented by a `Violation` message.
message Violations {
  // `violations` is a repeated field that contains all the `Violation` messages corresponding to the violations detected.
  repeated Violation violations = 1;
}

// `Violation` represents a single instance where a validation rule, expressed
// as a `Rule`, was not met. It provides information about the field that
// caused the violation, the specific rule that wasn't fulfilled, and a
// human-readable error message.
//
// For example, consider the following message:
//
// ```proto
// message User {
//     int32 age = 1 [(buf.validate.field).cel = {
//         id: "user.age",
//         expression: "this < 18 ? 'User must be at least 18 years old' : ''",
//     }];
// }
// ```
//
// It could produce the following violation:
//
// ```json
// {
//   "ruleId": "user.age",
//   "message": "User must be at least 18 years old",
//   "field": {
//     "elements": [
//       {
//         "fieldNumber": 1,
//         "fieldName": "age",
//         "fieldType": "TYPE_INT32"
//       }
//     ]
//   },
//   "rule": {
//     "elements": [
//       {
//         "fieldNumber": 23,
//         "fieldName": "cel",
//         "fieldType": "TYPE_MESSAGE",
//         "index": "0"
//       }
//     ]
//   }
// }
// ```
message Violation {
  // `field` is a machine-readable path to the field that failed validation.
  // This could be a nested field, in which case the path will include all the parent fields leading to the actual field that caused the violation.
  //
  // For example, consider the following message:
  //
  // ```proto
  // message Message {
  //   bool a = 1 [(buf.validate.field).required = true];
  // }
  // ```
  //
  // It could produce the following violation:
  //
  // ```textproto
  // violation {
  //   field { element { field_number: 1, field_name: "a", field_type: 8 } }
  //   ...
  // }
  // ```
  optional FieldPath field = 5;

  // `rule` is a machine-readable path that points to the specific rule that failed validation.
  // This will be a nested field starting from the FieldRules of the field that failed validation.
  // For custom rules, this will provide the path of the rule, e.g. `cel[0]`.
  //
  // For example, consider the following message:
  //
  // ```proto
  // message Message {
  //   bool a = 1 [(buf.validate.field).required = true];
  //   bool b = 2 [(buf.validate.field).cel = {
  //     id: "custom_rule",
  //     expression: "!this ? 'b must be true': ''"
  //   }]
  // }
  // ```
  //
  // It could produce the following violations:
  //
  // ```textproto
  // violation {
  //   rule { element { field_number: 25, field_name: "required", field_type: 8 } }
  //   ...
  // }
  // violation {
  //   rule { element { field_number: 23, field_name: "cel", field_type: 11, index: 0 } }
  //   ...
  // }
  // ```
  optional FieldPath rule = 6;

  // `rule_id` is the unique identifier of the `Rule` that was not fulfilled.
  // This is the same `id` that was specified in the `Rule` message, allowing easy tracing of which rule was violated.
  optional string rule_id = 2;

  // `message` is a human-readable error message that describes the nature of the violation.
  // This can be the default error message from the violated `Rule`, or it can be a custom message that gives more context about the violation.
  optional string message = 3;

  // `for_key` indicates whether the violation was caused by a map key, rather than a value.
  optional bool for_key = 4;

  reserved 1;
  reserved "field_path";
}

// `FieldPath` provides a path to a nested protobuf field.
//
// This message provides enough information to render a dotted field path even without protobuf descriptors.
// It also provides enough information to resolve a nested field through unknown wire data.
message FieldPath {
  // `elements` contains each element of the path, starting from the root and recursing downward.
  repeated FieldPathElement elements = 1;
}

// `FieldPathElement` provides enough information to nest through a single protobuf field.
//
// If the selected field is a map or repeated field, the `subscript` value selects a specific element from it.
// A path that refers to a value nested under a map key or repeated field index will have a `subscript` value.
// The `field_type` field allows unambiguous resolution of a field even if descriptors are not available.
message FieldPathElement {
  // `field_number` is the field number this path element refers to.
  optional int32 field_number = 1;

  // `field_name` contains the field name this path element refers to.
  // This can be used to display a human-readable path even if the field number is unknown.
  optional string field_name = 2;

  // `field_type` specifies the type of this field. When using reflection, this value is not needed.
  //
  // This value is provided to make it possible to traverse unknown fields through wire data.
  // When traversing wire data, be mindful of both packed[1] and delimited[2] encoding schemes.
  //
  // [1]: https://protobuf.dev/programming-guides/encoding/#packed
  // [2]: https://protobuf.dev/programming-guides/encoding/#groups
  //
  // N.B.: Although groups are deprecated, the corresponding delimited encoding scheme is not, and
  // can be explicitly used in Protocol Buffers 2023 Edition.
  optional google.protobuf.FieldDescriptorProto.Type field_type = 3;

  // `key_type` specifies the map key type of this field. This value is useful when traversing
  // unknown fields through wire data: specifically, it allows handling the differences between
  // different integer encodings.
  optional google.protobuf.FieldDescriptorProto.Type key_type = 4;

  // `value_type` specifies map value type of this field. This is useful if you want to display a
  // value inside unknown fields through wire data.
  optional google.protobuf.FieldDescriptorProto.Type value_type = 5;

  // `subscript` contains a repeated index or map key, if this path element nests into a repeated or map field.
  oneof subscript {
    // `index` specifies a 0-based index into a repeated field.
    uint64 index = 6;

    // `bool_key` specifies a map key of type bool.
    bool bool_key = 7;

    // `int_key` specifies a map key of type int32, int64, sint32, sint64, sfixed32 or sfixed64.
    int64 int_key = 8;

    // `uint_key` specifies a map key of type uint32, uint64, fixed32 or fixed64.
    uint64 uint_key = 9;

    // `string_key` specifies a map key of type string.
    string string_key = 10;
  }
}
