syntax = "proto3";

package a;

import "buf/validate/validate.proto";
import "google/protobuf/any.proto";
import "google/protobuf/duration.proto";
import "google/protobuf/timestamp.proto";

message Foo {
  // cannot have equal `gt` and `lt` rules on the same field
  float equal_gt_lt = 1 [
    (buf.validate.field).float.gt = 1,
    (buf.validate.field).float.lt = 1
  ];
  // cannot have equal `gte` and `lt` rules on the same field
  float equal_gte_lt = 2 [
    (buf.validate.field).float.gte = 1,
    (buf.validate.field).float.lt = 1
  ];
  // cannot have equal `gt` and `lte` rules on the same field
  float equal_gt_lte = 3 [
    (buf.validate.field).float.gt = 1,
    (buf.validate.field).float.lte = 1
  ];
  // use `const` instead of equal `lte` and `gte` rules
  float equal_gte_lte = 4 [
    (buf.validate.field).float.gte = 1,
    (buf.validate.field).float.lte = 1
  ];
  // Checks if `repeated` rule is used for repeated fields.
  float not_repeated_float = 5 [(buf.validate.field).repeated.unique = true];
  // Prevents simultaneous use of `in` and `not_in` rules on the same field.
  float not_in_float = 6 [(buf.validate.field).float = {
    not_in: [1]
    in: [1]
  }];
  // Checks if `prefix` length exceeds `max_len` constraint.
  string prefix_max_len = 7 [
    (buf.validate.field).string.prefix = "ab",
    (buf.validate.field).string.max_len = 1
  ];
  // Checks if `suffix` length exceeds `max_len` constraint.
  string suffix_max_len = 8 [
    (buf.validate.field).string.suffix = "ab",
    (buf.validate.field).string.max_len = 1
  ];
  // Checks if `contains` length exceeds `max_len` constraint.
  string contains_max_len = 9 [
    (buf.validate.field).string.contains = "ab",
    (buf.validate.field).string.max_len = 1
  ];
  // Ensures `max_len` doesn't exceed `max_bytes` constraint.
  string max_len_bytes_conflict = 10 [
    (buf.validate.field).string.max_len = 2,
    (buf.validate.field).string.max_bytes = 1
  ];
  // Prevents simultaneous use of `len` and `min_len` rules.
  string len_min_len_conflict = 11 [
    (buf.validate.field).string.len = 1,
    (buf.validate.field).string.min_len = 2
  ];
  // Prevents simultaneous use of `len` and `max_len` rules.
  string len_max_len_conflict = 12 [
    (buf.validate.field).string.len = 2,
    (buf.validate.field).string.max_len = 1
  ];
  // Ensures `min_len` value is less than `max_len` value.
  string min_gt_max_len = 13 [
    (buf.validate.field).string.min_len = 2,
    (buf.validate.field).string.max_len = 1
  ];
  // Detects incompatibility between `well_known_regex` and `pattern` rules.
  string regex_well_known_conflict = 14 [
    (buf.validate.field).string.well_known_regex = KNOWN_REGEX_HTTP_HEADER_NAME,
    (buf.validate.field).string.pattern = "ab"
  ];
  // Detects incompatibility between `pattern` and `in` rules.
  string regex_pattern_in_conflict = 15 [(buf.validate.field).string = {
    pattern: "ab.*"
    in: ["a"]
  }];
  // Validates the syntax of the regex `pattern`.
  string regex_pattern_parse = 16 [(buf.validate.field).string.pattern = "ab"];
  // Reports unexpected field type during validation.
  string unexpected_type = 17 [(buf.validate.field).int32 = {const: 1}];
  // Detects conflict between undefined `in` value and `defined_only` rule.
  enum UndefinedInConflict {
    UNDEFINED_IN_CONFLICT_UNDEFINED_IN_CONFLICT = 0;
  }
  UndefinedInConflict undefined_in_conflict = 18 [(buf.validate.field).enum = {
    defined_only: true
    in: [1]
  }];
  // Checks if `prefix` length exceeds `max_bytes` constraint.
  string prefix_max_len_bytes_conflict = 19 [
    (buf.validate.field).string.prefix = "ab",
    (buf.validate.field).string.max_bytes = 1
  ];
  // Checks if `suffix` length exceeds `max_bytes` constraint.
  string suffix_max_len_bytes_conflict = 20 [
    (buf.validate.field).string.suffix = "ab",
    (buf.validate.field).string.max_bytes = 1
  ];
  // Checks if `contains` length exceeds `max_bytes` constraint.
  string contains_max_len_bytes_conflict = 21 [
    (buf.validate.field).string.contains = "ab",
    (buf.validate.field).string.max_bytes = 1
  ];
  // Ensures the `unique` rule is only used for scalar types.
  message baz {}
  repeated baz unique_scalar = 22 [(buf.validate.field).repeated.unique = true];
  // Verifies the resolution of duration values.
  google.protobuf.Duration duration_resolution = 25 [(buf.validate.field).duration = {
    gt: {seconds: -1}
  }];
  // Prevents the use of both `now` rules together.
  google.protobuf.Timestamp now_both_rules = 26 [(buf.validate.field).timestamp = {
    gt_now: true
    lt_now: true
  }];
  // Validates that `within` rule is positive and non-zero.
  google.protobuf.Timestamp within_positive = 27 [(buf.validate.field).timestamp = {
    within: {seconds: 0}
  }];
  // Verifies the resolution of timestamp values.
  google.protobuf.Timestamp timestamp_resolution = 28 [(buf.validate.field).timestamp = {
    gt: {seconds: 864010000000}
  }];
  // VALIDATE_NO_CUSTOM_CEL_ON_ANYPB - Assists with protecting against CELs
  // that use custom functions on google.protobuf.Any fields.
  google.protobuf.Any anypb = 29 [(buf.validate.field).cel = {
    id: "foo.anypb",
    message: "no can do with anypb"
    expression: "this.type_url != this.value"
  }];
  // Checks if `prefix` length exceeds `max_len` constraint.
  bytes prefix_max_len_bytes = 30 [
    (buf.validate.field).bytes.prefix = "ab",
    (buf.validate.field).bytes.max_len = 1
  ];
  // Checks if `suffix` length exceeds `max_len` constraint.
  bytes suffix_max_len_bytes = 31 [
    (buf.validate.field).bytes.suffix = "ab",
    (buf.validate.field).bytes.max_len = 1
  ];
  // Checks if `contains` length exceeds `max_len` constraint.
  bytes contains_max_len_bytes = 32 [
    (buf.validate.field).bytes.contains = "ab",
    (buf.validate.field).bytes.max_len = 1
  ];
  // Prevents simultaneous use of `len` and `min_len` rules.
  bytes len_min_len_conflict_bytes = 33 [
    (buf.validate.field).bytes.len = 1,
    (buf.validate.field).bytes.min_len = 2
  ];
  // Prevents simultaneous use of `len` and `max_len` rules.
  bytes len_max_len_conflict_bytes = 34 [
    (buf.validate.field).bytes.len = 2,
    (buf.validate.field).bytes.max_len = 1
  ];
  // Ensures `min_len` value is less than `max_len` value.
  bytes min_gt_max_len_bytes = 35 [
    (buf.validate.field).bytes.min_len = 2,
    (buf.validate.field).bytes.max_len = 1
  ];
}
