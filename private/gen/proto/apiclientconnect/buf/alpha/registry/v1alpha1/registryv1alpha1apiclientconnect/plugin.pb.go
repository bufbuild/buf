// Copyright 2020-2022 Buf Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by protoc-gen-go-apiclientconnect. DO NOT EDIT.

package registryv1alpha1apiclientconnect

import (
	context "context"
	registryv1alpha1connect "github.com/bufbuild/buf/private/gen/proto/connect/buf/alpha/registry/v1alpha1/registryv1alpha1connect"
	v1alpha1 "github.com/bufbuild/buf/private/gen/proto/go/buf/alpha/registry/v1alpha1"
	connect_go "github.com/bufbuild/connect-go"
	zap "go.uber.org/zap"
)

type pluginServiceClient struct {
	logger *zap.Logger
	client registryv1alpha1connect.PluginServiceClient
}

func (s *pluginServiceClient) Unwrap() registryv1alpha1connect.PluginServiceClient {
	return s.client
}

// ListPlugins returns all the plugins available to the user. This includes
// public plugins, those uploaded to organizations the user is part of,
// and any plugins uploaded directly by the user.
func (s *pluginServiceClient) ListPlugins(
	ctx context.Context,
	pageSize uint32,
	pageToken string,
	reverse bool,
) (plugins []*v1alpha1.Plugin, nextPageToken string, _ error) {
	response, err := s.client.ListPlugins(
		ctx,
		connect_go.NewRequest(
			&v1alpha1.ListPluginsRequest{
				PageSize:  pageSize,
				PageToken: pageToken,
				Reverse:   reverse,
			}),
	)
	if err != nil {
		return nil, "", err
	}
	return response.Msg.Plugins, response.Msg.NextPageToken, nil
}

// ListUserPlugins lists all plugins belonging to a user.
func (s *pluginServiceClient) ListUserPlugins(
	ctx context.Context,
	owner string,
	pageSize uint32,
	pageToken string,
	reverse bool,
) (plugins []*v1alpha1.Plugin, nextPageToken string, _ error) {
	response, err := s.client.ListUserPlugins(
		ctx,
		connect_go.NewRequest(
			&v1alpha1.ListUserPluginsRequest{
				Owner:     owner,
				PageSize:  pageSize,
				PageToken: pageToken,
				Reverse:   reverse,
			}),
	)
	if err != nil {
		return nil, "", err
	}
	return response.Msg.Plugins, response.Msg.NextPageToken, nil
}

// ListOrganizationPlugins lists all plugins for an organization.
func (s *pluginServiceClient) ListOrganizationPlugins(
	ctx context.Context,
	organization string,
	pageSize uint32,
	pageToken string,
	reverse bool,
) (plugins []*v1alpha1.Plugin, nextPageToken string, _ error) {
	response, err := s.client.ListOrganizationPlugins(
		ctx,
		connect_go.NewRequest(
			&v1alpha1.ListOrganizationPluginsRequest{
				Organization: organization,
				PageSize:     pageSize,
				PageToken:    pageToken,
				Reverse:      reverse,
			}),
	)
	if err != nil {
		return nil, "", err
	}
	return response.Msg.Plugins, response.Msg.NextPageToken, nil
}

// GetPluginVersion returns the plugin version, if found.
func (s *pluginServiceClient) GetPluginVersion(
	ctx context.Context,
	owner string,
	name string,
	version string,
) (pluginVersion *v1alpha1.PluginVersion, _ error) {
	response, err := s.client.GetPluginVersion(
		ctx,
		connect_go.NewRequest(
			&v1alpha1.GetPluginVersionRequest{
				Owner:   owner,
				Name:    name,
				Version: version,
			}),
	)
	if err != nil {
		return nil, err
	}
	return response.Msg.PluginVersion, nil
}

// ListPluginVersions lists all the versions available for the specified plugin.
func (s *pluginServiceClient) ListPluginVersions(
	ctx context.Context,
	owner string,
	name string,
	pageSize uint32,
	pageToken string,
	reverse bool,
) (pluginVersions []*v1alpha1.PluginVersion, nextPageToken string, _ error) {
	response, err := s.client.ListPluginVersions(
		ctx,
		connect_go.NewRequest(
			&v1alpha1.ListPluginVersionsRequest{
				Owner:     owner,
				Name:      name,
				PageSize:  pageSize,
				PageToken: pageToken,
				Reverse:   reverse,
			}),
	)
	if err != nil {
		return nil, "", err
	}
	return response.Msg.PluginVersions, response.Msg.NextPageToken, nil
}

// CreatePlugin creates a new plugin.
func (s *pluginServiceClient) CreatePlugin(
	ctx context.Context,
	owner string,
	name string,
	visibility v1alpha1.PluginVisibility,
) (plugin *v1alpha1.Plugin, _ error) {
	response, err := s.client.CreatePlugin(
		ctx,
		connect_go.NewRequest(
			&v1alpha1.CreatePluginRequest{
				Owner:      owner,
				Name:       name,
				Visibility: visibility,
			}),
	)
	if err != nil {
		return nil, err
	}
	return response.Msg.Plugin, nil
}

// GetPlugin returns the plugin, if found.
func (s *pluginServiceClient) GetPlugin(
	ctx context.Context,
	owner string,
	name string,
) (plugin *v1alpha1.Plugin, _ error) {
	response, err := s.client.GetPlugin(
		ctx,
		connect_go.NewRequest(
			&v1alpha1.GetPluginRequest{
				Owner: owner,
				Name:  name,
			}),
	)
	if err != nil {
		return nil, err
	}
	return response.Msg.Plugin, nil
}

// DeletePlugin deletes the plugin, if it exists. Note that deleting
// a plugin may cause breaking changes for templates using that plugin,
// and should be done with extreme care.
func (s *pluginServiceClient) DeletePlugin(
	ctx context.Context,
	owner string,
	name string,
) (_ error) {
	_, err := s.client.DeletePlugin(
		ctx,
		connect_go.NewRequest(
			&v1alpha1.DeletePluginRequest{
				Owner: owner,
				Name:  name,
			}),
	)
	if err != nil {
		return err
	}
	return nil
}

// SetPluginContributor sets the role of a user in the plugin.
func (s *pluginServiceClient) SetPluginContributor(
	ctx context.Context,
	pluginId string,
	userId string,
	pluginRole v1alpha1.PluginRole,
) (_ error) {
	_, err := s.client.SetPluginContributor(
		ctx,
		connect_go.NewRequest(
			&v1alpha1.SetPluginContributorRequest{
				PluginId:   pluginId,
				UserId:     userId,
				PluginRole: pluginRole,
			}),
	)
	if err != nil {
		return err
	}
	return nil
}

// ListPluginContributors returns the list of contributors that has an explicit role against the plugin.
// This does not include users who have implicit roles against the plugin, unless they have also been
// assigned a role explicitly.
func (s *pluginServiceClient) ListPluginContributors(
	ctx context.Context,
	pluginId string,
	pageSize uint32,
	pageToken string,
	reverse bool,
) (users []*v1alpha1.PluginContributor, nextPageToken string, _ error) {
	response, err := s.client.ListPluginContributors(
		ctx,
		connect_go.NewRequest(
			&v1alpha1.ListPluginContributorsRequest{
				PluginId:  pluginId,
				PageSize:  pageSize,
				PageToken: pageToken,
				Reverse:   reverse,
			}),
	)
	if err != nil {
		return nil, "", err
	}
	return response.Msg.Users, response.Msg.NextPageToken, nil
}

// DeprecatePlugin deprecates the plugin, if found.
func (s *pluginServiceClient) DeprecatePlugin(
	ctx context.Context,
	owner string,
	name string,
	message string,
) (_ error) {
	_, err := s.client.DeprecatePlugin(
		ctx,
		connect_go.NewRequest(
			&v1alpha1.DeprecatePluginRequest{
				Owner:   owner,
				Name:    name,
				Message: message,
			}),
	)
	if err != nil {
		return err
	}
	return nil
}

// UndeprecatePlugin makes the plugin not deprecated and removes any deprecation_message.
func (s *pluginServiceClient) UndeprecatePlugin(
	ctx context.Context,
	owner string,
	name string,
) (_ error) {
	_, err := s.client.UndeprecatePlugin(
		ctx,
		connect_go.NewRequest(
			&v1alpha1.UndeprecatePluginRequest{
				Owner: owner,
				Name:  name,
			}),
	)
	if err != nil {
		return err
	}
	return nil
}

// GetTemplate returns the template, if found.
func (s *pluginServiceClient) GetTemplate(
	ctx context.Context,
	owner string,
	name string,
) (template *v1alpha1.Template, _ error) {
	response, err := s.client.GetTemplate(
		ctx,
		connect_go.NewRequest(
			&v1alpha1.GetTemplateRequest{
				Owner: owner,
				Name:  name,
			}),
	)
	if err != nil {
		return nil, err
	}
	return response.Msg.Template, nil
}

// ListTemplates returns all the templates available to the user. This includes
// public templates, those owned by organizations the user is part of,
// and any created directly by the user.
func (s *pluginServiceClient) ListTemplates(
	ctx context.Context,
	pageSize uint32,
	pageToken string,
	reverse bool,
) (templates []*v1alpha1.Template, nextPageToken string, _ error) {
	response, err := s.client.ListTemplates(
		ctx,
		connect_go.NewRequest(
			&v1alpha1.ListTemplatesRequest{
				PageSize:  pageSize,
				PageToken: pageToken,
				Reverse:   reverse,
			}),
	)
	if err != nil {
		return nil, "", err
	}
	return response.Msg.Templates, response.Msg.NextPageToken, nil
}

// ListTemplatesUserCanAccess is like ListTemplates, but does not return
// public templates.
func (s *pluginServiceClient) ListTemplatesUserCanAccess(
	ctx context.Context,
	pageSize uint32,
	pageToken string,
	reverse bool,
) (templates []*v1alpha1.Template, nextPageToken string, _ error) {
	response, err := s.client.ListTemplatesUserCanAccess(
		ctx,
		connect_go.NewRequest(
			&v1alpha1.ListTemplatesUserCanAccessRequest{
				PageSize:  pageSize,
				PageToken: pageToken,
				Reverse:   reverse,
			}),
	)
	if err != nil {
		return nil, "", err
	}
	return response.Msg.Templates, response.Msg.NextPageToken, nil
}

// ListUserPlugins lists all templates belonging to a user.
func (s *pluginServiceClient) ListUserTemplates(
	ctx context.Context,
	owner string,
	pageSize uint32,
	pageToken string,
	reverse bool,
) (templates []*v1alpha1.Template, nextPageToken string, _ error) {
	response, err := s.client.ListUserTemplates(
		ctx,
		connect_go.NewRequest(
			&v1alpha1.ListUserTemplatesRequest{
				Owner:     owner,
				PageSize:  pageSize,
				PageToken: pageToken,
				Reverse:   reverse,
			}),
	)
	if err != nil {
		return nil, "", err
	}
	return response.Msg.Templates, response.Msg.NextPageToken, nil
}

// ListOrganizationTemplates lists all templates for an organization.
func (s *pluginServiceClient) ListOrganizationTemplates(
	ctx context.Context,
	organization string,
	pageSize uint32,
	pageToken string,
	reverse bool,
) (templates []*v1alpha1.Template, nextPageToken string, _ error) {
	response, err := s.client.ListOrganizationTemplates(
		ctx,
		connect_go.NewRequest(
			&v1alpha1.ListOrganizationTemplatesRequest{
				Organization: organization,
				PageSize:     pageSize,
				PageToken:    pageToken,
				Reverse:      reverse,
			}),
	)
	if err != nil {
		return nil, "", err
	}
	return response.Msg.Templates, response.Msg.NextPageToken, nil
}

// GetTemplateVersion returns the template version, if found.
func (s *pluginServiceClient) GetTemplateVersion(
	ctx context.Context,
	owner string,
	name string,
	version string,
) (templateVersion *v1alpha1.TemplateVersion, _ error) {
	response, err := s.client.GetTemplateVersion(
		ctx,
		connect_go.NewRequest(
			&v1alpha1.GetTemplateVersionRequest{
				Owner:   owner,
				Name:    name,
				Version: version,
			}),
	)
	if err != nil {
		return nil, err
	}
	return response.Msg.TemplateVersion, nil
}

// ListTemplateVersions lists all the template versions available for the specified template.
func (s *pluginServiceClient) ListTemplateVersions(
	ctx context.Context,
	owner string,
	name string,
	pageSize uint32,
	pageToken string,
	reverse bool,
) (templateVersions []*v1alpha1.TemplateVersion, nextPageToken string, _ error) {
	response, err := s.client.ListTemplateVersions(
		ctx,
		connect_go.NewRequest(
			&v1alpha1.ListTemplateVersionsRequest{
				Owner:     owner,
				Name:      name,
				PageSize:  pageSize,
				PageToken: pageToken,
				Reverse:   reverse,
			}),
	)
	if err != nil {
		return nil, "", err
	}
	return response.Msg.TemplateVersions, response.Msg.NextPageToken, nil
}

// CreateTemplate creates a new template.
func (s *pluginServiceClient) CreateTemplate(
	ctx context.Context,
	owner string,
	name string,
	visibility v1alpha1.PluginVisibility,
	pluginConfigs []*v1alpha1.PluginConfig,
) (template *v1alpha1.Template, _ error) {
	response, err := s.client.CreateTemplate(
		ctx,
		connect_go.NewRequest(
			&v1alpha1.CreateTemplateRequest{
				Owner:         owner,
				Name:          name,
				Visibility:    visibility,
				PluginConfigs: pluginConfigs,
			}),
	)
	if err != nil {
		return nil, err
	}
	return response.Msg.Template, nil
}

// DeleteTemplate deletes the template, if it exists.
func (s *pluginServiceClient) DeleteTemplate(
	ctx context.Context,
	owner string,
	name string,
) (_ error) {
	_, err := s.client.DeleteTemplate(
		ctx,
		connect_go.NewRequest(
			&v1alpha1.DeleteTemplateRequest{
				Owner: owner,
				Name:  name,
			}),
	)
	if err != nil {
		return err
	}
	return nil
}

// CreateTemplateVersion creates a new template version.
func (s *pluginServiceClient) CreateTemplateVersion(
	ctx context.Context,
	name string,
	templateOwner string,
	templateName string,
	pluginVersions []*v1alpha1.PluginVersionMapping,
) (templateVersion *v1alpha1.TemplateVersion, _ error) {
	response, err := s.client.CreateTemplateVersion(
		ctx,
		connect_go.NewRequest(
			&v1alpha1.CreateTemplateVersionRequest{
				Name:           name,
				TemplateOwner:  templateOwner,
				TemplateName:   templateName,
				PluginVersions: pluginVersions,
			}),
	)
	if err != nil {
		return nil, err
	}
	return response.Msg.TemplateVersion, nil
}

// SetTemplateContributor sets the role of a user in the template.
func (s *pluginServiceClient) SetTemplateContributor(
	ctx context.Context,
	templateId string,
	userId string,
	templateRole v1alpha1.TemplateRole,
) (_ error) {
	_, err := s.client.SetTemplateContributor(
		ctx,
		connect_go.NewRequest(
			&v1alpha1.SetTemplateContributorRequest{
				TemplateId:   templateId,
				UserId:       userId,
				TemplateRole: templateRole,
			}),
	)
	if err != nil {
		return err
	}
	return nil
}

// ListTemplateContributors returns the list of contributors that has an explicit role against the template.
// This does not include users who have implicit roles against the template, unless they have also been
// assigned a role explicitly.
func (s *pluginServiceClient) ListTemplateContributors(
	ctx context.Context,
	templateId string,
	pageSize uint32,
	pageToken string,
	reverse bool,
) (users []*v1alpha1.TemplateContributor, nextPageToken string, _ error) {
	response, err := s.client.ListTemplateContributors(
		ctx,
		connect_go.NewRequest(
			&v1alpha1.ListTemplateContributorsRequest{
				TemplateId: templateId,
				PageSize:   pageSize,
				PageToken:  pageToken,
				Reverse:    reverse,
			}),
	)
	if err != nil {
		return nil, "", err
	}
	return response.Msg.Users, response.Msg.NextPageToken, nil
}

// DeprecateTemplate deprecates the template, if found.
func (s *pluginServiceClient) DeprecateTemplate(
	ctx context.Context,
	owner string,
	name string,
	message string,
) (_ error) {
	_, err := s.client.DeprecateTemplate(
		ctx,
		connect_go.NewRequest(
			&v1alpha1.DeprecateTemplateRequest{
				Owner:   owner,
				Name:    name,
				Message: message,
			}),
	)
	if err != nil {
		return err
	}
	return nil
}

// UndeprecateTemplate makes the template not deprecated and removes any deprecation_message.
func (s *pluginServiceClient) UndeprecateTemplate(
	ctx context.Context,
	owner string,
	name string,
) (_ error) {
	_, err := s.client.UndeprecateTemplate(
		ctx,
		connect_go.NewRequest(
			&v1alpha1.UndeprecateTemplateRequest{
				Owner: owner,
				Name:  name,
			}),
	)
	if err != nil {
		return err
	}
	return nil
}
