// Copyright 2020-2022 Buf Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package storagegodata provides a mechanism to embed data into a Golang file.
package storagegodata

import (
	"bytes"
	"context"
	"fmt"
	"go/format"
	"io"
	"math"
	"sort"

	"github.com/bufbuild/buf/private/pkg/storage"
)

const (
	// DefaultPackageName is the default package name used for generated Golang files.
	DefaultPackageName = "generated"

	sliceLength = math.MaxInt64
)

// Build builds a Golang file that contains the data for the given bucket.
func Build(ctx context.Context, bucket storage.ReadBucket, options ...BuildOption) ([]byte, error) {
	buildOptions := newBuildOptions()
	for _, option := range options {
		option(buildOptions)
	}
	if buildOptions.packageName == "" {
		buildOptions.packageName = DefaultPackageName
	}
	pathToData, err := getPathToData(ctx, bucket)
	if err != nil {
		return nil, err
	}
	return getGolangFileData(
		pathToData,
		buildOptions.packageName,
		buildOptions.programName,
	)
}

// BuildOption is an option for build.
type BuildOption func(*buildOptions)

// BuildWithPackageName returns a new BuildOption that sets the name of the package
// in the generated Golang file.
//
// The default is to use DefaultPackageName.
func BuildWithPackageName(packageName string) BuildOption {
	return func(buildOptions *buildOptions) {
		buildOptions.packageName = packageName
	}
}

// BuildWithProgramName returns a new BuildOption that results in a comment being
// added to the beginning of the generated file that says the code is generated
// by the given program.
//
// The default is to generate no header comment.
func BuildWithProgramName(programName string) BuildOption {
	return func(buildOptions *buildOptions) {
		buildOptions.programName = programName
	}
}

func getPathToData(ctx context.Context, bucket storage.ReadBucket) (map[string][]byte, error) {
	pathToData := make(map[string][]byte)
	if err := storage.WalkReadObjects(
		ctx,
		bucket,
		"",
		func(readObject storage.ReadObject) error {
			data, err := io.ReadAll(readObject)
			if err != nil {
				return err
			}
			pathToData[readObject.Path()] = data
			return nil
		},
	); err != nil {
		return nil, err
	}
	return pathToData, nil
}

func getGolangFileData(pathToData map[string][]byte, packageName string, programName string) ([]byte, error) {
	buffer := bytes.NewBuffer(nil)
	if programName != "" {
		_, _ = buffer.WriteString(`// Code generated by `)
		_, _ = buffer.WriteString(programName)
		_, _ = buffer.WriteString(`. DO NOT EDIT.

`)
	}
	_, _ = buffer.WriteString(`package `)
	_, _ = buffer.WriteString(packageName)
	_, _ = buffer.WriteString(`

import (
	"github.com/bufbuild/buf/private/pkg/storage"
	"github.com/bufbuild/buf/private/pkg/storage/storagemem"
	"github.com/bufbuild/buf/private/pkg/normalpath"
)

var (
	// ReadBucket is the storage.ReadBucket with the static data generated for this package.
	ReadBucket storage.ReadBucket

	pathToData = map[string][]byte{
`)

	paths := make([]string, 0, len(pathToData))
	for path := range pathToData {
		paths = append(paths, path)
	}
	sort.Strings(paths)

	for _, path := range paths {
		_, _ = buffer.WriteString(`"`)
		_, _ = buffer.WriteString(path)
		_, _ = buffer.WriteString(`": {
`)
		data := pathToData[path]
		for len(data) > 0 {
			n := sliceLength
			if n > len(data) {
				n = len(data)
			}
			accum := ""
			for _, elem := range data[:n] {
				accum += fmt.Sprintf("0x%02x,", elem)
			}
			_, _ = buffer.WriteString(accum)
			_, _ = buffer.WriteString("\n")
			data = data[n:]
		}
		_, _ = buffer.WriteString(`},
`)
	}
	_, _ = buffer.WriteString(`}
)

func init() {
	readBucket, err := storagemem.NewReadBucket(pathToData)
	if err != nil {
		panic(err.Error())
	}
	ReadBucket = readBucket
}

// Exists returns true if the given path exists in the static data.
//
// The path is normalized within this function.
func Exists(path string) bool {
	_, ok := pathToData[normalpath.Normalize(path)]
	return ok
}
`)

	return format.Source(buffer.Bytes())
}

type buildOptions struct {
	packageName string
	programName string
}

func newBuildOptions() *buildOptions {
	return &buildOptions{}
}
